// Generated by jextract

package io.github.kinsleykajiva.opusfile;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class opusfile_h extends opusfile_h$shared {

    opusfile_h() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup
            .libraryLookup(System.mapLibraryName("opusfile"), LIBRARY_ARENA)
            .or(SymbolLookup.loaderLookup())
            .or(Linker.nativeLinker().defaultLookup());

    private static final int __GNUC_VA_LIST = (int) 1L;

    /**
     * {@snippet lang = c : * #define __GNUC_VA_LIST 1
     * }
     */
    public static int __GNUC_VA_LIST() {
        return __GNUC_VA_LIST;
    }

    private static final int _VCRT_COMPILER_PREPROCESSOR = (int) 1L;

    /**
     * {@snippet lang = c : * #define _VCRT_COMPILER_PREPROCESSOR 1
     * }
     */
    public static int _VCRT_COMPILER_PREPROCESSOR() {
        return _VCRT_COMPILER_PREPROCESSOR;
    }

    private static final int _SAL_VERSION = (int) 20L;

    /**
     * {@snippet lang = c : * #define _SAL_VERSION 20
     * }
     */
    public static int _SAL_VERSION() {
        return _SAL_VERSION;
    }

    private static final int __SAL_H_VERSION = (int) 180000000L;

    /**
     * {@snippet lang = c : * #define __SAL_H_VERSION 180000000
     * }
     */
    public static int __SAL_H_VERSION() {
        return __SAL_H_VERSION;
    }

    private static final int _USE_DECLSPECS_FOR_SAL = (int) 0L;

    /**
     * {@snippet lang = c : * #define _USE_DECLSPECS_FOR_SAL 0
     * }
     */
    public static int _USE_DECLSPECS_FOR_SAL() {
        return _USE_DECLSPECS_FOR_SAL;
    }

    private static final int _USE_ATTRIBUTES_FOR_SAL = (int) 0L;

    /**
     * {@snippet lang = c : * #define _USE_ATTRIBUTES_FOR_SAL 0
     * }
     */
    public static int _USE_ATTRIBUTES_FOR_SAL() {
        return _USE_ATTRIBUTES_FOR_SAL;
    }

    private static final int _CRT_PACKING = (int) 8L;

    /**
     * {@snippet lang = c : * #define _CRT_PACKING 8
     * }
     */
    public static int _CRT_PACKING() {
        return _CRT_PACKING;
    }

    private static final int _HAS_EXCEPTIONS = (int) 1L;

    /**
     * {@snippet lang = c : * #define _HAS_EXCEPTIONS 1
     * }
     */
    public static int _HAS_EXCEPTIONS() {
        return _HAS_EXCEPTIONS;
    }

    private static final int _HAS_CXX17 = (int) 0L;

    /**
     * {@snippet lang = c : * #define _HAS_CXX17 0
     * }
     */
    public static int _HAS_CXX17() {
        return _HAS_CXX17;
    }

    private static final int _HAS_CXX20 = (int) 0L;

    /**
     * {@snippet lang = c : * #define _HAS_CXX20 0
     * }
     */
    public static int _HAS_CXX20() {
        return _HAS_CXX20;
    }

    private static final int _HAS_CXX23 = (int) 0L;

    /**
     * {@snippet lang = c : * #define _HAS_CXX23 0
     * }
     */
    public static int _HAS_CXX23() {
        return _HAS_CXX23;
    }

    private static final int _HAS_CXX26 = (int) 0L;

    /**
     * {@snippet lang = c : * #define _HAS_CXX26 0
     * }
     */
    public static int _HAS_CXX26() {
        return _HAS_CXX26;
    }

    private static final int _HAS_NODISCARD = (int) 0L;

    /**
     * {@snippet lang = c : * #define _HAS_NODISCARD 0
     * }
     */
    public static int _HAS_NODISCARD() {
        return _HAS_NODISCARD;
    }

    private static final int _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE = (int) 1L;

    /**
     * {@snippet lang = c : * #define _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE 1
     * }
     */
    public static int _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE() {
        return _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE;
    }

    private static final int _CRT_BUILD_DESKTOP_APP = (int) 1L;

    /**
     * {@snippet lang = c : * #define _CRT_BUILD_DESKTOP_APP 1
     * }
     */
    public static int _CRT_BUILD_DESKTOP_APP() {
        return _CRT_BUILD_DESKTOP_APP;
    }

    private static final int _ARGMAX = (int) 100L;

    /**
     * {@snippet lang = c : * #define _ARGMAX 100
     * }
     */
    public static int _ARGMAX() {
        return _ARGMAX;
    }

    private static final int _CRT_INT_MAX = (int) 2147483647L;

    /**
     * {@snippet lang = c : * #define _CRT_INT_MAX 2147483647
     * }
     */
    public static int _CRT_INT_MAX() {
        return _CRT_INT_MAX;
    }

    private static final int _CRT_FUNCTIONS_REQUIRED = (int) 1L;

    /**
     * {@snippet lang = c : * #define _CRT_FUNCTIONS_REQUIRED 1
     * }
     */
    public static int _CRT_FUNCTIONS_REQUIRED() {
        return _CRT_FUNCTIONS_REQUIRED;
    }

    private static final int _CRT_HAS_CXX17 = (int) 0L;

    /**
     * {@snippet lang = c : * #define _CRT_HAS_CXX17 0
     * }
     */
    public static int _CRT_HAS_CXX17() {
        return _CRT_HAS_CXX17;
    }

    private static final int _CRT_HAS_C11 = (int) 1L;

    /**
     * {@snippet lang = c : * #define _CRT_HAS_C11 1
     * }
     */
    public static int _CRT_HAS_C11() {
        return _CRT_HAS_C11;
    }

    private static final int _CRT_INTERNAL_NONSTDC_NAMES = (int) 1L;

    /**
     * {@snippet lang = c : * #define _CRT_INTERNAL_NONSTDC_NAMES 1
     * }
     */
    public static int _CRT_INTERNAL_NONSTDC_NAMES() {
        return _CRT_INTERNAL_NONSTDC_NAMES;
    }

    private static final int __STDC_WANT_SECURE_LIB__ = (int) 1L;

    /**
     * {@snippet lang = c : * #define __STDC_WANT_SECURE_LIB__ 1
     * }
     */
    public static int __STDC_WANT_SECURE_LIB__() {
        return __STDC_WANT_SECURE_LIB__;
    }

    private static final int _SECURECRT_FILL_BUFFER_PATTERN = (int) 254L;

    /**
     * {@snippet lang = c : * #define _SECURECRT_FILL_BUFFER_PATTERN 254
     * }
     */
    public static int _SECURECRT_FILL_BUFFER_PATTERN() {
        return _SECURECRT_FILL_BUFFER_PATTERN;
    }

    private static final int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES = (int) 0L;

    /**
     * {@snippet lang = c : * #define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES 0
     * }
     */
    public static int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES() {
        return _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES;
    }

    private static final int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT = (int) 0L;

    /**
     * {@snippet lang = c
     * : * #define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT 0
     * }
     */
    public static int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT() {
        return _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT;
    }

    private static final int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES = (int) 1L;

    /**
     * {@snippet lang = c : * #define _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES 1
     * }
     */
    public static int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES() {
        return _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES;
    }

    private static final int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY = (int) 0L;

    /**
     * {@snippet lang = c
     * : * #define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY 0
     * }
     */
    public static int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY() {
        return _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY;
    }

    private static final int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY = (int) 0L;

    /**
     * {@snippet lang = c : * #define _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY 0
     * }
     */
    public static int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY() {
        return _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY;
    }

    private static final int BUFSIZ = (int) 512L;

    /**
     * {@snippet lang = c : * #define BUFSIZ 512
     * }
     */
    public static int BUFSIZ() {
        return BUFSIZ;
    }

    private static final int _NSTREAM_ = (int) 512L;

    /**
     * {@snippet lang = c : * #define _NSTREAM_ 512
     * }
     */
    public static int _NSTREAM_() {
        return _NSTREAM_;
    }

    private static final int _IOB_ENTRIES = (int) 3L;

    /**
     * {@snippet lang = c : * #define _IOB_ENTRIES 3
     * }
     */
    public static int _IOB_ENTRIES() {
        return _IOB_ENTRIES;
    }

    private static final int _IOFBF = (int) 0L;

    /**
     * {@snippet lang = c : * #define _IOFBF 0
     * }
     */
    public static int _IOFBF() {
        return _IOFBF;
    }

    private static final int _IOLBF = (int) 64L;

    /**
     * {@snippet lang = c : * #define _IOLBF 64
     * }
     */
    public static int _IOLBF() {
        return _IOLBF;
    }

    private static final int _IONBF = (int) 4L;

    /**
     * {@snippet lang = c : * #define _IONBF 4
     * }
     */
    public static int _IONBF() {
        return _IONBF;
    }

    private static final int L_tmpnam = (int) 260L;

    /**
     * {@snippet lang = c : * #define L_tmpnam 260
     * }
     */
    public static int L_tmpnam() {
        return L_tmpnam;
    }

    private static final int SEEK_CUR = (int) 1L;

    /**
     * {@snippet lang = c : * #define SEEK_CUR 1
     * }
     */
    public static int SEEK_CUR() {
        return SEEK_CUR;
    }

    private static final int SEEK_END = (int) 2L;

    /**
     * {@snippet lang = c : * #define SEEK_END 2
     * }
     */
    public static int SEEK_END() {
        return SEEK_END;
    }

    private static final int SEEK_SET = (int) 0L;

    /**
     * {@snippet lang = c : * #define SEEK_SET 0
     * }
     */
    public static int SEEK_SET() {
        return SEEK_SET;
    }

    private static final int FILENAME_MAX = (int) 260L;

    /**
     * {@snippet lang = c : * #define FILENAME_MAX 260
     * }
     */
    public static int FILENAME_MAX() {
        return FILENAME_MAX;
    }

    private static final int FOPEN_MAX = (int) 20L;

    /**
     * {@snippet lang = c : * #define FOPEN_MAX 20
     * }
     */
    public static int FOPEN_MAX() {
        return FOPEN_MAX;
    }

    private static final int _SYS_OPEN = (int) 20L;

    /**
     * {@snippet lang = c : * #define _SYS_OPEN 20
     * }
     */
    public static int _SYS_OPEN() {
        return _SYS_OPEN;
    }

    private static final int WCHAR_MIN = (int) 0L;

    /**
     * {@snippet lang = c : * #define WCHAR_MIN 0
     * }
     */
    public static int WCHAR_MIN() {
        return WCHAR_MIN;
    }

    private static final int WCHAR_MAX = (int) 65535L;

    /**
     * {@snippet lang = c : * #define WCHAR_MAX 65535
     * }
     */
    public static int WCHAR_MAX() {
        return WCHAR_MAX;
    }

    private static final int WINT_MIN = (int) 0L;

    /**
     * {@snippet lang = c : * #define WINT_MIN 0
     * }
     */
    public static int WINT_MIN() {
        return WINT_MIN;
    }

    private static final int WINT_MAX = (int) 65535L;

    /**
     * {@snippet lang = c : * #define WINT_MAX 65535
     * }
     */
    public static int WINT_MAX() {
        return WINT_MAX;
    }

    private static final int OPUS_OK = (int) 0L;

    /**
     * {@snippet lang = c : * #define OPUS_OK 0
     * }
     */
    public static int OPUS_OK() {
        return OPUS_OK;
    }

    private static final int OPUS_SET_APPLICATION_REQUEST = (int) 4000L;

    /**
     * {@snippet lang = c : * #define OPUS_SET_APPLICATION_REQUEST 4000
     * }
     */
    public static int OPUS_SET_APPLICATION_REQUEST() {
        return OPUS_SET_APPLICATION_REQUEST;
    }

    private static final int OPUS_GET_APPLICATION_REQUEST = (int) 4001L;

    /**
     * {@snippet lang = c : * #define OPUS_GET_APPLICATION_REQUEST 4001
     * }
     */
    public static int OPUS_GET_APPLICATION_REQUEST() {
        return OPUS_GET_APPLICATION_REQUEST;
    }

    private static final int OPUS_SET_BITRATE_REQUEST = (int) 4002L;

    /**
     * {@snippet lang = c : * #define OPUS_SET_BITRATE_REQUEST 4002
     * }
     */
    public static int OPUS_SET_BITRATE_REQUEST() {
        return OPUS_SET_BITRATE_REQUEST;
    }

    private static final int OPUS_GET_BITRATE_REQUEST = (int) 4003L;

    /**
     * {@snippet lang = c : * #define OPUS_GET_BITRATE_REQUEST 4003
     * }
     */
    public static int OPUS_GET_BITRATE_REQUEST() {
        return OPUS_GET_BITRATE_REQUEST;
    }

    private static final int OPUS_SET_MAX_BANDWIDTH_REQUEST = (int) 4004L;

    /**
     * {@snippet lang = c : * #define OPUS_SET_MAX_BANDWIDTH_REQUEST 4004
     * }
     */
    public static int OPUS_SET_MAX_BANDWIDTH_REQUEST() {
        return OPUS_SET_MAX_BANDWIDTH_REQUEST;
    }

    private static final int OPUS_GET_MAX_BANDWIDTH_REQUEST = (int) 4005L;

    /**
     * {@snippet lang = c : * #define OPUS_GET_MAX_BANDWIDTH_REQUEST 4005
     * }
     */
    public static int OPUS_GET_MAX_BANDWIDTH_REQUEST() {
        return OPUS_GET_MAX_BANDWIDTH_REQUEST;
    }

    private static final int OPUS_SET_VBR_REQUEST = (int) 4006L;

    /**
     * {@snippet lang = c : * #define OPUS_SET_VBR_REQUEST 4006
     * }
     */
    public static int OPUS_SET_VBR_REQUEST() {
        return OPUS_SET_VBR_REQUEST;
    }

    private static final int OPUS_GET_VBR_REQUEST = (int) 4007L;

    /**
     * {@snippet lang = c : * #define OPUS_GET_VBR_REQUEST 4007
     * }
     */
    public static int OPUS_GET_VBR_REQUEST() {
        return OPUS_GET_VBR_REQUEST;
    }

    private static final int OPUS_SET_BANDWIDTH_REQUEST = (int) 4008L;

    /**
     * {@snippet lang = c : * #define OPUS_SET_BANDWIDTH_REQUEST 4008
     * }
     */
    public static int OPUS_SET_BANDWIDTH_REQUEST() {
        return OPUS_SET_BANDWIDTH_REQUEST;
    }

    private static final int OPUS_GET_BANDWIDTH_REQUEST = (int) 4009L;

    /**
     * {@snippet lang = c : * #define OPUS_GET_BANDWIDTH_REQUEST 4009
     * }
     */
    public static int OPUS_GET_BANDWIDTH_REQUEST() {
        return OPUS_GET_BANDWIDTH_REQUEST;
    }

    private static final int OPUS_SET_COMPLEXITY_REQUEST = (int) 4010L;

    /**
     * {@snippet lang = c : * #define OPUS_SET_COMPLEXITY_REQUEST 4010
     * }
     */
    public static int OPUS_SET_COMPLEXITY_REQUEST() {
        return OPUS_SET_COMPLEXITY_REQUEST;
    }

    private static final int OPUS_GET_COMPLEXITY_REQUEST = (int) 4011L;

    /**
     * {@snippet lang = c : * #define OPUS_GET_COMPLEXITY_REQUEST 4011
     * }
     */
    public static int OPUS_GET_COMPLEXITY_REQUEST() {
        return OPUS_GET_COMPLEXITY_REQUEST;
    }

    private static final int OPUS_SET_INBAND_FEC_REQUEST = (int) 4012L;

    /**
     * {@snippet lang = c : * #define OPUS_SET_INBAND_FEC_REQUEST 4012
     * }
     */
    public static int OPUS_SET_INBAND_FEC_REQUEST() {
        return OPUS_SET_INBAND_FEC_REQUEST;
    }

    private static final int OPUS_GET_INBAND_FEC_REQUEST = (int) 4013L;

    /**
     * {@snippet lang = c : * #define OPUS_GET_INBAND_FEC_REQUEST 4013
     * }
     */
    public static int OPUS_GET_INBAND_FEC_REQUEST() {
        return OPUS_GET_INBAND_FEC_REQUEST;
    }

    private static final int OPUS_SET_PACKET_LOSS_PERC_REQUEST = (int) 4014L;

    /**
     * {@snippet lang = c : * #define OPUS_SET_PACKET_LOSS_PERC_REQUEST 4014
     * }
     */
    public static int OPUS_SET_PACKET_LOSS_PERC_REQUEST() {
        return OPUS_SET_PACKET_LOSS_PERC_REQUEST;
    }

    private static final int OPUS_GET_PACKET_LOSS_PERC_REQUEST = (int) 4015L;

    /**
     * {@snippet lang = c : * #define OPUS_GET_PACKET_LOSS_PERC_REQUEST 4015
     * }
     */
    public static int OPUS_GET_PACKET_LOSS_PERC_REQUEST() {
        return OPUS_GET_PACKET_LOSS_PERC_REQUEST;
    }

    private static final int OPUS_SET_DTX_REQUEST = (int) 4016L;

    /**
     * {@snippet lang = c : * #define OPUS_SET_DTX_REQUEST 4016
     * }
     */
    public static int OPUS_SET_DTX_REQUEST() {
        return OPUS_SET_DTX_REQUEST;
    }

    private static final int OPUS_GET_DTX_REQUEST = (int) 4017L;

    /**
     * {@snippet lang = c : * #define OPUS_GET_DTX_REQUEST 4017
     * }
     */
    public static int OPUS_GET_DTX_REQUEST() {
        return OPUS_GET_DTX_REQUEST;
    }

    private static final int OPUS_SET_VBR_CONSTRAINT_REQUEST = (int) 4020L;

    /**
     * {@snippet lang = c : * #define OPUS_SET_VBR_CONSTRAINT_REQUEST 4020
     * }
     */
    public static int OPUS_SET_VBR_CONSTRAINT_REQUEST() {
        return OPUS_SET_VBR_CONSTRAINT_REQUEST;
    }

    private static final int OPUS_GET_VBR_CONSTRAINT_REQUEST = (int) 4021L;

    /**
     * {@snippet lang = c : * #define OPUS_GET_VBR_CONSTRAINT_REQUEST 4021
     * }
     */
    public static int OPUS_GET_VBR_CONSTRAINT_REQUEST() {
        return OPUS_GET_VBR_CONSTRAINT_REQUEST;
    }

    private static final int OPUS_SET_FORCE_CHANNELS_REQUEST = (int) 4022L;

    /**
     * {@snippet lang = c : * #define OPUS_SET_FORCE_CHANNELS_REQUEST 4022
     * }
     */
    public static int OPUS_SET_FORCE_CHANNELS_REQUEST() {
        return OPUS_SET_FORCE_CHANNELS_REQUEST;
    }

    private static final int OPUS_GET_FORCE_CHANNELS_REQUEST = (int) 4023L;

    /**
     * {@snippet lang = c : * #define OPUS_GET_FORCE_CHANNELS_REQUEST 4023
     * }
     */
    public static int OPUS_GET_FORCE_CHANNELS_REQUEST() {
        return OPUS_GET_FORCE_CHANNELS_REQUEST;
    }

    private static final int OPUS_SET_SIGNAL_REQUEST = (int) 4024L;

    /**
     * {@snippet lang = c : * #define OPUS_SET_SIGNAL_REQUEST 4024
     * }
     */
    public static int OPUS_SET_SIGNAL_REQUEST() {
        return OPUS_SET_SIGNAL_REQUEST;
    }

    private static final int OPUS_GET_SIGNAL_REQUEST = (int) 4025L;

    /**
     * {@snippet lang = c : * #define OPUS_GET_SIGNAL_REQUEST 4025
     * }
     */
    public static int OPUS_GET_SIGNAL_REQUEST() {
        return OPUS_GET_SIGNAL_REQUEST;
    }

    private static final int OPUS_GET_LOOKAHEAD_REQUEST = (int) 4027L;

    /**
     * {@snippet lang = c : * #define OPUS_GET_LOOKAHEAD_REQUEST 4027
     * }
     */
    public static int OPUS_GET_LOOKAHEAD_REQUEST() {
        return OPUS_GET_LOOKAHEAD_REQUEST;
    }

    private static final int OPUS_GET_SAMPLE_RATE_REQUEST = (int) 4029L;

    /**
     * {@snippet lang = c : * #define OPUS_GET_SAMPLE_RATE_REQUEST 4029
     * }
     */
    public static int OPUS_GET_SAMPLE_RATE_REQUEST() {
        return OPUS_GET_SAMPLE_RATE_REQUEST;
    }

    private static final int OPUS_GET_FINAL_RANGE_REQUEST = (int) 4031L;

    /**
     * {@snippet lang = c : * #define OPUS_GET_FINAL_RANGE_REQUEST 4031
     * }
     */
    public static int OPUS_GET_FINAL_RANGE_REQUEST() {
        return OPUS_GET_FINAL_RANGE_REQUEST;
    }

    private static final int OPUS_GET_PITCH_REQUEST = (int) 4033L;

    /**
     * {@snippet lang = c : * #define OPUS_GET_PITCH_REQUEST 4033
     * }
     */
    public static int OPUS_GET_PITCH_REQUEST() {
        return OPUS_GET_PITCH_REQUEST;
    }

    private static final int OPUS_SET_GAIN_REQUEST = (int) 4034L;

    /**
     * {@snippet lang = c : * #define OPUS_SET_GAIN_REQUEST 4034
     * }
     */
    public static int OPUS_SET_GAIN_REQUEST() {
        return OPUS_SET_GAIN_REQUEST;
    }

    private static final int OPUS_GET_GAIN_REQUEST = (int) 4045L;

    /**
     * {@snippet lang = c : * #define OPUS_GET_GAIN_REQUEST 4045
     * }
     */
    public static int OPUS_GET_GAIN_REQUEST() {
        return OPUS_GET_GAIN_REQUEST;
    }

    private static final int OPUS_SET_LSB_DEPTH_REQUEST = (int) 4036L;

    /**
     * {@snippet lang = c : * #define OPUS_SET_LSB_DEPTH_REQUEST 4036
     * }
     */
    public static int OPUS_SET_LSB_DEPTH_REQUEST() {
        return OPUS_SET_LSB_DEPTH_REQUEST;
    }

    private static final int OPUS_GET_LSB_DEPTH_REQUEST = (int) 4037L;

    /**
     * {@snippet lang = c : * #define OPUS_GET_LSB_DEPTH_REQUEST 4037
     * }
     */
    public static int OPUS_GET_LSB_DEPTH_REQUEST() {
        return OPUS_GET_LSB_DEPTH_REQUEST;
    }

    private static final int OPUS_GET_LAST_PACKET_DURATION_REQUEST = (int) 4039L;

    /**
     * {@snippet lang = c : * #define OPUS_GET_LAST_PACKET_DURATION_REQUEST 4039
     * }
     */
    public static int OPUS_GET_LAST_PACKET_DURATION_REQUEST() {
        return OPUS_GET_LAST_PACKET_DURATION_REQUEST;
    }

    private static final int OPUS_SET_EXPERT_FRAME_DURATION_REQUEST = (int) 4040L;

    /**
     * {@snippet lang = c : * #define OPUS_SET_EXPERT_FRAME_DURATION_REQUEST 4040
     * }
     */
    public static int OPUS_SET_EXPERT_FRAME_DURATION_REQUEST() {
        return OPUS_SET_EXPERT_FRAME_DURATION_REQUEST;
    }

    private static final int OPUS_GET_EXPERT_FRAME_DURATION_REQUEST = (int) 4041L;

    /**
     * {@snippet lang = c : * #define OPUS_GET_EXPERT_FRAME_DURATION_REQUEST 4041
     * }
     */
    public static int OPUS_GET_EXPERT_FRAME_DURATION_REQUEST() {
        return OPUS_GET_EXPERT_FRAME_DURATION_REQUEST;
    }

    private static final int OPUS_SET_PREDICTION_DISABLED_REQUEST = (int) 4042L;

    /**
     * {@snippet lang = c : * #define OPUS_SET_PREDICTION_DISABLED_REQUEST 4042
     * }
     */
    public static int OPUS_SET_PREDICTION_DISABLED_REQUEST() {
        return OPUS_SET_PREDICTION_DISABLED_REQUEST;
    }

    private static final int OPUS_GET_PREDICTION_DISABLED_REQUEST = (int) 4043L;

    /**
     * {@snippet lang = c : * #define OPUS_GET_PREDICTION_DISABLED_REQUEST 4043
     * }
     */
    public static int OPUS_GET_PREDICTION_DISABLED_REQUEST() {
        return OPUS_GET_PREDICTION_DISABLED_REQUEST;
    }

    private static final int OPUS_SET_PHASE_INVERSION_DISABLED_REQUEST = (int) 4046L;

    /**
     * {@snippet lang = c : * #define OPUS_SET_PHASE_INVERSION_DISABLED_REQUEST 4046
     * }
     */
    public static int OPUS_SET_PHASE_INVERSION_DISABLED_REQUEST() {
        return OPUS_SET_PHASE_INVERSION_DISABLED_REQUEST;
    }

    private static final int OPUS_GET_PHASE_INVERSION_DISABLED_REQUEST = (int) 4047L;

    /**
     * {@snippet lang = c : * #define OPUS_GET_PHASE_INVERSION_DISABLED_REQUEST 4047
     * }
     */
    public static int OPUS_GET_PHASE_INVERSION_DISABLED_REQUEST() {
        return OPUS_GET_PHASE_INVERSION_DISABLED_REQUEST;
    }

    private static final int OPUS_GET_IN_DTX_REQUEST = (int) 4049L;

    /**
     * {@snippet lang = c : * #define OPUS_GET_IN_DTX_REQUEST 4049
     * }
     */
    public static int OPUS_GET_IN_DTX_REQUEST() {
        return OPUS_GET_IN_DTX_REQUEST;
    }

    private static final int OPUS_SET_DRED_DURATION_REQUEST = (int) 4050L;

    /**
     * {@snippet lang = c : * #define OPUS_SET_DRED_DURATION_REQUEST 4050
     * }
     */
    public static int OPUS_SET_DRED_DURATION_REQUEST() {
        return OPUS_SET_DRED_DURATION_REQUEST;
    }

    private static final int OPUS_GET_DRED_DURATION_REQUEST = (int) 4051L;

    /**
     * {@snippet lang = c : * #define OPUS_GET_DRED_DURATION_REQUEST 4051
     * }
     */
    public static int OPUS_GET_DRED_DURATION_REQUEST() {
        return OPUS_GET_DRED_DURATION_REQUEST;
    }

    private static final int OPUS_SET_DNN_BLOB_REQUEST = (int) 4052L;

    /**
     * {@snippet lang = c : * #define OPUS_SET_DNN_BLOB_REQUEST 4052
     * }
     */
    public static int OPUS_SET_DNN_BLOB_REQUEST() {
        return OPUS_SET_DNN_BLOB_REQUEST;
    }

    private static final int OPUS_SET_OSCE_BWE_REQUEST = (int) 4054L;

    /**
     * {@snippet lang = c : * #define OPUS_SET_OSCE_BWE_REQUEST 4054
     * }
     */
    public static int OPUS_SET_OSCE_BWE_REQUEST() {
        return OPUS_SET_OSCE_BWE_REQUEST;
    }

    private static final int OPUS_GET_OSCE_BWE_REQUEST = (int) 4055L;

    /**
     * {@snippet lang = c : * #define OPUS_GET_OSCE_BWE_REQUEST 4055
     * }
     */
    public static int OPUS_GET_OSCE_BWE_REQUEST() {
        return OPUS_GET_OSCE_BWE_REQUEST;
    }

    private static final int OPUS_SET_QEXT_REQUEST = (int) 4056L;

    /**
     * {@snippet lang = c : * #define OPUS_SET_QEXT_REQUEST 4056
     * }
     */
    public static int OPUS_SET_QEXT_REQUEST() {
        return OPUS_SET_QEXT_REQUEST;
    }

    private static final int OPUS_GET_QEXT_REQUEST = (int) 4057L;

    /**
     * {@snippet lang = c : * #define OPUS_GET_QEXT_REQUEST 4057
     * }
     */
    public static int OPUS_GET_QEXT_REQUEST() {
        return OPUS_GET_QEXT_REQUEST;
    }

    private static final int OPUS_SET_IGNORE_EXTENSIONS_REQUEST = (int) 4058L;

    /**
     * {@snippet lang = c : * #define OPUS_SET_IGNORE_EXTENSIONS_REQUEST 4058
     * }
     */
    public static int OPUS_SET_IGNORE_EXTENSIONS_REQUEST() {
        return OPUS_SET_IGNORE_EXTENSIONS_REQUEST;
    }

    private static final int OPUS_GET_IGNORE_EXTENSIONS_REQUEST = (int) 4059L;

    /**
     * {@snippet lang = c : * #define OPUS_GET_IGNORE_EXTENSIONS_REQUEST 4059
     * }
     */
    public static int OPUS_GET_IGNORE_EXTENSIONS_REQUEST() {
        return OPUS_GET_IGNORE_EXTENSIONS_REQUEST;
    }

    private static final int OPUS_APPLICATION_VOIP = (int) 2048L;

    /**
     * {@snippet lang = c : * #define OPUS_APPLICATION_VOIP 2048
     * }
     */
    public static int OPUS_APPLICATION_VOIP() {
        return OPUS_APPLICATION_VOIP;
    }

    private static final int OPUS_APPLICATION_AUDIO = (int) 2049L;

    /**
     * {@snippet lang = c : * #define OPUS_APPLICATION_AUDIO 2049
     * }
     */
    public static int OPUS_APPLICATION_AUDIO() {
        return OPUS_APPLICATION_AUDIO;
    }

    private static final int OPUS_APPLICATION_RESTRICTED_LOWDELAY = (int) 2051L;

    /**
     * {@snippet lang = c : * #define OPUS_APPLICATION_RESTRICTED_LOWDELAY 2051
     * }
     */
    public static int OPUS_APPLICATION_RESTRICTED_LOWDELAY() {
        return OPUS_APPLICATION_RESTRICTED_LOWDELAY;
    }

    private static final int OPUS_APPLICATION_RESTRICTED_SILK = (int) 2052L;

    /**
     * {@snippet lang = c : * #define OPUS_APPLICATION_RESTRICTED_SILK 2052
     * }
     */
    public static int OPUS_APPLICATION_RESTRICTED_SILK() {
        return OPUS_APPLICATION_RESTRICTED_SILK;
    }

    private static final int OPUS_APPLICATION_RESTRICTED_CELT = (int) 2053L;

    /**
     * {@snippet lang = c : * #define OPUS_APPLICATION_RESTRICTED_CELT 2053
     * }
     */
    public static int OPUS_APPLICATION_RESTRICTED_CELT() {
        return OPUS_APPLICATION_RESTRICTED_CELT;
    }

    private static final int OPUS_SIGNAL_VOICE = (int) 3001L;

    /**
     * {@snippet lang = c : * #define OPUS_SIGNAL_VOICE 3001
     * }
     */
    public static int OPUS_SIGNAL_VOICE() {
        return OPUS_SIGNAL_VOICE;
    }

    private static final int OPUS_SIGNAL_MUSIC = (int) 3002L;

    /**
     * {@snippet lang = c : * #define OPUS_SIGNAL_MUSIC 3002
     * }
     */
    public static int OPUS_SIGNAL_MUSIC() {
        return OPUS_SIGNAL_MUSIC;
    }

    private static final int OPUS_BANDWIDTH_NARROWBAND = (int) 1101L;

    /**
     * {@snippet lang = c : * #define OPUS_BANDWIDTH_NARROWBAND 1101
     * }
     */
    public static int OPUS_BANDWIDTH_NARROWBAND() {
        return OPUS_BANDWIDTH_NARROWBAND;
    }

    private static final int OPUS_BANDWIDTH_MEDIUMBAND = (int) 1102L;

    /**
     * {@snippet lang = c : * #define OPUS_BANDWIDTH_MEDIUMBAND 1102
     * }
     */
    public static int OPUS_BANDWIDTH_MEDIUMBAND() {
        return OPUS_BANDWIDTH_MEDIUMBAND;
    }

    private static final int OPUS_BANDWIDTH_WIDEBAND = (int) 1103L;

    /**
     * {@snippet lang = c : * #define OPUS_BANDWIDTH_WIDEBAND 1103
     * }
     */
    public static int OPUS_BANDWIDTH_WIDEBAND() {
        return OPUS_BANDWIDTH_WIDEBAND;
    }

    private static final int OPUS_BANDWIDTH_SUPERWIDEBAND = (int) 1104L;

    /**
     * {@snippet lang = c : * #define OPUS_BANDWIDTH_SUPERWIDEBAND 1104
     * }
     */
    public static int OPUS_BANDWIDTH_SUPERWIDEBAND() {
        return OPUS_BANDWIDTH_SUPERWIDEBAND;
    }

    private static final int OPUS_BANDWIDTH_FULLBAND = (int) 1105L;

    /**
     * {@snippet lang = c : * #define OPUS_BANDWIDTH_FULLBAND 1105
     * }
     */
    public static int OPUS_BANDWIDTH_FULLBAND() {
        return OPUS_BANDWIDTH_FULLBAND;
    }

    private static final int OPUS_FRAMESIZE_ARG = (int) 5000L;

    /**
     * {@snippet lang = c : * #define OPUS_FRAMESIZE_ARG 5000
     * }
     */
    public static int OPUS_FRAMESIZE_ARG() {
        return OPUS_FRAMESIZE_ARG;
    }

    private static final int OPUS_FRAMESIZE_2_5_MS = (int) 5001L;

    /**
     * {@snippet lang = c : * #define OPUS_FRAMESIZE_2_5_MS 5001
     * }
     */
    public static int OPUS_FRAMESIZE_2_5_MS() {
        return OPUS_FRAMESIZE_2_5_MS;
    }

    private static final int OPUS_FRAMESIZE_5_MS = (int) 5002L;

    /**
     * {@snippet lang = c : * #define OPUS_FRAMESIZE_5_MS 5002
     * }
     */
    public static int OPUS_FRAMESIZE_5_MS() {
        return OPUS_FRAMESIZE_5_MS;
    }

    private static final int OPUS_FRAMESIZE_10_MS = (int) 5003L;

    /**
     * {@snippet lang = c : * #define OPUS_FRAMESIZE_10_MS 5003
     * }
     */
    public static int OPUS_FRAMESIZE_10_MS() {
        return OPUS_FRAMESIZE_10_MS;
    }

    private static final int OPUS_FRAMESIZE_20_MS = (int) 5004L;

    /**
     * {@snippet lang = c : * #define OPUS_FRAMESIZE_20_MS 5004
     * }
     */
    public static int OPUS_FRAMESIZE_20_MS() {
        return OPUS_FRAMESIZE_20_MS;
    }

    private static final int OPUS_FRAMESIZE_40_MS = (int) 5005L;

    /**
     * {@snippet lang = c : * #define OPUS_FRAMESIZE_40_MS 5005
     * }
     */
    public static int OPUS_FRAMESIZE_40_MS() {
        return OPUS_FRAMESIZE_40_MS;
    }

    private static final int OPUS_FRAMESIZE_60_MS = (int) 5006L;

    /**
     * {@snippet lang = c : * #define OPUS_FRAMESIZE_60_MS 5006
     * }
     */
    public static int OPUS_FRAMESIZE_60_MS() {
        return OPUS_FRAMESIZE_60_MS;
    }

    private static final int OPUS_FRAMESIZE_80_MS = (int) 5007L;

    /**
     * {@snippet lang = c : * #define OPUS_FRAMESIZE_80_MS 5007
     * }
     */
    public static int OPUS_FRAMESIZE_80_MS() {
        return OPUS_FRAMESIZE_80_MS;
    }

    private static final int OPUS_FRAMESIZE_100_MS = (int) 5008L;

    /**
     * {@snippet lang = c : * #define OPUS_FRAMESIZE_100_MS 5008
     * }
     */
    public static int OPUS_FRAMESIZE_100_MS() {
        return OPUS_FRAMESIZE_100_MS;
    }

    private static final int OPUS_FRAMESIZE_120_MS = (int) 5009L;

    /**
     * {@snippet lang = c : * #define OPUS_FRAMESIZE_120_MS 5009
     * }
     */
    public static int OPUS_FRAMESIZE_120_MS() {
        return OPUS_FRAMESIZE_120_MS;
    }

    private static final int OPUS_RESET_STATE = (int) 4028L;

    /**
     * {@snippet lang = c : * #define OPUS_RESET_STATE 4028
     * }
     */
    public static int OPUS_RESET_STATE() {
        return OPUS_RESET_STATE;
    }

    private static final int OPUS_MULTISTREAM_GET_ENCODER_STATE_REQUEST = (int) 5120L;

    /**
     * {@snippet lang = c
     * : * #define OPUS_MULTISTREAM_GET_ENCODER_STATE_REQUEST 5120
     * }
     */
    public static int OPUS_MULTISTREAM_GET_ENCODER_STATE_REQUEST() {
        return OPUS_MULTISTREAM_GET_ENCODER_STATE_REQUEST;
    }

    private static final int OPUS_MULTISTREAM_GET_DECODER_STATE_REQUEST = (int) 5122L;

    /**
     * {@snippet lang = c
     * : * #define OPUS_MULTISTREAM_GET_DECODER_STATE_REQUEST 5122
     * }
     */
    public static int OPUS_MULTISTREAM_GET_DECODER_STATE_REQUEST() {
        return OPUS_MULTISTREAM_GET_DECODER_STATE_REQUEST;
    }

    /**
     * {@snippet lang = c : * typedef __builtin_va_list va_list
     * }
     */
    public static final AddressLayout va_list = opusfile_h.C_POINTER;
    /**
     * {@snippet lang = c : * typedef __builtin_va_list __gnuc_va_list
     * }
     */
    public static final AddressLayout __gnuc_va_list = opusfile_h.C_POINTER;
    /**
     * {@snippet lang = c : * typedef unsigned long long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = opusfile_h.C_LONG_LONG;

    /**
     * Variadic invoker class for:
     * {@snippet lang = c : * void __va_start(va_list *, ...)
     * }
     */
    public static class __va_start {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER);
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__va_start");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private __va_start(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang = c : * void __va_start(va_list *, ...)
         * }
         */
        public static __va_start makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new __va_start(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("__va_start", x0, x1);
                }
                spreader.invokeExact(x0, x1);
            } catch (IllegalArgumentException | ClassCastException ex$) {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * {@snippet lang = c : * typedef unsigned long long size_t
     * }
     */
    public static final OfLong size_t = opusfile_h.C_LONG_LONG;
    /**
     * {@snippet lang = c : * typedef long long ptrdiff_t
     * }
     */
    public static final OfLong ptrdiff_t = opusfile_h.C_LONG_LONG;
    /**
     * {@snippet lang = c : * typedef long long intptr_t
     * }
     */
    public static final OfLong intptr_t = opusfile_h.C_LONG_LONG;
    /**
     * {@snippet lang = c : * typedef _Bool __vcrt_bool
     * }
     */
    public static final OfBoolean __vcrt_bool = opusfile_h.C_BOOL;
    /**
     * {@snippet lang = c : * typedef unsigned short wchar_t
     * }
     */
    public static final OfShort wchar_t = opusfile_h.C_SHORT;

    private static class __security_init_cookie {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid();

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__security_init_cookie");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * void __security_init_cookie()
     * }
     */
    public static FunctionDescriptor __security_init_cookie$descriptor() {
        return __security_init_cookie.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * void __security_init_cookie()
     * }
     */
    public static MethodHandle __security_init_cookie$handle() {
        return __security_init_cookie.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * void __security_init_cookie()
     * }
     */
    public static MemorySegment __security_init_cookie$address() {
        return __security_init_cookie.ADDR;
    }

    /**
     * {@snippet lang = c : * void __security_init_cookie()
     * }
     */
    public static void __security_init_cookie() {
        var mh$ = __security_init_cookie.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__security_init_cookie");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __security_check_cookie {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_LONG_LONG);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__security_check_cookie");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * void __security_check_cookie(uintptr_t _StackCookie)
     * }
     */
    public static FunctionDescriptor __security_check_cookie$descriptor() {
        return __security_check_cookie.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * void __security_check_cookie(uintptr_t _StackCookie)
     * }
     */
    public static MethodHandle __security_check_cookie$handle() {
        return __security_check_cookie.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * void __security_check_cookie(uintptr_t _StackCookie)
     * }
     */
    public static MemorySegment __security_check_cookie$address() {
        return __security_check_cookie.ADDR;
    }

    /**
     * {@snippet lang = c : * void __security_check_cookie(uintptr_t _StackCookie)
     * }
     */
    public static void __security_check_cookie(long _StackCookie) {
        var mh$ = __security_check_cookie.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__security_check_cookie", _StackCookie);
            }
            mh$.invokeExact(_StackCookie);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __report_gsfailure {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_LONG_LONG);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__report_gsfailure");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * void __report_gsfailure(uintptr_t _StackCookie)
     * }
     */
    public static FunctionDescriptor __report_gsfailure$descriptor() {
        return __report_gsfailure.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * void __report_gsfailure(uintptr_t _StackCookie)
     * }
     */
    public static MethodHandle __report_gsfailure$handle() {
        return __report_gsfailure.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * void __report_gsfailure(uintptr_t _StackCookie)
     * }
     */
    public static MemorySegment __report_gsfailure$address() {
        return __report_gsfailure.ADDR;
    }

    /**
     * {@snippet lang = c : * void __report_gsfailure(uintptr_t _StackCookie)
     * }
     */
    public static void __report_gsfailure(long _StackCookie) {
        var mh$ = __report_gsfailure.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__report_gsfailure", _StackCookie);
            }
            mh$.invokeExact(_StackCookie);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __security_cookie$constants {
        public static final OfLong LAYOUT = opusfile_h.C_LONG_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("__security_cookie")
                .reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang = c : * extern uintptr_t __security_cookie
     * }
     */
    public static OfLong __security_cookie$layout() {
        return __security_cookie$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang = c : * extern uintptr_t __security_cookie
     * }
     */
    public static MemorySegment __security_cookie$segment() {
        return __security_cookie$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang = c : * extern uintptr_t __security_cookie
     * }
     */
    public static long __security_cookie() {
        return __security_cookie$constants.SEGMENT.get(__security_cookie$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang = c : * extern uintptr_t __security_cookie
     * }
     */
    public static void __security_cookie(long varValue) {
        __security_cookie$constants.SEGMENT.set(__security_cookie$constants.LAYOUT, 0L, varValue);
    }

    /**
     * {@snippet lang = c : * typedef _Bool __crt_bool
     * }
     */
    public static final OfBoolean __crt_bool = opusfile_h.C_BOOL;

    private static class _invalid_parameter_noinfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid();

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_invalid_parameter_noinfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * void _invalid_parameter_noinfo()
     * }
     */
    public static FunctionDescriptor _invalid_parameter_noinfo$descriptor() {
        return _invalid_parameter_noinfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * void _invalid_parameter_noinfo()
     * }
     */
    public static MethodHandle _invalid_parameter_noinfo$handle() {
        return _invalid_parameter_noinfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * void _invalid_parameter_noinfo()
     * }
     */
    public static MemorySegment _invalid_parameter_noinfo$address() {
        return _invalid_parameter_noinfo.ADDR;
    }

    /**
     * {@snippet lang = c : * void _invalid_parameter_noinfo()
     * }
     */
    public static void _invalid_parameter_noinfo() {
        var mh$ = _invalid_parameter_noinfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_invalid_parameter_noinfo");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _invalid_parameter_noinfo_noreturn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid();

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_invalid_parameter_noinfo_noreturn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * void _invalid_parameter_noinfo_noreturn()
     * }
     */
    public static FunctionDescriptor _invalid_parameter_noinfo_noreturn$descriptor() {
        return _invalid_parameter_noinfo_noreturn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * void _invalid_parameter_noinfo_noreturn()
     * }
     */
    public static MethodHandle _invalid_parameter_noinfo_noreturn$handle() {
        return _invalid_parameter_noinfo_noreturn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * void _invalid_parameter_noinfo_noreturn()
     * }
     */
    public static MemorySegment _invalid_parameter_noinfo_noreturn$address() {
        return _invalid_parameter_noinfo_noreturn.ADDR;
    }

    /**
     * {@snippet lang = c : * void _invalid_parameter_noinfo_noreturn()
     * }
     */
    public static void _invalid_parameter_noinfo_noreturn() {
        var mh$ = _invalid_parameter_noinfo_noreturn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_invalid_parameter_noinfo_noreturn");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _invoke_watson {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_LONG_LONG);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_invoke_watson");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * void _invoke_watson(const wchar_t *_Expression, const wchar_t *_FunctionName, const wchar_t *_FileName, unsigned int _LineNo, uintptr_t _Reserved)
     * }
     */
    public static FunctionDescriptor _invoke_watson$descriptor() {
        return _invoke_watson.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * void _invoke_watson(const wchar_t *_Expression, const wchar_t *_FunctionName, const wchar_t *_FileName, unsigned int _LineNo, uintptr_t _Reserved)
     * }
     */
    public static MethodHandle _invoke_watson$handle() {
        return _invoke_watson.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * void _invoke_watson(const wchar_t *_Expression, const wchar_t *_FunctionName, const wchar_t *_FileName, unsigned int _LineNo, uintptr_t _Reserved)
     * }
     */
    public static MemorySegment _invoke_watson$address() {
        return _invoke_watson.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * void _invoke_watson(const wchar_t *_Expression, const wchar_t *_FunctionName, const wchar_t *_FileName, unsigned int _LineNo, uintptr_t _Reserved)
     * }
     */
    public static void _invoke_watson(MemorySegment _Expression, MemorySegment _FunctionName, MemorySegment _FileName,
            int _LineNo, long _Reserved) {
        var mh$ = _invoke_watson.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_invoke_watson", _Expression, _FunctionName, _FileName, _LineNo, _Reserved);
            }
            mh$.invokeExact(_Expression, _FunctionName, _FileName, _LineNo, _Reserved);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * {@snippet lang = c : * typedef int errno_t
     * }
     */
    public static final OfInt errno_t = opusfile_h.C_INT;
    /**
     * {@snippet lang = c : * typedef unsigned short wint_t
     * }
     */
    public static final OfShort wint_t = opusfile_h.C_SHORT;
    /**
     * {@snippet lang = c : * typedef unsigned short wctype_t
     * }
     */
    public static final OfShort wctype_t = opusfile_h.C_SHORT;
    /**
     * {@snippet lang = c : * typedef long __time32_t
     * }
     */
    public static final OfInt __time32_t = opusfile_h.C_LONG;
    /**
     * {@snippet lang = c : * typedef long long __time64_t
     * }
     */
    public static final OfLong __time64_t = opusfile_h.C_LONG_LONG;
    /**
     * {@snippet lang = c : * typedef __crt_locale_pointers *_locale_t
     * }
     */
    public static final AddressLayout _locale_t = opusfile_h.C_POINTER;
    /**
     * {@snippet lang = c : * typedef __time64_t time_t
     * }
     */
    public static final OfLong time_t = opusfile_h.C_LONG_LONG;
    /**
     * {@snippet lang = c : * typedef size_t rsize_t
     * }
     */
    public static final OfLong rsize_t = opusfile_h.C_LONG_LONG;

    private static class __acrt_iob_func {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__acrt_iob_func");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * FILE *__acrt_iob_func(unsigned int _Ix)
     * }
     */
    public static FunctionDescriptor __acrt_iob_func$descriptor() {
        return __acrt_iob_func.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * FILE *__acrt_iob_func(unsigned int _Ix)
     * }
     */
    public static MethodHandle __acrt_iob_func$handle() {
        return __acrt_iob_func.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * FILE *__acrt_iob_func(unsigned int _Ix)
     * }
     */
    public static MemorySegment __acrt_iob_func$address() {
        return __acrt_iob_func.ADDR;
    }

    /**
     * {@snippet lang = c : * FILE *__acrt_iob_func(unsigned int _Ix)
     * }
     */
    public static MemorySegment __acrt_iob_func(int _Ix) {
        var mh$ = __acrt_iob_func.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__acrt_iob_func", _Ix);
            }
            return (MemorySegment) mh$.invokeExact(_Ix);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetwc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_SHORT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fgetwc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * wint_t fgetwc(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fgetwc$descriptor() {
        return fgetwc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * wint_t fgetwc(FILE *_Stream)
     * }
     */
    public static MethodHandle fgetwc$handle() {
        return fgetwc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * wint_t fgetwc(FILE *_Stream)
     * }
     */
    public static MemorySegment fgetwc$address() {
        return fgetwc.ADDR;
    }

    /**
     * {@snippet lang = c : * wint_t fgetwc(FILE *_Stream)
     * }
     */
    public static short fgetwc(MemorySegment _Stream) {
        var mh$ = fgetwc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetwc", _Stream);
            }
            return (short) mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fgetwchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_SHORT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fgetwchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * wint_t _fgetwchar()
     * }
     */
    public static FunctionDescriptor _fgetwchar$descriptor() {
        return _fgetwchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * wint_t _fgetwchar()
     * }
     */
    public static MethodHandle _fgetwchar$handle() {
        return _fgetwchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * wint_t _fgetwchar()
     * }
     */
    public static MemorySegment _fgetwchar$address() {
        return _fgetwchar.ADDR;
    }

    /**
     * {@snippet lang = c : * wint_t _fgetwchar()
     * }
     */
    public static short _fgetwchar() {
        var mh$ = _fgetwchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fgetwchar");
            }
            return (short) mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputwc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_SHORT,
                opusfile_h.C_SHORT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fputwc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * wint_t fputwc(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fputwc$descriptor() {
        return fputwc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * wint_t fputwc(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle fputwc$handle() {
        return fputwc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * wint_t fputwc(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment fputwc$address() {
        return fputwc.ADDR;
    }

    /**
     * {@snippet lang = c : * wint_t fputwc(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static short fputwc(short _Character, MemorySegment _Stream) {
        var mh$ = fputwc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputwc", _Character, _Stream);
            }
            return (short) mh$.invokeExact(_Character, _Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fputwchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_SHORT,
                opusfile_h.C_SHORT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fputwchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * wint_t _fputwchar(wchar_t _Character)
     * }
     */
    public static FunctionDescriptor _fputwchar$descriptor() {
        return _fputwchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * wint_t _fputwchar(wchar_t _Character)
     * }
     */
    public static MethodHandle _fputwchar$handle() {
        return _fputwchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * wint_t _fputwchar(wchar_t _Character)
     * }
     */
    public static MemorySegment _fputwchar$address() {
        return _fputwchar.ADDR;
    }

    /**
     * {@snippet lang = c : * wint_t _fputwchar(wchar_t _Character)
     * }
     */
    public static short _fputwchar(short _Character) {
        var mh$ = _fputwchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fputwchar", _Character);
            }
            return (short) mh$.invokeExact(_Character);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getwc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_SHORT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getwc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * wint_t getwc(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor getwc$descriptor() {
        return getwc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * wint_t getwc(FILE *_Stream)
     * }
     */
    public static MethodHandle getwc$handle() {
        return getwc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * wint_t getwc(FILE *_Stream)
     * }
     */
    public static MemorySegment getwc$address() {
        return getwc.ADDR;
    }

    /**
     * {@snippet lang = c : * wint_t getwc(FILE *_Stream)
     * }
     */
    public static short getwc(MemorySegment _Stream) {
        var mh$ = getwc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getwc", _Stream);
            }
            return (short) mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getwchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_SHORT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getwchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * wint_t getwchar()
     * }
     */
    public static FunctionDescriptor getwchar$descriptor() {
        return getwchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * wint_t getwchar()
     * }
     */
    public static MethodHandle getwchar$handle() {
        return getwchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * wint_t getwchar()
     * }
     */
    public static MemorySegment getwchar$address() {
        return getwchar.ADDR;
    }

    /**
     * {@snippet lang = c : * wint_t getwchar()
     * }
     */
    public static short getwchar() {
        var mh$ = getwchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getwchar");
            }
            return (short) mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetws {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fgetws");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * wchar_t *fgetws(wchar_t *_Buffer, int _BufferCount, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fgetws$descriptor() {
        return fgetws.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * wchar_t *fgetws(wchar_t *_Buffer, int _BufferCount, FILE *_Stream)
     * }
     */
    public static MethodHandle fgetws$handle() {
        return fgetws.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * wchar_t *fgetws(wchar_t *_Buffer, int _BufferCount, FILE *_Stream)
     * }
     */
    public static MemorySegment fgetws$address() {
        return fgetws.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * wchar_t *fgetws(wchar_t *_Buffer, int _BufferCount, FILE *_Stream)
     * }
     */
    public static MemorySegment fgetws(MemorySegment _Buffer, int _BufferCount, MemorySegment _Stream) {
        var mh$ = fgetws.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetws", _Buffer, _BufferCount, _Stream);
            }
            return (MemorySegment) mh$.invokeExact(_Buffer, _BufferCount, _Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputws {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fputws");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int fputws(const wchar_t *_Buffer, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fputws$descriptor() {
        return fputws.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int fputws(const wchar_t *_Buffer, FILE *_Stream)
     * }
     */
    public static MethodHandle fputws$handle() {
        return fputws.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int fputws(const wchar_t *_Buffer, FILE *_Stream)
     * }
     */
    public static MemorySegment fputws$address() {
        return fputws.ADDR;
    }

    /**
     * {@snippet lang = c : * int fputws(const wchar_t *_Buffer, FILE *_Stream)
     * }
     */
    public static int fputws(MemorySegment _Buffer, MemorySegment _Stream) {
        var mh$ = fputws.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputws", _Buffer, _Stream);
            }
            return (int) mh$.invokeExact(_Buffer, _Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _getws_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_LONG_LONG);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_getws_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * wchar_t *_getws_s(wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static FunctionDescriptor _getws_s$descriptor() {
        return _getws_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * wchar_t *_getws_s(wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static MethodHandle _getws_s$handle() {
        return _getws_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * wchar_t *_getws_s(wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static MemorySegment _getws_s$address() {
        return _getws_s.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * wchar_t *_getws_s(wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static MemorySegment _getws_s(MemorySegment _Buffer, long _BufferCount) {
        var mh$ = _getws_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_getws_s", _Buffer, _BufferCount);
            }
            return (MemorySegment) mh$.invokeExact(_Buffer, _BufferCount);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putwc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_SHORT,
                opusfile_h.C_SHORT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("putwc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * wint_t putwc(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor putwc$descriptor() {
        return putwc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * wint_t putwc(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle putwc$handle() {
        return putwc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * wint_t putwc(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment putwc$address() {
        return putwc.ADDR;
    }

    /**
     * {@snippet lang = c : * wint_t putwc(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static short putwc(short _Character, MemorySegment _Stream) {
        var mh$ = putwc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putwc", _Character, _Stream);
            }
            return (short) mh$.invokeExact(_Character, _Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putwchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_SHORT,
                opusfile_h.C_SHORT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("putwchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * wint_t putwchar(wchar_t _Character)
     * }
     */
    public static FunctionDescriptor putwchar$descriptor() {
        return putwchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * wint_t putwchar(wchar_t _Character)
     * }
     */
    public static MethodHandle putwchar$handle() {
        return putwchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * wint_t putwchar(wchar_t _Character)
     * }
     */
    public static MemorySegment putwchar$address() {
        return putwchar.ADDR;
    }

    /**
     * {@snippet lang = c : * wint_t putwchar(wchar_t _Character)
     * }
     */
    public static short putwchar(short _Character) {
        var mh$ = putwchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putwchar", _Character);
            }
            return (short) mh$.invokeExact(_Character);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _putws {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_putws");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int _putws(const wchar_t *_Buffer)
     * }
     */
    public static FunctionDescriptor _putws$descriptor() {
        return _putws.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int _putws(const wchar_t *_Buffer)
     * }
     */
    public static MethodHandle _putws$handle() {
        return _putws.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int _putws(const wchar_t *_Buffer)
     * }
     */
    public static MemorySegment _putws$address() {
        return _putws.ADDR;
    }

    /**
     * {@snippet lang = c : * int _putws(const wchar_t *_Buffer)
     * }
     */
    public static int _putws(MemorySegment _Buffer) {
        var mh$ = _putws.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_putws", _Buffer);
            }
            return (int) mh$.invokeExact(_Buffer);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ungetwc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_SHORT,
                opusfile_h.C_SHORT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ungetwc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * wint_t ungetwc(wint_t _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor ungetwc$descriptor() {
        return ungetwc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * wint_t ungetwc(wint_t _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle ungetwc$handle() {
        return ungetwc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * wint_t ungetwc(wint_t _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment ungetwc$address() {
        return ungetwc.ADDR;
    }

    /**
     * {@snippet lang = c : * wint_t ungetwc(wint_t _Character, FILE *_Stream)
     * }
     */
    public static short ungetwc(short _Character, MemorySegment _Stream) {
        var mh$ = ungetwc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ungetwc", _Character, _Stream);
            }
            return (short) mh$.invokeExact(_Character, _Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wfdopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wfdopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * FILE *_wfdopen(int _FileHandle, const wchar_t *_Mode)
     * }
     */
    public static FunctionDescriptor _wfdopen$descriptor() {
        return _wfdopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * FILE *_wfdopen(int _FileHandle, const wchar_t *_Mode)
     * }
     */
    public static MethodHandle _wfdopen$handle() {
        return _wfdopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * FILE *_wfdopen(int _FileHandle, const wchar_t *_Mode)
     * }
     */
    public static MemorySegment _wfdopen$address() {
        return _wfdopen.ADDR;
    }

    /**
     * {@snippet lang = c : * FILE *_wfdopen(int _FileHandle, const wchar_t *_Mode)
     * }
     */
    public static MemorySegment _wfdopen(int _FileHandle, MemorySegment _Mode) {
        var mh$ = _wfdopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wfdopen", _FileHandle, _Mode);
            }
            return (MemorySegment) mh$.invokeExact(_FileHandle, _Mode);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wfopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wfopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * FILE *_wfopen(const wchar_t *_FileName, const wchar_t *_Mode)
     * }
     */
    public static FunctionDescriptor _wfopen$descriptor() {
        return _wfopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * FILE *_wfopen(const wchar_t *_FileName, const wchar_t *_Mode)
     * }
     */
    public static MethodHandle _wfopen$handle() {
        return _wfopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * FILE *_wfopen(const wchar_t *_FileName, const wchar_t *_Mode)
     * }
     */
    public static MemorySegment _wfopen$address() {
        return _wfopen.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * FILE *_wfopen(const wchar_t *_FileName, const wchar_t *_Mode)
     * }
     */
    public static MemorySegment _wfopen(MemorySegment _FileName, MemorySegment _Mode) {
        var mh$ = _wfopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wfopen", _FileName, _Mode);
            }
            return (MemorySegment) mh$.invokeExact(_FileName, _Mode);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wfopen_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wfopen_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * errno_t _wfopen_s(FILE **_Stream, const wchar_t *_FileName, const wchar_t *_Mode)
     * }
     */
    public static FunctionDescriptor _wfopen_s$descriptor() {
        return _wfopen_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * errno_t _wfopen_s(FILE **_Stream, const wchar_t *_FileName, const wchar_t *_Mode)
     * }
     */
    public static MethodHandle _wfopen_s$handle() {
        return _wfopen_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * errno_t _wfopen_s(FILE **_Stream, const wchar_t *_FileName, const wchar_t *_Mode)
     * }
     */
    public static MemorySegment _wfopen_s$address() {
        return _wfopen_s.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * errno_t _wfopen_s(FILE **_Stream, const wchar_t *_FileName, const wchar_t *_Mode)
     * }
     */
    public static int _wfopen_s(MemorySegment _Stream, MemorySegment _FileName, MemorySegment _Mode) {
        var mh$ = _wfopen_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wfopen_s", _Stream, _FileName, _Mode);
            }
            return (int) mh$.invokeExact(_Stream, _FileName, _Mode);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wfreopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wfreopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * FILE *_wfreopen(const wchar_t *_FileName, const wchar_t *_Mode, FILE *_OldStream)
     * }
     */
    public static FunctionDescriptor _wfreopen$descriptor() {
        return _wfreopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * FILE *_wfreopen(const wchar_t *_FileName, const wchar_t *_Mode, FILE *_OldStream)
     * }
     */
    public static MethodHandle _wfreopen$handle() {
        return _wfreopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * FILE *_wfreopen(const wchar_t *_FileName, const wchar_t *_Mode, FILE *_OldStream)
     * }
     */
    public static MemorySegment _wfreopen$address() {
        return _wfreopen.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * FILE *_wfreopen(const wchar_t *_FileName, const wchar_t *_Mode, FILE *_OldStream)
     * }
     */
    public static MemorySegment _wfreopen(MemorySegment _FileName, MemorySegment _Mode, MemorySegment _OldStream) {
        var mh$ = _wfreopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wfreopen", _FileName, _Mode, _OldStream);
            }
            return (MemorySegment) mh$.invokeExact(_FileName, _Mode, _OldStream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wfreopen_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wfreopen_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * errno_t _wfreopen_s(FILE **_Stream, const wchar_t *_FileName, const wchar_t *_Mode, FILE *_OldStream)
     * }
     */
    public static FunctionDescriptor _wfreopen_s$descriptor() {
        return _wfreopen_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * errno_t _wfreopen_s(FILE **_Stream, const wchar_t *_FileName, const wchar_t *_Mode, FILE *_OldStream)
     * }
     */
    public static MethodHandle _wfreopen_s$handle() {
        return _wfreopen_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * errno_t _wfreopen_s(FILE **_Stream, const wchar_t *_FileName, const wchar_t *_Mode, FILE *_OldStream)
     * }
     */
    public static MemorySegment _wfreopen_s$address() {
        return _wfreopen_s.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * errno_t _wfreopen_s(FILE **_Stream, const wchar_t *_FileName, const wchar_t *_Mode, FILE *_OldStream)
     * }
     */
    public static int _wfreopen_s(MemorySegment _Stream, MemorySegment _FileName, MemorySegment _Mode,
            MemorySegment _OldStream) {
        var mh$ = _wfreopen_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wfreopen_s", _Stream, _FileName, _Mode, _OldStream);
            }
            return (int) mh$.invokeExact(_Stream, _FileName, _Mode, _OldStream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wfsopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wfsopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * FILE *_wfsopen(const wchar_t *_FileName, const wchar_t *_Mode, int _ShFlag)
     * }
     */
    public static FunctionDescriptor _wfsopen$descriptor() {
        return _wfsopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * FILE *_wfsopen(const wchar_t *_FileName, const wchar_t *_Mode, int _ShFlag)
     * }
     */
    public static MethodHandle _wfsopen$handle() {
        return _wfsopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * FILE *_wfsopen(const wchar_t *_FileName, const wchar_t *_Mode, int _ShFlag)
     * }
     */
    public static MemorySegment _wfsopen$address() {
        return _wfsopen.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * FILE *_wfsopen(const wchar_t *_FileName, const wchar_t *_Mode, int _ShFlag)
     * }
     */
    public static MemorySegment _wfsopen(MemorySegment _FileName, MemorySegment _Mode, int _ShFlag) {
        var mh$ = _wfsopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wfsopen", _FileName, _Mode, _ShFlag);
            }
            return (MemorySegment) mh$.invokeExact(_FileName, _Mode, _ShFlag);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wperror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wperror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * void _wperror(const wchar_t *_ErrorMessage)
     * }
     */
    public static FunctionDescriptor _wperror$descriptor() {
        return _wperror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * void _wperror(const wchar_t *_ErrorMessage)
     * }
     */
    public static MethodHandle _wperror$handle() {
        return _wperror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * void _wperror(const wchar_t *_ErrorMessage)
     * }
     */
    public static MemorySegment _wperror$address() {
        return _wperror.ADDR;
    }

    /**
     * {@snippet lang = c : * void _wperror(const wchar_t *_ErrorMessage)
     * }
     */
    public static void _wperror(MemorySegment _ErrorMessage) {
        var mh$ = _wperror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wperror", _ErrorMessage);
            }
            mh$.invokeExact(_ErrorMessage);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wpopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wpopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * FILE *_wpopen(const wchar_t *_Command, const wchar_t *_Mode)
     * }
     */
    public static FunctionDescriptor _wpopen$descriptor() {
        return _wpopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * FILE *_wpopen(const wchar_t *_Command, const wchar_t *_Mode)
     * }
     */
    public static MethodHandle _wpopen$handle() {
        return _wpopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * FILE *_wpopen(const wchar_t *_Command, const wchar_t *_Mode)
     * }
     */
    public static MemorySegment _wpopen$address() {
        return _wpopen.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * FILE *_wpopen(const wchar_t *_Command, const wchar_t *_Mode)
     * }
     */
    public static MemorySegment _wpopen(MemorySegment _Command, MemorySegment _Mode) {
        var mh$ = _wpopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wpopen", _Command, _Mode);
            }
            return (MemorySegment) mh$.invokeExact(_Command, _Mode);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wremove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wremove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int _wremove(const wchar_t *_FileName)
     * }
     */
    public static FunctionDescriptor _wremove$descriptor() {
        return _wremove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int _wremove(const wchar_t *_FileName)
     * }
     */
    public static MethodHandle _wremove$handle() {
        return _wremove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int _wremove(const wchar_t *_FileName)
     * }
     */
    public static MemorySegment _wremove$address() {
        return _wremove.ADDR;
    }

    /**
     * {@snippet lang = c : * int _wremove(const wchar_t *_FileName)
     * }
     */
    public static int _wremove(MemorySegment _FileName) {
        var mh$ = _wremove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wremove", _FileName);
            }
            return (int) mh$.invokeExact(_FileName);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtempnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wtempnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * wchar_t *_wtempnam(const wchar_t *_Directory, const wchar_t *_FilePrefix)
     * }
     */
    public static FunctionDescriptor _wtempnam$descriptor() {
        return _wtempnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * wchar_t *_wtempnam(const wchar_t *_Directory, const wchar_t *_FilePrefix)
     * }
     */
    public static MethodHandle _wtempnam$handle() {
        return _wtempnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * wchar_t *_wtempnam(const wchar_t *_Directory, const wchar_t *_FilePrefix)
     * }
     */
    public static MemorySegment _wtempnam$address() {
        return _wtempnam.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * wchar_t *_wtempnam(const wchar_t *_Directory, const wchar_t *_FilePrefix)
     * }
     */
    public static MemorySegment _wtempnam(MemorySegment _Directory, MemorySegment _FilePrefix) {
        var mh$ = _wtempnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtempnam", _Directory, _FilePrefix);
            }
            return (MemorySegment) mh$.invokeExact(_Directory, _FilePrefix);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtmpnam_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_LONG_LONG);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wtmpnam_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * errno_t _wtmpnam_s(wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static FunctionDescriptor _wtmpnam_s$descriptor() {
        return _wtmpnam_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * errno_t _wtmpnam_s(wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static MethodHandle _wtmpnam_s$handle() {
        return _wtmpnam_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * errno_t _wtmpnam_s(wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static MemorySegment _wtmpnam_s$address() {
        return _wtmpnam_s.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * errno_t _wtmpnam_s(wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static int _wtmpnam_s(MemorySegment _Buffer, long _BufferCount) {
        var mh$ = _wtmpnam_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtmpnam_s", _Buffer, _BufferCount);
            }
            return (int) mh$.invokeExact(_Buffer, _BufferCount);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtmpnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wtmpnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * wchar_t *_wtmpnam(wchar_t *_Buffer)
     * }
     */
    public static FunctionDescriptor _wtmpnam$descriptor() {
        return _wtmpnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * wchar_t *_wtmpnam(wchar_t *_Buffer)
     * }
     */
    public static MethodHandle _wtmpnam$handle() {
        return _wtmpnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * wchar_t *_wtmpnam(wchar_t *_Buffer)
     * }
     */
    public static MemorySegment _wtmpnam$address() {
        return _wtmpnam.ADDR;
    }

    /**
     * {@snippet lang = c : * wchar_t *_wtmpnam(wchar_t *_Buffer)
     * }
     */
    public static MemorySegment _wtmpnam(MemorySegment _Buffer) {
        var mh$ = _wtmpnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtmpnam", _Buffer);
            }
            return (MemorySegment) mh$.invokeExact(_Buffer);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fgetwc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_SHORT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fgetwc_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * wint_t _fgetwc_nolock(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fgetwc_nolock$descriptor() {
        return _fgetwc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * wint_t _fgetwc_nolock(FILE *_Stream)
     * }
     */
    public static MethodHandle _fgetwc_nolock$handle() {
        return _fgetwc_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * wint_t _fgetwc_nolock(FILE *_Stream)
     * }
     */
    public static MemorySegment _fgetwc_nolock$address() {
        return _fgetwc_nolock.ADDR;
    }

    /**
     * {@snippet lang = c : * wint_t _fgetwc_nolock(FILE *_Stream)
     * }
     */
    public static short _fgetwc_nolock(MemorySegment _Stream) {
        var mh$ = _fgetwc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fgetwc_nolock", _Stream);
            }
            return (short) mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fputwc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_SHORT,
                opusfile_h.C_SHORT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fputwc_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * wint_t _fputwc_nolock(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fputwc_nolock$descriptor() {
        return _fputwc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * wint_t _fputwc_nolock(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle _fputwc_nolock$handle() {
        return _fputwc_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * wint_t _fputwc_nolock(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment _fputwc_nolock$address() {
        return _fputwc_nolock.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * wint_t _fputwc_nolock(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static short _fputwc_nolock(short _Character, MemorySegment _Stream) {
        var mh$ = _fputwc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fputwc_nolock", _Character, _Stream);
            }
            return (short) mh$.invokeExact(_Character, _Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _getwc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_SHORT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_getwc_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * wint_t _getwc_nolock(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _getwc_nolock$descriptor() {
        return _getwc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * wint_t _getwc_nolock(FILE *_Stream)
     * }
     */
    public static MethodHandle _getwc_nolock$handle() {
        return _getwc_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * wint_t _getwc_nolock(FILE *_Stream)
     * }
     */
    public static MemorySegment _getwc_nolock$address() {
        return _getwc_nolock.ADDR;
    }

    /**
     * {@snippet lang = c : * wint_t _getwc_nolock(FILE *_Stream)
     * }
     */
    public static short _getwc_nolock(MemorySegment _Stream) {
        var mh$ = _getwc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_getwc_nolock", _Stream);
            }
            return (short) mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _putwc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_SHORT,
                opusfile_h.C_SHORT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_putwc_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * wint_t _putwc_nolock(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _putwc_nolock$descriptor() {
        return _putwc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * wint_t _putwc_nolock(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle _putwc_nolock$handle() {
        return _putwc_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * wint_t _putwc_nolock(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment _putwc_nolock$address() {
        return _putwc_nolock.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * wint_t _putwc_nolock(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static short _putwc_nolock(short _Character, MemorySegment _Stream) {
        var mh$ = _putwc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_putwc_nolock", _Character, _Stream);
            }
            return (short) mh$.invokeExact(_Character, _Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ungetwc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_SHORT,
                opusfile_h.C_SHORT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ungetwc_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * wint_t _ungetwc_nolock(wint_t _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _ungetwc_nolock$descriptor() {
        return _ungetwc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * wint_t _ungetwc_nolock(wint_t _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle _ungetwc_nolock$handle() {
        return _ungetwc_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * wint_t _ungetwc_nolock(wint_t _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment _ungetwc_nolock$address() {
        return _ungetwc_nolock.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * wint_t _ungetwc_nolock(wint_t _Character, FILE *_Stream)
     * }
     */
    public static short _ungetwc_nolock(short _Character, MemorySegment _Stream) {
        var mh$ = _ungetwc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ungetwc_nolock", _Character, _Stream);
            }
            return (short) mh$.invokeExact(_Character, _Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vfwprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__stdio_common_vfwprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int __stdio_common_vfwprintf(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vfwprintf$descriptor() {
        return __stdio_common_vfwprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int __stdio_common_vfwprintf(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vfwprintf$handle() {
        return __stdio_common_vfwprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int __stdio_common_vfwprintf(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vfwprintf$address() {
        return __stdio_common_vfwprintf.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int __stdio_common_vfwprintf(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vfwprintf(long _Options, MemorySegment _Stream, MemorySegment _Format,
            MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vfwprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vfwprintf", _Options, _Stream, _Format, _Locale, _ArgList);
            }
            return (int) mh$.invokeExact(_Options, _Stream, _Format, _Locale, _ArgList);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vfwprintf_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__stdio_common_vfwprintf_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int __stdio_common_vfwprintf_s(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vfwprintf_s$descriptor() {
        return __stdio_common_vfwprintf_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int __stdio_common_vfwprintf_s(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vfwprintf_s$handle() {
        return __stdio_common_vfwprintf_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int __stdio_common_vfwprintf_s(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vfwprintf_s$address() {
        return __stdio_common_vfwprintf_s.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int __stdio_common_vfwprintf_s(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vfwprintf_s(long _Options, MemorySegment _Stream, MemorySegment _Format,
            MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vfwprintf_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vfwprintf_s", _Options, _Stream, _Format, _Locale, _ArgList);
            }
            return (int) mh$.invokeExact(_Options, _Stream, _Format, _Locale, _ArgList);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vfwprintf_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__stdio_common_vfwprintf_p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int __stdio_common_vfwprintf_p(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vfwprintf_p$descriptor() {
        return __stdio_common_vfwprintf_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int __stdio_common_vfwprintf_p(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vfwprintf_p$handle() {
        return __stdio_common_vfwprintf_p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int __stdio_common_vfwprintf_p(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vfwprintf_p$address() {
        return __stdio_common_vfwprintf_p.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int __stdio_common_vfwprintf_p(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vfwprintf_p(long _Options, MemorySegment _Stream, MemorySegment _Format,
            MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vfwprintf_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vfwprintf_p", _Options, _Stream, _Format, _Locale, _ArgList);
            }
            return (int) mh$.invokeExact(_Options, _Stream, _Format, _Locale, _ArgList);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vfwscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__stdio_common_vfwscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int __stdio_common_vfwscanf(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vfwscanf$descriptor() {
        return __stdio_common_vfwscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int __stdio_common_vfwscanf(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vfwscanf$handle() {
        return __stdio_common_vfwscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int __stdio_common_vfwscanf(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vfwscanf$address() {
        return __stdio_common_vfwscanf.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int __stdio_common_vfwscanf(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vfwscanf(long _Options, MemorySegment _Stream, MemorySegment _Format,
            MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vfwscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vfwscanf", _Options, _Stream, _Format, _Locale, _ArgList);
            }
            return (int) mh$.invokeExact(_Options, _Stream, _Format, _Locale, _ArgList);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vswprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__stdio_common_vswprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int __stdio_common_vswprintf(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vswprintf$descriptor() {
        return __stdio_common_vswprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int __stdio_common_vswprintf(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vswprintf$handle() {
        return __stdio_common_vswprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int __stdio_common_vswprintf(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vswprintf$address() {
        return __stdio_common_vswprintf.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int __stdio_common_vswprintf(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vswprintf(long _Options, MemorySegment _Buffer, long _BufferCount,
            MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vswprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vswprintf", _Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
            }
            return (int) mh$.invokeExact(_Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vswprintf_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__stdio_common_vswprintf_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int __stdio_common_vswprintf_s(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vswprintf_s$descriptor() {
        return __stdio_common_vswprintf_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int __stdio_common_vswprintf_s(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vswprintf_s$handle() {
        return __stdio_common_vswprintf_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int __stdio_common_vswprintf_s(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vswprintf_s$address() {
        return __stdio_common_vswprintf_s.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int __stdio_common_vswprintf_s(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vswprintf_s(long _Options, MemorySegment _Buffer, long _BufferCount,
            MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vswprintf_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vswprintf_s", _Options, _Buffer, _BufferCount, _Format, _Locale,
                        _ArgList);
            }
            return (int) mh$.invokeExact(_Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vsnwprintf_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__stdio_common_vsnwprintf_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int __stdio_common_vsnwprintf_s(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, size_t _MaxCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vsnwprintf_s$descriptor() {
        return __stdio_common_vsnwprintf_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int __stdio_common_vsnwprintf_s(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, size_t _MaxCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vsnwprintf_s$handle() {
        return __stdio_common_vsnwprintf_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int __stdio_common_vsnwprintf_s(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, size_t _MaxCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vsnwprintf_s$address() {
        return __stdio_common_vsnwprintf_s.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int __stdio_common_vsnwprintf_s(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, size_t _MaxCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vsnwprintf_s(long _Options, MemorySegment _Buffer, long _BufferCount,
            long _MaxCount, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vsnwprintf_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vsnwprintf_s", _Options, _Buffer, _BufferCount, _MaxCount, _Format,
                        _Locale, _ArgList);
            }
            return (int) mh$.invokeExact(_Options, _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vswprintf_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__stdio_common_vswprintf_p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int __stdio_common_vswprintf_p(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vswprintf_p$descriptor() {
        return __stdio_common_vswprintf_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int __stdio_common_vswprintf_p(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vswprintf_p$handle() {
        return __stdio_common_vswprintf_p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int __stdio_common_vswprintf_p(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vswprintf_p$address() {
        return __stdio_common_vswprintf_p.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int __stdio_common_vswprintf_p(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vswprintf_p(long _Options, MemorySegment _Buffer, long _BufferCount,
            MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vswprintf_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vswprintf_p", _Options, _Buffer, _BufferCount, _Format, _Locale,
                        _ArgList);
            }
            return (int) mh$.invokeExact(_Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vswscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__stdio_common_vswscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int __stdio_common_vswscanf(unsigned long long _Options, const wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vswscanf$descriptor() {
        return __stdio_common_vswscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int __stdio_common_vswscanf(unsigned long long _Options, const wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vswscanf$handle() {
        return __stdio_common_vswscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int __stdio_common_vswscanf(unsigned long long _Options, const wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vswscanf$address() {
        return __stdio_common_vswscanf.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int __stdio_common_vswscanf(unsigned long long _Options, const wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vswscanf(long _Options, MemorySegment _Buffer, long _BufferCount,
            MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vswscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vswscanf", _Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
            }
            return (int) mh$.invokeExact(_Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * {@snippet lang = c : * typedef long long fpos_t
     * }
     */
    public static final OfLong fpos_t = opusfile_h.C_LONG_LONG;

    private static class _get_stream_buffer_pointers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_get_stream_buffer_pointers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * errno_t _get_stream_buffer_pointers(FILE *_Stream, char ***_Base, char ***_Pointer, int **_Count)
     * }
     */
    public static FunctionDescriptor _get_stream_buffer_pointers$descriptor() {
        return _get_stream_buffer_pointers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * errno_t _get_stream_buffer_pointers(FILE *_Stream, char ***_Base, char ***_Pointer, int **_Count)
     * }
     */
    public static MethodHandle _get_stream_buffer_pointers$handle() {
        return _get_stream_buffer_pointers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * errno_t _get_stream_buffer_pointers(FILE *_Stream, char ***_Base, char ***_Pointer, int **_Count)
     * }
     */
    public static MemorySegment _get_stream_buffer_pointers$address() {
        return _get_stream_buffer_pointers.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * errno_t _get_stream_buffer_pointers(FILE *_Stream, char ***_Base, char ***_Pointer, int **_Count)
     * }
     */
    public static int _get_stream_buffer_pointers(MemorySegment _Stream, MemorySegment _Base, MemorySegment _Pointer,
            MemorySegment _Count) {
        var mh$ = _get_stream_buffer_pointers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_stream_buffer_pointers", _Stream, _Base, _Pointer, _Count);
            }
            return (int) mh$.invokeExact(_Stream, _Base, _Pointer, _Count);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearerr_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("clearerr_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * errno_t clearerr_s(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor clearerr_s$descriptor() {
        return clearerr_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * errno_t clearerr_s(FILE *_Stream)
     * }
     */
    public static MethodHandle clearerr_s$handle() {
        return clearerr_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * errno_t clearerr_s(FILE *_Stream)
     * }
     */
    public static MemorySegment clearerr_s$address() {
        return clearerr_s.ADDR;
    }

    /**
     * {@snippet lang = c : * errno_t clearerr_s(FILE *_Stream)
     * }
     */
    public static int clearerr_s(MemorySegment _Stream) {
        var mh$ = clearerr_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearerr_s", _Stream);
            }
            return (int) mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fopen_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fopen_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * errno_t fopen_s(FILE **_Stream, const char *_FileName, const char *_Mode)
     * }
     */
    public static FunctionDescriptor fopen_s$descriptor() {
        return fopen_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * errno_t fopen_s(FILE **_Stream, const char *_FileName, const char *_Mode)
     * }
     */
    public static MethodHandle fopen_s$handle() {
        return fopen_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * errno_t fopen_s(FILE **_Stream, const char *_FileName, const char *_Mode)
     * }
     */
    public static MemorySegment fopen_s$address() {
        return fopen_s.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * errno_t fopen_s(FILE **_Stream, const char *_FileName, const char *_Mode)
     * }
     */
    public static int fopen_s(MemorySegment _Stream, MemorySegment _FileName, MemorySegment _Mode) {
        var mh$ = fopen_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fopen_s", _Stream, _FileName, _Mode);
            }
            return (int) mh$.invokeExact(_Stream, _FileName, _Mode);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fread_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fread_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * size_t fread_s(void *_Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fread_s$descriptor() {
        return fread_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * size_t fread_s(void *_Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MethodHandle fread_s$handle() {
        return fread_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * size_t fread_s(void *_Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MemorySegment fread_s$address() {
        return fread_s.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * size_t fread_s(void *_Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static long fread_s(MemorySegment _Buffer, long _BufferSize, long _ElementSize, long _ElementCount,
            MemorySegment _Stream) {
        var mh$ = fread_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fread_s", _Buffer, _BufferSize, _ElementSize, _ElementCount, _Stream);
            }
            return (long) mh$.invokeExact(_Buffer, _BufferSize, _ElementSize, _ElementCount, _Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class freopen_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("freopen_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * errno_t freopen_s(FILE **_Stream, const char *_FileName, const char *_Mode, FILE *_OldStream)
     * }
     */
    public static FunctionDescriptor freopen_s$descriptor() {
        return freopen_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * errno_t freopen_s(FILE **_Stream, const char *_FileName, const char *_Mode, FILE *_OldStream)
     * }
     */
    public static MethodHandle freopen_s$handle() {
        return freopen_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * errno_t freopen_s(FILE **_Stream, const char *_FileName, const char *_Mode, FILE *_OldStream)
     * }
     */
    public static MemorySegment freopen_s$address() {
        return freopen_s.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * errno_t freopen_s(FILE **_Stream, const char *_FileName, const char *_Mode, FILE *_OldStream)
     * }
     */
    public static int freopen_s(MemorySegment _Stream, MemorySegment _FileName, MemorySegment _Mode,
            MemorySegment _OldStream) {
        var mh$ = freopen_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("freopen_s", _Stream, _FileName, _Mode, _OldStream);
            }
            return (int) mh$.invokeExact(_Stream, _FileName, _Mode, _OldStream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gets_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_LONG_LONG);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("gets_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * char *gets_s(char *_Buffer, rsize_t _Size)
     * }
     */
    public static FunctionDescriptor gets_s$descriptor() {
        return gets_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * char *gets_s(char *_Buffer, rsize_t _Size)
     * }
     */
    public static MethodHandle gets_s$handle() {
        return gets_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * char *gets_s(char *_Buffer, rsize_t _Size)
     * }
     */
    public static MemorySegment gets_s$address() {
        return gets_s.ADDR;
    }

    /**
     * {@snippet lang = c : * char *gets_s(char *_Buffer, rsize_t _Size)
     * }
     */
    public static MemorySegment gets_s(MemorySegment _Buffer, long _Size) {
        var mh$ = gets_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gets_s", _Buffer, _Size);
            }
            return (MemorySegment) mh$.invokeExact(_Buffer, _Size);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpfile_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("tmpfile_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * errno_t tmpfile_s(FILE **_Stream)
     * }
     */
    public static FunctionDescriptor tmpfile_s$descriptor() {
        return tmpfile_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * errno_t tmpfile_s(FILE **_Stream)
     * }
     */
    public static MethodHandle tmpfile_s$handle() {
        return tmpfile_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * errno_t tmpfile_s(FILE **_Stream)
     * }
     */
    public static MemorySegment tmpfile_s$address() {
        return tmpfile_s.ADDR;
    }

    /**
     * {@snippet lang = c : * errno_t tmpfile_s(FILE **_Stream)
     * }
     */
    public static int tmpfile_s(MemorySegment _Stream) {
        var mh$ = tmpfile_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpfile_s", _Stream);
            }
            return (int) mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpnam_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_LONG_LONG);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("tmpnam_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * errno_t tmpnam_s(char *_Buffer, rsize_t _Size)
     * }
     */
    public static FunctionDescriptor tmpnam_s$descriptor() {
        return tmpnam_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * errno_t tmpnam_s(char *_Buffer, rsize_t _Size)
     * }
     */
    public static MethodHandle tmpnam_s$handle() {
        return tmpnam_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * errno_t tmpnam_s(char *_Buffer, rsize_t _Size)
     * }
     */
    public static MemorySegment tmpnam_s$address() {
        return tmpnam_s.ADDR;
    }

    /**
     * {@snippet lang = c : * errno_t tmpnam_s(char *_Buffer, rsize_t _Size)
     * }
     */
    public static int tmpnam_s(MemorySegment _Buffer, long _Size) {
        var mh$ = tmpnam_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpnam_s", _Buffer, _Size);
            }
            return (int) mh$.invokeExact(_Buffer, _Size);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearerr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("clearerr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * void clearerr(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor clearerr$descriptor() {
        return clearerr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * void clearerr(FILE *_Stream)
     * }
     */
    public static MethodHandle clearerr$handle() {
        return clearerr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * void clearerr(FILE *_Stream)
     * }
     */
    public static MemorySegment clearerr$address() {
        return clearerr.ADDR;
    }

    /**
     * {@snippet lang = c : * void clearerr(FILE *_Stream)
     * }
     */
    public static void clearerr(MemorySegment _Stream) {
        var mh$ = clearerr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearerr", _Stream);
            }
            mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int fclose(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fclose$descriptor() {
        return fclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int fclose(FILE *_Stream)
     * }
     */
    public static MethodHandle fclose$handle() {
        return fclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int fclose(FILE *_Stream)
     * }
     */
    public static MemorySegment fclose$address() {
        return fclose.ADDR;
    }

    /**
     * {@snippet lang = c : * int fclose(FILE *_Stream)
     * }
     */
    public static int fclose(MemorySegment _Stream) {
        var mh$ = fclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fclose", _Stream);
            }
            return (int) mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fcloseall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fcloseall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int _fcloseall()
     * }
     */
    public static FunctionDescriptor _fcloseall$descriptor() {
        return _fcloseall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int _fcloseall()
     * }
     */
    public static MethodHandle _fcloseall$handle() {
        return _fcloseall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int _fcloseall()
     * }
     */
    public static MemorySegment _fcloseall$address() {
        return _fcloseall.ADDR;
    }

    /**
     * {@snippet lang = c : * int _fcloseall()
     * }
     */
    public static int _fcloseall() {
        var mh$ = _fcloseall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fcloseall");
            }
            return (int) mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fdopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * FILE *_fdopen(int _FileHandle, const char *_Mode)
     * }
     */
    public static FunctionDescriptor _fdopen$descriptor() {
        return _fdopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * FILE *_fdopen(int _FileHandle, const char *_Mode)
     * }
     */
    public static MethodHandle _fdopen$handle() {
        return _fdopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * FILE *_fdopen(int _FileHandle, const char *_Mode)
     * }
     */
    public static MemorySegment _fdopen$address() {
        return _fdopen.ADDR;
    }

    /**
     * {@snippet lang = c : * FILE *_fdopen(int _FileHandle, const char *_Mode)
     * }
     */
    public static MemorySegment _fdopen(int _FileHandle, MemorySegment _Mode) {
        var mh$ = _fdopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdopen", _FileHandle, _Mode);
            }
            return (MemorySegment) mh$.invokeExact(_FileHandle, _Mode);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class feof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("feof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int feof(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor feof$descriptor() {
        return feof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int feof(FILE *_Stream)
     * }
     */
    public static MethodHandle feof$handle() {
        return feof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int feof(FILE *_Stream)
     * }
     */
    public static MemorySegment feof$address() {
        return feof.ADDR;
    }

    /**
     * {@snippet lang = c : * int feof(FILE *_Stream)
     * }
     */
    public static int feof(MemorySegment _Stream) {
        var mh$ = feof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("feof", _Stream);
            }
            return (int) mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ferror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ferror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int ferror(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor ferror$descriptor() {
        return ferror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int ferror(FILE *_Stream)
     * }
     */
    public static MethodHandle ferror$handle() {
        return ferror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int ferror(FILE *_Stream)
     * }
     */
    public static MemorySegment ferror$address() {
        return ferror.ADDR;
    }

    /**
     * {@snippet lang = c : * int ferror(FILE *_Stream)
     * }
     */
    public static int ferror(MemorySegment _Stream) {
        var mh$ = ferror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ferror", _Stream);
            }
            return (int) mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fflush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fflush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int fflush(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fflush$descriptor() {
        return fflush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int fflush(FILE *_Stream)
     * }
     */
    public static MethodHandle fflush$handle() {
        return fflush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int fflush(FILE *_Stream)
     * }
     */
    public static MemorySegment fflush$address() {
        return fflush.ADDR;
    }

    /**
     * {@snippet lang = c : * int fflush(FILE *_Stream)
     * }
     */
    public static int fflush(MemorySegment _Stream) {
        var mh$ = fflush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fflush", _Stream);
            }
            return (int) mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fgetc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int fgetc(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fgetc$descriptor() {
        return fgetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int fgetc(FILE *_Stream)
     * }
     */
    public static MethodHandle fgetc$handle() {
        return fgetc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int fgetc(FILE *_Stream)
     * }
     */
    public static MemorySegment fgetc$address() {
        return fgetc.ADDR;
    }

    /**
     * {@snippet lang = c : * int fgetc(FILE *_Stream)
     * }
     */
    public static int fgetc(MemorySegment _Stream) {
        var mh$ = fgetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetc", _Stream);
            }
            return (int) mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fgetchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fgetchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int _fgetchar()
     * }
     */
    public static FunctionDescriptor _fgetchar$descriptor() {
        return _fgetchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int _fgetchar()
     * }
     */
    public static MethodHandle _fgetchar$handle() {
        return _fgetchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int _fgetchar()
     * }
     */
    public static MemorySegment _fgetchar$address() {
        return _fgetchar.ADDR;
    }

    /**
     * {@snippet lang = c : * int _fgetchar()
     * }
     */
    public static int _fgetchar() {
        var mh$ = _fgetchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fgetchar");
            }
            return (int) mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fgetpos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int fgetpos(FILE *_Stream, fpos_t *_Position)
     * }
     */
    public static FunctionDescriptor fgetpos$descriptor() {
        return fgetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int fgetpos(FILE *_Stream, fpos_t *_Position)
     * }
     */
    public static MethodHandle fgetpos$handle() {
        return fgetpos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int fgetpos(FILE *_Stream, fpos_t *_Position)
     * }
     */
    public static MemorySegment fgetpos$address() {
        return fgetpos.ADDR;
    }

    /**
     * {@snippet lang = c : * int fgetpos(FILE *_Stream, fpos_t *_Position)
     * }
     */
    public static int fgetpos(MemorySegment _Stream, MemorySegment _Position) {
        var mh$ = fgetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetpos", _Stream, _Position);
            }
            return (int) mh$.invokeExact(_Stream, _Position);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fgets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * char *fgets(char *_Buffer, int _MaxCount, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fgets$descriptor() {
        return fgets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * char *fgets(char *_Buffer, int _MaxCount, FILE *_Stream)
     * }
     */
    public static MethodHandle fgets$handle() {
        return fgets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * char *fgets(char *_Buffer, int _MaxCount, FILE *_Stream)
     * }
     */
    public static MemorySegment fgets$address() {
        return fgets.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * char *fgets(char *_Buffer, int _MaxCount, FILE *_Stream)
     * }
     */
    public static MemorySegment fgets(MemorySegment _Buffer, int _MaxCount, MemorySegment _Stream) {
        var mh$ = fgets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgets", _Buffer, _MaxCount, _Stream);
            }
            return (MemorySegment) mh$.invokeExact(_Buffer, _MaxCount, _Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fileno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fileno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int _fileno(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fileno$descriptor() {
        return _fileno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int _fileno(FILE *_Stream)
     * }
     */
    public static MethodHandle _fileno$handle() {
        return _fileno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int _fileno(FILE *_Stream)
     * }
     */
    public static MemorySegment _fileno$address() {
        return _fileno.ADDR;
    }

    /**
     * {@snippet lang = c : * int _fileno(FILE *_Stream)
     * }
     */
    public static int _fileno(MemorySegment _Stream) {
        var mh$ = _fileno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fileno", _Stream);
            }
            return (int) mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _flushall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_flushall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int _flushall()
     * }
     */
    public static FunctionDescriptor _flushall$descriptor() {
        return _flushall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int _flushall()
     * }
     */
    public static MethodHandle _flushall$handle() {
        return _flushall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int _flushall()
     * }
     */
    public static MemorySegment _flushall$address() {
        return _flushall.ADDR;
    }

    /**
     * {@snippet lang = c : * int _flushall()
     * }
     */
    public static int _flushall() {
        var mh$ = _flushall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_flushall");
            }
            return (int) mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * FILE *fopen(const char *_FileName, const char *_Mode)
     * }
     */
    public static FunctionDescriptor fopen$descriptor() {
        return fopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * FILE *fopen(const char *_FileName, const char *_Mode)
     * }
     */
    public static MethodHandle fopen$handle() {
        return fopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * FILE *fopen(const char *_FileName, const char *_Mode)
     * }
     */
    public static MemorySegment fopen$address() {
        return fopen.ADDR;
    }

    /**
     * {@snippet lang = c : * FILE *fopen(const char *_FileName, const char *_Mode)
     * }
     */
    public static MemorySegment fopen(MemorySegment _FileName, MemorySegment _Mode) {
        var mh$ = fopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fopen", _FileName, _Mode);
            }
            return (MemorySegment) mh$.invokeExact(_FileName, _Mode);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fputc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int fputc(int _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fputc$descriptor() {
        return fputc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int fputc(int _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle fputc$handle() {
        return fputc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int fputc(int _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment fputc$address() {
        return fputc.ADDR;
    }

    /**
     * {@snippet lang = c : * int fputc(int _Character, FILE *_Stream)
     * }
     */
    public static int fputc(int _Character, MemorySegment _Stream) {
        var mh$ = fputc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputc", _Character, _Stream);
            }
            return (int) mh$.invokeExact(_Character, _Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fputchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fputchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int _fputchar(int _Character)
     * }
     */
    public static FunctionDescriptor _fputchar$descriptor() {
        return _fputchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int _fputchar(int _Character)
     * }
     */
    public static MethodHandle _fputchar$handle() {
        return _fputchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int _fputchar(int _Character)
     * }
     */
    public static MemorySegment _fputchar$address() {
        return _fputchar.ADDR;
    }

    /**
     * {@snippet lang = c : * int _fputchar(int _Character)
     * }
     */
    public static int _fputchar(int _Character) {
        var mh$ = _fputchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fputchar", _Character);
            }
            return (int) mh$.invokeExact(_Character);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fputs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int fputs(const char *_Buffer, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fputs$descriptor() {
        return fputs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int fputs(const char *_Buffer, FILE *_Stream)
     * }
     */
    public static MethodHandle fputs$handle() {
        return fputs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int fputs(const char *_Buffer, FILE *_Stream)
     * }
     */
    public static MemorySegment fputs$address() {
        return fputs.ADDR;
    }

    /**
     * {@snippet lang = c : * int fputs(const char *_Buffer, FILE *_Stream)
     * }
     */
    public static int fputs(MemorySegment _Buffer, MemorySegment _Stream) {
        var mh$ = fputs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputs", _Buffer, _Stream);
            }
            return (int) mh$.invokeExact(_Buffer, _Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * unsigned long long fread(void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fread$descriptor() {
        return fread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * unsigned long long fread(void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MethodHandle fread$handle() {
        return fread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * unsigned long long fread(void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MemorySegment fread$address() {
        return fread.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * unsigned long long fread(void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static long fread(MemorySegment _Buffer, long _ElementSize, long _ElementCount, MemorySegment _Stream) {
        var mh$ = fread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fread", _Buffer, _ElementSize, _ElementCount, _Stream);
            }
            return (long) mh$.invokeExact(_Buffer, _ElementSize, _ElementCount, _Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class freopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("freopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * FILE *freopen(const char *_FileName, const char *_Mode, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor freopen$descriptor() {
        return freopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * FILE *freopen(const char *_FileName, const char *_Mode, FILE *_Stream)
     * }
     */
    public static MethodHandle freopen$handle() {
        return freopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * FILE *freopen(const char *_FileName, const char *_Mode, FILE *_Stream)
     * }
     */
    public static MemorySegment freopen$address() {
        return freopen.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * FILE *freopen(const char *_FileName, const char *_Mode, FILE *_Stream)
     * }
     */
    public static MemorySegment freopen(MemorySegment _FileName, MemorySegment _Mode, MemorySegment _Stream) {
        var mh$ = freopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("freopen", _FileName, _Mode, _Stream);
            }
            return (MemorySegment) mh$.invokeExact(_FileName, _Mode, _Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fsopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fsopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * FILE *_fsopen(const char *_FileName, const char *_Mode, int _ShFlag)
     * }
     */
    public static FunctionDescriptor _fsopen$descriptor() {
        return _fsopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * FILE *_fsopen(const char *_FileName, const char *_Mode, int _ShFlag)
     * }
     */
    public static MethodHandle _fsopen$handle() {
        return _fsopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * FILE *_fsopen(const char *_FileName, const char *_Mode, int _ShFlag)
     * }
     */
    public static MemorySegment _fsopen$address() {
        return _fsopen.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * FILE *_fsopen(const char *_FileName, const char *_Mode, int _ShFlag)
     * }
     */
    public static MemorySegment _fsopen(MemorySegment _FileName, MemorySegment _Mode, int _ShFlag) {
        var mh$ = _fsopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fsopen", _FileName, _Mode, _ShFlag);
            }
            return (MemorySegment) mh$.invokeExact(_FileName, _Mode, _ShFlag);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fsetpos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int fsetpos(FILE *_Stream, const fpos_t *_Position)
     * }
     */
    public static FunctionDescriptor fsetpos$descriptor() {
        return fsetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int fsetpos(FILE *_Stream, const fpos_t *_Position)
     * }
     */
    public static MethodHandle fsetpos$handle() {
        return fsetpos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int fsetpos(FILE *_Stream, const fpos_t *_Position)
     * }
     */
    public static MemorySegment fsetpos$address() {
        return fsetpos.ADDR;
    }

    /**
     * {@snippet lang = c : * int fsetpos(FILE *_Stream, const fpos_t *_Position)
     * }
     */
    public static int fsetpos(MemorySegment _Stream, MemorySegment _Position) {
        var mh$ = fsetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsetpos", _Stream, _Position);
            }
            return (int) mh$.invokeExact(_Stream, _Position);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fseek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_LONG,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fseek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int fseek(FILE *_Stream, long _Offset, int _Origin)
     * }
     */
    public static FunctionDescriptor fseek$descriptor() {
        return fseek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int fseek(FILE *_Stream, long _Offset, int _Origin)
     * }
     */
    public static MethodHandle fseek$handle() {
        return fseek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int fseek(FILE *_Stream, long _Offset, int _Origin)
     * }
     */
    public static MemorySegment fseek$address() {
        return fseek.ADDR;
    }

    /**
     * {@snippet lang = c : * int fseek(FILE *_Stream, long _Offset, int _Origin)
     * }
     */
    public static int fseek(MemorySegment _Stream, int _Offset, int _Origin) {
        var mh$ = fseek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fseek", _Stream, _Offset, _Origin);
            }
            return (int) mh$.invokeExact(_Stream, _Offset, _Origin);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fseeki64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fseeki64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int _fseeki64(FILE *_Stream, long long _Offset, int _Origin)
     * }
     */
    public static FunctionDescriptor _fseeki64$descriptor() {
        return _fseeki64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int _fseeki64(FILE *_Stream, long long _Offset, int _Origin)
     * }
     */
    public static MethodHandle _fseeki64$handle() {
        return _fseeki64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int _fseeki64(FILE *_Stream, long long _Offset, int _Origin)
     * }
     */
    public static MemorySegment _fseeki64$address() {
        return _fseeki64.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int _fseeki64(FILE *_Stream, long long _Offset, int _Origin)
     * }
     */
    public static int _fseeki64(MemorySegment _Stream, long _Offset, int _Origin) {
        var mh$ = _fseeki64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fseeki64", _Stream, _Offset, _Origin);
            }
            return (int) mh$.invokeExact(_Stream, _Offset, _Origin);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_LONG,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ftell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * long ftell(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor ftell$descriptor() {
        return ftell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * long ftell(FILE *_Stream)
     * }
     */
    public static MethodHandle ftell$handle() {
        return ftell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * long ftell(FILE *_Stream)
     * }
     */
    public static MemorySegment ftell$address() {
        return ftell.ADDR;
    }

    /**
     * {@snippet lang = c : * long ftell(FILE *_Stream)
     * }
     */
    public static int ftell(MemorySegment _Stream) {
        var mh$ = ftell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftell", _Stream);
            }
            return (int) mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ftelli64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ftelli64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * long long _ftelli64(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _ftelli64$descriptor() {
        return _ftelli64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * long long _ftelli64(FILE *_Stream)
     * }
     */
    public static MethodHandle _ftelli64$handle() {
        return _ftelli64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * long long _ftelli64(FILE *_Stream)
     * }
     */
    public static MemorySegment _ftelli64$address() {
        return _ftelli64.ADDR;
    }

    /**
     * {@snippet lang = c : * long long _ftelli64(FILE *_Stream)
     * }
     */
    public static long _ftelli64(MemorySegment _Stream) {
        var mh$ = _ftelli64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ftelli64", _Stream);
            }
            return (long) mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fwrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fwrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * unsigned long long fwrite(const void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fwrite$descriptor() {
        return fwrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * unsigned long long fwrite(const void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MethodHandle fwrite$handle() {
        return fwrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * unsigned long long fwrite(const void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MemorySegment fwrite$address() {
        return fwrite.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * unsigned long long fwrite(const void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static long fwrite(MemorySegment _Buffer, long _ElementSize, long _ElementCount, MemorySegment _Stream) {
        var mh$ = fwrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fwrite", _Buffer, _ElementSize, _ElementCount, _Stream);
            }
            return (long) mh$.invokeExact(_Buffer, _ElementSize, _ElementCount, _Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int getc(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor getc$descriptor() {
        return getc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int getc(FILE *_Stream)
     * }
     */
    public static MethodHandle getc$handle() {
        return getc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int getc(FILE *_Stream)
     * }
     */
    public static MemorySegment getc$address() {
        return getc.ADDR;
    }

    /**
     * {@snippet lang = c : * int getc(FILE *_Stream)
     * }
     */
    public static int getc(MemorySegment _Stream) {
        var mh$ = getc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getc", _Stream);
            }
            return (int) mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int getchar()
     * }
     */
    public static FunctionDescriptor getchar$descriptor() {
        return getchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int getchar()
     * }
     */
    public static MethodHandle getchar$handle() {
        return getchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int getchar()
     * }
     */
    public static MemorySegment getchar$address() {
        return getchar.ADDR;
    }

    /**
     * {@snippet lang = c : * int getchar()
     * }
     */
    public static int getchar() {
        var mh$ = getchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getchar");
            }
            return (int) mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _getmaxstdio {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_getmaxstdio");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int _getmaxstdio()
     * }
     */
    public static FunctionDescriptor _getmaxstdio$descriptor() {
        return _getmaxstdio.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int _getmaxstdio()
     * }
     */
    public static MethodHandle _getmaxstdio$handle() {
        return _getmaxstdio.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int _getmaxstdio()
     * }
     */
    public static MemorySegment _getmaxstdio$address() {
        return _getmaxstdio.ADDR;
    }

    /**
     * {@snippet lang = c : * int _getmaxstdio()
     * }
     */
    public static int _getmaxstdio() {
        var mh$ = _getmaxstdio.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_getmaxstdio");
            }
            return (int) mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _getw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_getw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int _getw(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _getw$descriptor() {
        return _getw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int _getw(FILE *_Stream)
     * }
     */
    public static MethodHandle _getw$handle() {
        return _getw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int _getw(FILE *_Stream)
     * }
     */
    public static MemorySegment _getw$address() {
        return _getw.ADDR;
    }

    /**
     * {@snippet lang = c : * int _getw(FILE *_Stream)
     * }
     */
    public static int _getw(MemorySegment _Stream) {
        var mh$ = _getw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_getw", _Stream);
            }
            return (int) mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class perror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("perror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * void perror(const char *_ErrorMessage)
     * }
     */
    public static FunctionDescriptor perror$descriptor() {
        return perror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * void perror(const char *_ErrorMessage)
     * }
     */
    public static MethodHandle perror$handle() {
        return perror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * void perror(const char *_ErrorMessage)
     * }
     */
    public static MemorySegment perror$address() {
        return perror.ADDR;
    }

    /**
     * {@snippet lang = c : * void perror(const char *_ErrorMessage)
     * }
     */
    public static void perror(MemorySegment _ErrorMessage) {
        var mh$ = perror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("perror", _ErrorMessage);
            }
            mh$.invokeExact(_ErrorMessage);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _pclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_pclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int _pclose(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _pclose$descriptor() {
        return _pclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int _pclose(FILE *_Stream)
     * }
     */
    public static MethodHandle _pclose$handle() {
        return _pclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int _pclose(FILE *_Stream)
     * }
     */
    public static MemorySegment _pclose$address() {
        return _pclose.ADDR;
    }

    /**
     * {@snippet lang = c : * int _pclose(FILE *_Stream)
     * }
     */
    public static int _pclose(MemorySegment _Stream) {
        var mh$ = _pclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_pclose", _Stream);
            }
            return (int) mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _popen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_popen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * FILE *_popen(const char *_Command, const char *_Mode)
     * }
     */
    public static FunctionDescriptor _popen$descriptor() {
        return _popen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * FILE *_popen(const char *_Command, const char *_Mode)
     * }
     */
    public static MethodHandle _popen$handle() {
        return _popen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * FILE *_popen(const char *_Command, const char *_Mode)
     * }
     */
    public static MemorySegment _popen$address() {
        return _popen.ADDR;
    }

    /**
     * {@snippet lang = c : * FILE *_popen(const char *_Command, const char *_Mode)
     * }
     */
    public static MemorySegment _popen(MemorySegment _Command, MemorySegment _Mode) {
        var mh$ = _popen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_popen", _Command, _Mode);
            }
            return (MemorySegment) mh$.invokeExact(_Command, _Mode);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("putc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int putc(int _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor putc$descriptor() {
        return putc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int putc(int _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle putc$handle() {
        return putc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int putc(int _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment putc$address() {
        return putc.ADDR;
    }

    /**
     * {@snippet lang = c : * int putc(int _Character, FILE *_Stream)
     * }
     */
    public static int putc(int _Character, MemorySegment _Stream) {
        var mh$ = putc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putc", _Character, _Stream);
            }
            return (int) mh$.invokeExact(_Character, _Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("putchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int putchar(int _Character)
     * }
     */
    public static FunctionDescriptor putchar$descriptor() {
        return putchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int putchar(int _Character)
     * }
     */
    public static MethodHandle putchar$handle() {
        return putchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int putchar(int _Character)
     * }
     */
    public static MemorySegment putchar$address() {
        return putchar.ADDR;
    }

    /**
     * {@snippet lang = c : * int putchar(int _Character)
     * }
     */
    public static int putchar(int _Character) {
        var mh$ = putchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putchar", _Character);
            }
            return (int) mh$.invokeExact(_Character);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class puts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("puts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int puts(const char *_Buffer)
     * }
     */
    public static FunctionDescriptor puts$descriptor() {
        return puts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int puts(const char *_Buffer)
     * }
     */
    public static MethodHandle puts$handle() {
        return puts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int puts(const char *_Buffer)
     * }
     */
    public static MemorySegment puts$address() {
        return puts.ADDR;
    }

    /**
     * {@snippet lang = c : * int puts(const char *_Buffer)
     * }
     */
    public static int puts(MemorySegment _Buffer) {
        var mh$ = puts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("puts", _Buffer);
            }
            return (int) mh$.invokeExact(_Buffer);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _putw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_putw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int _putw(int _Word, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _putw$descriptor() {
        return _putw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int _putw(int _Word, FILE *_Stream)
     * }
     */
    public static MethodHandle _putw$handle() {
        return _putw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int _putw(int _Word, FILE *_Stream)
     * }
     */
    public static MemorySegment _putw$address() {
        return _putw.ADDR;
    }

    /**
     * {@snippet lang = c : * int _putw(int _Word, FILE *_Stream)
     * }
     */
    public static int _putw(int _Word, MemorySegment _Stream) {
        var mh$ = _putw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_putw", _Word, _Stream);
            }
            return (int) mh$.invokeExact(_Word, _Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int remove(const char *_FileName)
     * }
     */
    public static FunctionDescriptor remove$descriptor() {
        return remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int remove(const char *_FileName)
     * }
     */
    public static MethodHandle remove$handle() {
        return remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int remove(const char *_FileName)
     * }
     */
    public static MemorySegment remove$address() {
        return remove.ADDR;
    }

    /**
     * {@snippet lang = c : * int remove(const char *_FileName)
     * }
     */
    public static int remove(MemorySegment _FileName) {
        var mh$ = remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remove", _FileName);
            }
            return (int) mh$.invokeExact(_FileName);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("rename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int rename(const char *_OldFileName, const char *_NewFileName)
     * }
     */
    public static FunctionDescriptor rename$descriptor() {
        return rename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int rename(const char *_OldFileName, const char *_NewFileName)
     * }
     */
    public static MethodHandle rename$handle() {
        return rename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int rename(const char *_OldFileName, const char *_NewFileName)
     * }
     */
    public static MemorySegment rename$address() {
        return rename.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int rename(const char *_OldFileName, const char *_NewFileName)
     * }
     */
    public static int rename(MemorySegment _OldFileName, MemorySegment _NewFileName) {
        var mh$ = rename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rename", _OldFileName, _NewFileName);
            }
            return (int) mh$.invokeExact(_OldFileName, _NewFileName);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _unlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_unlink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int _unlink(const char *_FileName)
     * }
     */
    public static FunctionDescriptor _unlink$descriptor() {
        return _unlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int _unlink(const char *_FileName)
     * }
     */
    public static MethodHandle _unlink$handle() {
        return _unlink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int _unlink(const char *_FileName)
     * }
     */
    public static MemorySegment _unlink$address() {
        return _unlink.ADDR;
    }

    /**
     * {@snippet lang = c : * int _unlink(const char *_FileName)
     * }
     */
    public static int _unlink(MemorySegment _FileName) {
        var mh$ = _unlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_unlink", _FileName);
            }
            return (int) mh$.invokeExact(_FileName);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("unlink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int unlink(const char *_FileName)
     * }
     */
    public static FunctionDescriptor unlink$descriptor() {
        return unlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int unlink(const char *_FileName)
     * }
     */
    public static MethodHandle unlink$handle() {
        return unlink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int unlink(const char *_FileName)
     * }
     */
    public static MemorySegment unlink$address() {
        return unlink.ADDR;
    }

    /**
     * {@snippet lang = c : * int unlink(const char *_FileName)
     * }
     */
    public static int unlink(MemorySegment _FileName) {
        var mh$ = unlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unlink", _FileName);
            }
            return (int) mh$.invokeExact(_FileName);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rewind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("rewind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * void rewind(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor rewind$descriptor() {
        return rewind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * void rewind(FILE *_Stream)
     * }
     */
    public static MethodHandle rewind$handle() {
        return rewind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * void rewind(FILE *_Stream)
     * }
     */
    public static MemorySegment rewind$address() {
        return rewind.ADDR;
    }

    /**
     * {@snippet lang = c : * void rewind(FILE *_Stream)
     * }
     */
    public static void rewind(MemorySegment _Stream) {
        var mh$ = rewind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rewind", _Stream);
            }
            mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _rmtmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_rmtmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int _rmtmp()
     * }
     */
    public static FunctionDescriptor _rmtmp$descriptor() {
        return _rmtmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int _rmtmp()
     * }
     */
    public static MethodHandle _rmtmp$handle() {
        return _rmtmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int _rmtmp()
     * }
     */
    public static MemorySegment _rmtmp$address() {
        return _rmtmp.ADDR;
    }

    /**
     * {@snippet lang = c : * int _rmtmp()
     * }
     */
    public static int _rmtmp() {
        var mh$ = _rmtmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_rmtmp");
            }
            return (int) mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * void setbuf(FILE *_Stream, char *_Buffer)
     * }
     */
    public static FunctionDescriptor setbuf$descriptor() {
        return setbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * void setbuf(FILE *_Stream, char *_Buffer)
     * }
     */
    public static MethodHandle setbuf$handle() {
        return setbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * void setbuf(FILE *_Stream, char *_Buffer)
     * }
     */
    public static MemorySegment setbuf$address() {
        return setbuf.ADDR;
    }

    /**
     * {@snippet lang = c : * void setbuf(FILE *_Stream, char *_Buffer)
     * }
     */
    public static void setbuf(MemorySegment _Stream, MemorySegment _Buffer) {
        var mh$ = setbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setbuf", _Stream, _Buffer);
            }
            mh$.invokeExact(_Stream, _Buffer);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _setmaxstdio {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_setmaxstdio");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int _setmaxstdio(int _Maximum)
     * }
     */
    public static FunctionDescriptor _setmaxstdio$descriptor() {
        return _setmaxstdio.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int _setmaxstdio(int _Maximum)
     * }
     */
    public static MethodHandle _setmaxstdio$handle() {
        return _setmaxstdio.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int _setmaxstdio(int _Maximum)
     * }
     */
    public static MemorySegment _setmaxstdio$address() {
        return _setmaxstdio.ADDR;
    }

    /**
     * {@snippet lang = c : * int _setmaxstdio(int _Maximum)
     * }
     */
    public static int _setmaxstdio(int _Maximum) {
        var mh$ = _setmaxstdio.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_setmaxstdio", _Maximum);
            }
            return (int) mh$.invokeExact(_Maximum);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setvbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_LONG_LONG);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setvbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int setvbuf(FILE *_Stream, char *_Buffer, int _Mode, size_t _Size)
     * }
     */
    public static FunctionDescriptor setvbuf$descriptor() {
        return setvbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int setvbuf(FILE *_Stream, char *_Buffer, int _Mode, size_t _Size)
     * }
     */
    public static MethodHandle setvbuf$handle() {
        return setvbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int setvbuf(FILE *_Stream, char *_Buffer, int _Mode, size_t _Size)
     * }
     */
    public static MemorySegment setvbuf$address() {
        return setvbuf.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int setvbuf(FILE *_Stream, char *_Buffer, int _Mode, size_t _Size)
     * }
     */
    public static int setvbuf(MemorySegment _Stream, MemorySegment _Buffer, int _Mode, long _Size) {
        var mh$ = setvbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setvbuf", _Stream, _Buffer, _Mode, _Size);
            }
            return (int) mh$.invokeExact(_Stream, _Buffer, _Mode, _Size);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _tempnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_tempnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * char *_tempnam(const char *_DirectoryName, const char *_FilePrefix)
     * }
     */
    public static FunctionDescriptor _tempnam$descriptor() {
        return _tempnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * char *_tempnam(const char *_DirectoryName, const char *_FilePrefix)
     * }
     */
    public static MethodHandle _tempnam$handle() {
        return _tempnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * char *_tempnam(const char *_DirectoryName, const char *_FilePrefix)
     * }
     */
    public static MemorySegment _tempnam$address() {
        return _tempnam.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * char *_tempnam(const char *_DirectoryName, const char *_FilePrefix)
     * }
     */
    public static MemorySegment _tempnam(MemorySegment _DirectoryName, MemorySegment _FilePrefix) {
        var mh$ = _tempnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_tempnam", _DirectoryName, _FilePrefix);
            }
            return (MemorySegment) mh$.invokeExact(_DirectoryName, _FilePrefix);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("tmpfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * FILE *tmpfile()
     * }
     */
    public static FunctionDescriptor tmpfile$descriptor() {
        return tmpfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * FILE *tmpfile()
     * }
     */
    public static MethodHandle tmpfile$handle() {
        return tmpfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * FILE *tmpfile()
     * }
     */
    public static MemorySegment tmpfile$address() {
        return tmpfile.ADDR;
    }

    /**
     * {@snippet lang = c : * FILE *tmpfile()
     * }
     */
    public static MemorySegment tmpfile() {
        var mh$ = tmpfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpfile");
            }
            return (MemorySegment) mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("tmpnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * char *tmpnam(char *_Buffer)
     * }
     */
    public static FunctionDescriptor tmpnam$descriptor() {
        return tmpnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * char *tmpnam(char *_Buffer)
     * }
     */
    public static MethodHandle tmpnam$handle() {
        return tmpnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * char *tmpnam(char *_Buffer)
     * }
     */
    public static MemorySegment tmpnam$address() {
        return tmpnam.ADDR;
    }

    /**
     * {@snippet lang = c : * char *tmpnam(char *_Buffer)
     * }
     */
    public static MemorySegment tmpnam(MemorySegment _Buffer) {
        var mh$ = tmpnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpnam", _Buffer);
            }
            return (MemorySegment) mh$.invokeExact(_Buffer);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ungetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ungetc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int ungetc(int _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor ungetc$descriptor() {
        return ungetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int ungetc(int _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle ungetc$handle() {
        return ungetc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int ungetc(int _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment ungetc$address() {
        return ungetc.ADDR;
    }

    /**
     * {@snippet lang = c : * int ungetc(int _Character, FILE *_Stream)
     * }
     */
    public static int ungetc(int _Character, MemorySegment _Stream) {
        var mh$ = ungetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ungetc", _Character, _Stream);
            }
            return (int) mh$.invokeExact(_Character, _Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lock_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_lock_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * void _lock_file(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _lock_file$descriptor() {
        return _lock_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * void _lock_file(FILE *_Stream)
     * }
     */
    public static MethodHandle _lock_file$handle() {
        return _lock_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * void _lock_file(FILE *_Stream)
     * }
     */
    public static MemorySegment _lock_file$address() {
        return _lock_file.ADDR;
    }

    /**
     * {@snippet lang = c : * void _lock_file(FILE *_Stream)
     * }
     */
    public static void _lock_file(MemorySegment _Stream) {
        var mh$ = _lock_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lock_file", _Stream);
            }
            mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _unlock_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_unlock_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * void _unlock_file(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _unlock_file$descriptor() {
        return _unlock_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * void _unlock_file(FILE *_Stream)
     * }
     */
    public static MethodHandle _unlock_file$handle() {
        return _unlock_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * void _unlock_file(FILE *_Stream)
     * }
     */
    public static MemorySegment _unlock_file$address() {
        return _unlock_file.ADDR;
    }

    /**
     * {@snippet lang = c : * void _unlock_file(FILE *_Stream)
     * }
     */
    public static void _unlock_file(MemorySegment _Stream) {
        var mh$ = _unlock_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_unlock_file", _Stream);
            }
            mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fclose_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fclose_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int _fclose_nolock(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fclose_nolock$descriptor() {
        return _fclose_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int _fclose_nolock(FILE *_Stream)
     * }
     */
    public static MethodHandle _fclose_nolock$handle() {
        return _fclose_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int _fclose_nolock(FILE *_Stream)
     * }
     */
    public static MemorySegment _fclose_nolock$address() {
        return _fclose_nolock.ADDR;
    }

    /**
     * {@snippet lang = c : * int _fclose_nolock(FILE *_Stream)
     * }
     */
    public static int _fclose_nolock(MemorySegment _Stream) {
        var mh$ = _fclose_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fclose_nolock", _Stream);
            }
            return (int) mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fflush_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fflush_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int _fflush_nolock(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fflush_nolock$descriptor() {
        return _fflush_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int _fflush_nolock(FILE *_Stream)
     * }
     */
    public static MethodHandle _fflush_nolock$handle() {
        return _fflush_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int _fflush_nolock(FILE *_Stream)
     * }
     */
    public static MemorySegment _fflush_nolock$address() {
        return _fflush_nolock.ADDR;
    }

    /**
     * {@snippet lang = c : * int _fflush_nolock(FILE *_Stream)
     * }
     */
    public static int _fflush_nolock(MemorySegment _Stream) {
        var mh$ = _fflush_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fflush_nolock", _Stream);
            }
            return (int) mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fgetc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fgetc_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int _fgetc_nolock(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fgetc_nolock$descriptor() {
        return _fgetc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int _fgetc_nolock(FILE *_Stream)
     * }
     */
    public static MethodHandle _fgetc_nolock$handle() {
        return _fgetc_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int _fgetc_nolock(FILE *_Stream)
     * }
     */
    public static MemorySegment _fgetc_nolock$address() {
        return _fgetc_nolock.ADDR;
    }

    /**
     * {@snippet lang = c : * int _fgetc_nolock(FILE *_Stream)
     * }
     */
    public static int _fgetc_nolock(MemorySegment _Stream) {
        var mh$ = _fgetc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fgetc_nolock", _Stream);
            }
            return (int) mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fputc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fputc_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int _fputc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fputc_nolock$descriptor() {
        return _fputc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int _fputc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle _fputc_nolock$handle() {
        return _fputc_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int _fputc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment _fputc_nolock$address() {
        return _fputc_nolock.ADDR;
    }

    /**
     * {@snippet lang = c : * int _fputc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static int _fputc_nolock(int _Character, MemorySegment _Stream) {
        var mh$ = _fputc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fputc_nolock", _Character, _Stream);
            }
            return (int) mh$.invokeExact(_Character, _Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fread_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fread_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * size_t _fread_nolock(void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fread_nolock$descriptor() {
        return _fread_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * size_t _fread_nolock(void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MethodHandle _fread_nolock$handle() {
        return _fread_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * size_t _fread_nolock(void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MemorySegment _fread_nolock$address() {
        return _fread_nolock.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * size_t _fread_nolock(void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static long _fread_nolock(MemorySegment _Buffer, long _ElementSize, long _ElementCount,
            MemorySegment _Stream) {
        var mh$ = _fread_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fread_nolock", _Buffer, _ElementSize, _ElementCount, _Stream);
            }
            return (long) mh$.invokeExact(_Buffer, _ElementSize, _ElementCount, _Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fread_nolock_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fread_nolock_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * size_t _fread_nolock_s(void *_Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fread_nolock_s$descriptor() {
        return _fread_nolock_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * size_t _fread_nolock_s(void *_Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MethodHandle _fread_nolock_s$handle() {
        return _fread_nolock_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * size_t _fread_nolock_s(void *_Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MemorySegment _fread_nolock_s$address() {
        return _fread_nolock_s.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * size_t _fread_nolock_s(void *_Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static long _fread_nolock_s(MemorySegment _Buffer, long _BufferSize, long _ElementSize, long _ElementCount,
            MemorySegment _Stream) {
        var mh$ = _fread_nolock_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fread_nolock_s", _Buffer, _BufferSize, _ElementSize, _ElementCount, _Stream);
            }
            return (long) mh$.invokeExact(_Buffer, _BufferSize, _ElementSize, _ElementCount, _Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fseek_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_LONG,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fseek_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int _fseek_nolock(FILE *_Stream, long _Offset, int _Origin)
     * }
     */
    public static FunctionDescriptor _fseek_nolock$descriptor() {
        return _fseek_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int _fseek_nolock(FILE *_Stream, long _Offset, int _Origin)
     * }
     */
    public static MethodHandle _fseek_nolock$handle() {
        return _fseek_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int _fseek_nolock(FILE *_Stream, long _Offset, int _Origin)
     * }
     */
    public static MemorySegment _fseek_nolock$address() {
        return _fseek_nolock.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int _fseek_nolock(FILE *_Stream, long _Offset, int _Origin)
     * }
     */
    public static int _fseek_nolock(MemorySegment _Stream, int _Offset, int _Origin) {
        var mh$ = _fseek_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fseek_nolock", _Stream, _Offset, _Origin);
            }
            return (int) mh$.invokeExact(_Stream, _Offset, _Origin);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fseeki64_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fseeki64_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int _fseeki64_nolock(FILE *_Stream, long long _Offset, int _Origin)
     * }
     */
    public static FunctionDescriptor _fseeki64_nolock$descriptor() {
        return _fseeki64_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int _fseeki64_nolock(FILE *_Stream, long long _Offset, int _Origin)
     * }
     */
    public static MethodHandle _fseeki64_nolock$handle() {
        return _fseeki64_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int _fseeki64_nolock(FILE *_Stream, long long _Offset, int _Origin)
     * }
     */
    public static MemorySegment _fseeki64_nolock$address() {
        return _fseeki64_nolock.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int _fseeki64_nolock(FILE *_Stream, long long _Offset, int _Origin)
     * }
     */
    public static int _fseeki64_nolock(MemorySegment _Stream, long _Offset, int _Origin) {
        var mh$ = _fseeki64_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fseeki64_nolock", _Stream, _Offset, _Origin);
            }
            return (int) mh$.invokeExact(_Stream, _Offset, _Origin);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ftell_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_LONG,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ftell_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * long _ftell_nolock(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _ftell_nolock$descriptor() {
        return _ftell_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * long _ftell_nolock(FILE *_Stream)
     * }
     */
    public static MethodHandle _ftell_nolock$handle() {
        return _ftell_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * long _ftell_nolock(FILE *_Stream)
     * }
     */
    public static MemorySegment _ftell_nolock$address() {
        return _ftell_nolock.ADDR;
    }

    /**
     * {@snippet lang = c : * long _ftell_nolock(FILE *_Stream)
     * }
     */
    public static int _ftell_nolock(MemorySegment _Stream) {
        var mh$ = _ftell_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ftell_nolock", _Stream);
            }
            return (int) mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ftelli64_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ftelli64_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * long long _ftelli64_nolock(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _ftelli64_nolock$descriptor() {
        return _ftelli64_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * long long _ftelli64_nolock(FILE *_Stream)
     * }
     */
    public static MethodHandle _ftelli64_nolock$handle() {
        return _ftelli64_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * long long _ftelli64_nolock(FILE *_Stream)
     * }
     */
    public static MemorySegment _ftelli64_nolock$address() {
        return _ftelli64_nolock.ADDR;
    }

    /**
     * {@snippet lang = c : * long long _ftelli64_nolock(FILE *_Stream)
     * }
     */
    public static long _ftelli64_nolock(MemorySegment _Stream) {
        var mh$ = _ftelli64_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ftelli64_nolock", _Stream);
            }
            return (long) mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fwrite_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fwrite_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * size_t _fwrite_nolock(const void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fwrite_nolock$descriptor() {
        return _fwrite_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * size_t _fwrite_nolock(const void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MethodHandle _fwrite_nolock$handle() {
        return _fwrite_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * size_t _fwrite_nolock(const void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MemorySegment _fwrite_nolock$address() {
        return _fwrite_nolock.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * size_t _fwrite_nolock(const void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static long _fwrite_nolock(MemorySegment _Buffer, long _ElementSize, long _ElementCount,
            MemorySegment _Stream) {
        var mh$ = _fwrite_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fwrite_nolock", _Buffer, _ElementSize, _ElementCount, _Stream);
            }
            return (long) mh$.invokeExact(_Buffer, _ElementSize, _ElementCount, _Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _getc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_getc_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int _getc_nolock(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _getc_nolock$descriptor() {
        return _getc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int _getc_nolock(FILE *_Stream)
     * }
     */
    public static MethodHandle _getc_nolock$handle() {
        return _getc_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int _getc_nolock(FILE *_Stream)
     * }
     */
    public static MemorySegment _getc_nolock$address() {
        return _getc_nolock.ADDR;
    }

    /**
     * {@snippet lang = c : * int _getc_nolock(FILE *_Stream)
     * }
     */
    public static int _getc_nolock(MemorySegment _Stream) {
        var mh$ = _getc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_getc_nolock", _Stream);
            }
            return (int) mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _putc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_putc_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int _putc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _putc_nolock$descriptor() {
        return _putc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int _putc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle _putc_nolock$handle() {
        return _putc_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int _putc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment _putc_nolock$address() {
        return _putc_nolock.ADDR;
    }

    /**
     * {@snippet lang = c : * int _putc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static int _putc_nolock(int _Character, MemorySegment _Stream) {
        var mh$ = _putc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_putc_nolock", _Character, _Stream);
            }
            return (int) mh$.invokeExact(_Character, _Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ungetc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ungetc_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int _ungetc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _ungetc_nolock$descriptor() {
        return _ungetc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int _ungetc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle _ungetc_nolock$handle() {
        return _ungetc_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int _ungetc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment _ungetc_nolock$address() {
        return _ungetc_nolock.ADDR;
    }

    /**
     * {@snippet lang = c : * int _ungetc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static int _ungetc_nolock(int _Character, MemorySegment _Stream) {
        var mh$ = _ungetc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ungetc_nolock", _Character, _Stream);
            }
            return (int) mh$.invokeExact(_Character, _Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p__commode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__p__commode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int *__p__commode()
     * }
     */
    public static FunctionDescriptor __p__commode$descriptor() {
        return __p__commode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int *__p__commode()
     * }
     */
    public static MethodHandle __p__commode$handle() {
        return __p__commode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int *__p__commode()
     * }
     */
    public static MemorySegment __p__commode$address() {
        return __p__commode.ADDR;
    }

    /**
     * {@snippet lang = c : * int *__p__commode()
     * }
     */
    public static MemorySegment __p__commode() {
        var mh$ = __p__commode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p__commode");
            }
            return (MemorySegment) mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vfprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__stdio_common_vfprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int __stdio_common_vfprintf(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vfprintf$descriptor() {
        return __stdio_common_vfprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int __stdio_common_vfprintf(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vfprintf$handle() {
        return __stdio_common_vfprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int __stdio_common_vfprintf(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vfprintf$address() {
        return __stdio_common_vfprintf.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int __stdio_common_vfprintf(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vfprintf(long _Options, MemorySegment _Stream, MemorySegment _Format,
            MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vfprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vfprintf", _Options, _Stream, _Format, _Locale, _ArgList);
            }
            return (int) mh$.invokeExact(_Options, _Stream, _Format, _Locale, _ArgList);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vfprintf_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__stdio_common_vfprintf_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int __stdio_common_vfprintf_s(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vfprintf_s$descriptor() {
        return __stdio_common_vfprintf_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int __stdio_common_vfprintf_s(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vfprintf_s$handle() {
        return __stdio_common_vfprintf_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int __stdio_common_vfprintf_s(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vfprintf_s$address() {
        return __stdio_common_vfprintf_s.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int __stdio_common_vfprintf_s(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vfprintf_s(long _Options, MemorySegment _Stream, MemorySegment _Format,
            MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vfprintf_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vfprintf_s", _Options, _Stream, _Format, _Locale, _ArgList);
            }
            return (int) mh$.invokeExact(_Options, _Stream, _Format, _Locale, _ArgList);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vfprintf_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__stdio_common_vfprintf_p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int __stdio_common_vfprintf_p(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vfprintf_p$descriptor() {
        return __stdio_common_vfprintf_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int __stdio_common_vfprintf_p(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vfprintf_p$handle() {
        return __stdio_common_vfprintf_p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int __stdio_common_vfprintf_p(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vfprintf_p$address() {
        return __stdio_common_vfprintf_p.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int __stdio_common_vfprintf_p(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vfprintf_p(long _Options, MemorySegment _Stream, MemorySegment _Format,
            MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vfprintf_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vfprintf_p", _Options, _Stream, _Format, _Locale, _ArgList);
            }
            return (int) mh$.invokeExact(_Options, _Stream, _Format, _Locale, _ArgList);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_printf_count_output {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_set_printf_count_output");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int _set_printf_count_output(int _Value)
     * }
     */
    public static FunctionDescriptor _set_printf_count_output$descriptor() {
        return _set_printf_count_output.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int _set_printf_count_output(int _Value)
     * }
     */
    public static MethodHandle _set_printf_count_output$handle() {
        return _set_printf_count_output.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int _set_printf_count_output(int _Value)
     * }
     */
    public static MemorySegment _set_printf_count_output$address() {
        return _set_printf_count_output.ADDR;
    }

    /**
     * {@snippet lang = c : * int _set_printf_count_output(int _Value)
     * }
     */
    public static int _set_printf_count_output(int _Value) {
        var mh$ = _set_printf_count_output.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_printf_count_output", _Value);
            }
            return (int) mh$.invokeExact(_Value);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_printf_count_output {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_get_printf_count_output");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int _get_printf_count_output()
     * }
     */
    public static FunctionDescriptor _get_printf_count_output$descriptor() {
        return _get_printf_count_output.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int _get_printf_count_output()
     * }
     */
    public static MethodHandle _get_printf_count_output$handle() {
        return _get_printf_count_output.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int _get_printf_count_output()
     * }
     */
    public static MemorySegment _get_printf_count_output$address() {
        return _get_printf_count_output.ADDR;
    }

    /**
     * {@snippet lang = c : * int _get_printf_count_output()
     * }
     */
    public static int _get_printf_count_output() {
        var mh$ = _get_printf_count_output.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_printf_count_output");
            }
            return (int) mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vfscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__stdio_common_vfscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int __stdio_common_vfscanf(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _Arglist)
     * }
     */
    public static FunctionDescriptor __stdio_common_vfscanf$descriptor() {
        return __stdio_common_vfscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int __stdio_common_vfscanf(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _Arglist)
     * }
     */
    public static MethodHandle __stdio_common_vfscanf$handle() {
        return __stdio_common_vfscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int __stdio_common_vfscanf(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _Arglist)
     * }
     */
    public static MemorySegment __stdio_common_vfscanf$address() {
        return __stdio_common_vfscanf.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int __stdio_common_vfscanf(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _Arglist)
     * }
     */
    public static int __stdio_common_vfscanf(long _Options, MemorySegment _Stream, MemorySegment _Format,
            MemorySegment _Locale, MemorySegment _Arglist) {
        var mh$ = __stdio_common_vfscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vfscanf", _Options, _Stream, _Format, _Locale, _Arglist);
            }
            return (int) mh$.invokeExact(_Options, _Stream, _Format, _Locale, _Arglist);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vsprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__stdio_common_vsprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int __stdio_common_vsprintf(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vsprintf$descriptor() {
        return __stdio_common_vsprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int __stdio_common_vsprintf(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vsprintf$handle() {
        return __stdio_common_vsprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int __stdio_common_vsprintf(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vsprintf$address() {
        return __stdio_common_vsprintf.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int __stdio_common_vsprintf(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vsprintf(long _Options, MemorySegment _Buffer, long _BufferCount,
            MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vsprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vsprintf", _Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
            }
            return (int) mh$.invokeExact(_Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vsprintf_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__stdio_common_vsprintf_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int __stdio_common_vsprintf_s(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vsprintf_s$descriptor() {
        return __stdio_common_vsprintf_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int __stdio_common_vsprintf_s(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vsprintf_s$handle() {
        return __stdio_common_vsprintf_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int __stdio_common_vsprintf_s(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vsprintf_s$address() {
        return __stdio_common_vsprintf_s.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int __stdio_common_vsprintf_s(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vsprintf_s(long _Options, MemorySegment _Buffer, long _BufferCount,
            MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vsprintf_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vsprintf_s", _Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
            }
            return (int) mh$.invokeExact(_Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vsnprintf_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__stdio_common_vsnprintf_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int __stdio_common_vsnprintf_s(unsigned long long _Options, char *_Buffer, size_t _BufferCount, size_t _MaxCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vsnprintf_s$descriptor() {
        return __stdio_common_vsnprintf_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int __stdio_common_vsnprintf_s(unsigned long long _Options, char *_Buffer, size_t _BufferCount, size_t _MaxCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vsnprintf_s$handle() {
        return __stdio_common_vsnprintf_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int __stdio_common_vsnprintf_s(unsigned long long _Options, char *_Buffer, size_t _BufferCount, size_t _MaxCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vsnprintf_s$address() {
        return __stdio_common_vsnprintf_s.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int __stdio_common_vsnprintf_s(unsigned long long _Options, char *_Buffer, size_t _BufferCount, size_t _MaxCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vsnprintf_s(long _Options, MemorySegment _Buffer, long _BufferCount,
            long _MaxCount, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vsnprintf_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vsnprintf_s", _Options, _Buffer, _BufferCount, _MaxCount, _Format,
                        _Locale, _ArgList);
            }
            return (int) mh$.invokeExact(_Options, _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vsprintf_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__stdio_common_vsprintf_p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int __stdio_common_vsprintf_p(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vsprintf_p$descriptor() {
        return __stdio_common_vsprintf_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int __stdio_common_vsprintf_p(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vsprintf_p$handle() {
        return __stdio_common_vsprintf_p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int __stdio_common_vsprintf_p(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vsprintf_p$address() {
        return __stdio_common_vsprintf_p.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int __stdio_common_vsprintf_p(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vsprintf_p(long _Options, MemorySegment _Buffer, long _BufferCount,
            MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vsprintf_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vsprintf_p", _Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
            }
            return (int) mh$.invokeExact(_Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vsscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__stdio_common_vsscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int __stdio_common_vsscanf(unsigned long long _Options, const char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vsscanf$descriptor() {
        return __stdio_common_vsscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int __stdio_common_vsscanf(unsigned long long _Options, const char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vsscanf$handle() {
        return __stdio_common_vsscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int __stdio_common_vsscanf(unsigned long long _Options, const char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vsscanf$address() {
        return __stdio_common_vsscanf.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int __stdio_common_vsscanf(unsigned long long _Options, const char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vsscanf(long _Options, MemorySegment _Buffer, long _BufferCount,
            MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vsscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vsscanf", _Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
            }
            return (int) mh$.invokeExact(_Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tempnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("tempnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * char *tempnam(const char *_Directory, const char *_FilePrefix)
     * }
     */
    public static FunctionDescriptor tempnam$descriptor() {
        return tempnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * char *tempnam(const char *_Directory, const char *_FilePrefix)
     * }
     */
    public static MethodHandle tempnam$handle() {
        return tempnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * char *tempnam(const char *_Directory, const char *_FilePrefix)
     * }
     */
    public static MemorySegment tempnam$address() {
        return tempnam.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * char *tempnam(const char *_Directory, const char *_FilePrefix)
     * }
     */
    public static MemorySegment tempnam(MemorySegment _Directory, MemorySegment _FilePrefix) {
        var mh$ = tempnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tempnam", _Directory, _FilePrefix);
            }
            return (MemorySegment) mh$.invokeExact(_Directory, _FilePrefix);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcloseall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fcloseall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int fcloseall()
     * }
     */
    public static FunctionDescriptor fcloseall$descriptor() {
        return fcloseall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int fcloseall()
     * }
     */
    public static MethodHandle fcloseall$handle() {
        return fcloseall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int fcloseall()
     * }
     */
    public static MemorySegment fcloseall$address() {
        return fcloseall.ADDR;
    }

    /**
     * {@snippet lang = c : * int fcloseall()
     * }
     */
    public static int fcloseall() {
        var mh$ = fcloseall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcloseall");
            }
            return (int) mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fdopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * FILE *fdopen(int _FileHandle, const char *_Format)
     * }
     */
    public static FunctionDescriptor fdopen$descriptor() {
        return fdopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * FILE *fdopen(int _FileHandle, const char *_Format)
     * }
     */
    public static MethodHandle fdopen$handle() {
        return fdopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * FILE *fdopen(int _FileHandle, const char *_Format)
     * }
     */
    public static MemorySegment fdopen$address() {
        return fdopen.ADDR;
    }

    /**
     * {@snippet lang = c : * FILE *fdopen(int _FileHandle, const char *_Format)
     * }
     */
    public static MemorySegment fdopen(int _FileHandle, MemorySegment _Format) {
        var mh$ = fdopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdopen", _FileHandle, _Format);
            }
            return (MemorySegment) mh$.invokeExact(_FileHandle, _Format);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fgetchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int fgetchar()
     * }
     */
    public static FunctionDescriptor fgetchar$descriptor() {
        return fgetchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int fgetchar()
     * }
     */
    public static MethodHandle fgetchar$handle() {
        return fgetchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int fgetchar()
     * }
     */
    public static MemorySegment fgetchar$address() {
        return fgetchar.ADDR;
    }

    /**
     * {@snippet lang = c : * int fgetchar()
     * }
     */
    public static int fgetchar() {
        var mh$ = fgetchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetchar");
            }
            return (int) mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fileno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fileno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int fileno(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fileno$descriptor() {
        return fileno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int fileno(FILE *_Stream)
     * }
     */
    public static MethodHandle fileno$handle() {
        return fileno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int fileno(FILE *_Stream)
     * }
     */
    public static MemorySegment fileno$address() {
        return fileno.ADDR;
    }

    /**
     * {@snippet lang = c : * int fileno(FILE *_Stream)
     * }
     */
    public static int fileno(MemorySegment _Stream) {
        var mh$ = fileno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fileno", _Stream);
            }
            return (int) mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flushall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flushall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int flushall()
     * }
     */
    public static FunctionDescriptor flushall$descriptor() {
        return flushall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int flushall()
     * }
     */
    public static MethodHandle flushall$handle() {
        return flushall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int flushall()
     * }
     */
    public static MemorySegment flushall$address() {
        return flushall.ADDR;
    }

    /**
     * {@snippet lang = c : * int flushall()
     * }
     */
    public static int flushall() {
        var mh$ = flushall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flushall");
            }
            return (int) mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fputchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int fputchar(int _Ch)
     * }
     */
    public static FunctionDescriptor fputchar$descriptor() {
        return fputchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int fputchar(int _Ch)
     * }
     */
    public static MethodHandle fputchar$handle() {
        return fputchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int fputchar(int _Ch)
     * }
     */
    public static MemorySegment fputchar$address() {
        return fputchar.ADDR;
    }

    /**
     * {@snippet lang = c : * int fputchar(int _Ch)
     * }
     */
    public static int fputchar(int _Ch) {
        var mh$ = fputchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputchar", _Ch);
            }
            return (int) mh$.invokeExact(_Ch);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int getw(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor getw$descriptor() {
        return getw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int getw(FILE *_Stream)
     * }
     */
    public static MethodHandle getw$handle() {
        return getw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int getw(FILE *_Stream)
     * }
     */
    public static MemorySegment getw$address() {
        return getw.ADDR;
    }

    /**
     * {@snippet lang = c : * int getw(FILE *_Stream)
     * }
     */
    public static int getw(MemorySegment _Stream) {
        var mh$ = getw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getw", _Stream);
            }
            return (int) mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("putw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int putw(int _Ch, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor putw$descriptor() {
        return putw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int putw(int _Ch, FILE *_Stream)
     * }
     */
    public static MethodHandle putw$handle() {
        return putw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int putw(int _Ch, FILE *_Stream)
     * }
     */
    public static MemorySegment putw$address() {
        return putw.ADDR;
    }

    /**
     * {@snippet lang = c : * int putw(int _Ch, FILE *_Stream)
     * }
     */
    public static int putw(int _Ch, MemorySegment _Stream) {
        var mh$ = putw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putw", _Ch, _Stream);
            }
            return (int) mh$.invokeExact(_Ch, _Stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmtmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("rmtmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int rmtmp()
     * }
     */
    public static FunctionDescriptor rmtmp$descriptor() {
        return rmtmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int rmtmp()
     * }
     */
    public static MethodHandle rmtmp$handle() {
        return rmtmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int rmtmp()
     * }
     */
    public static MemorySegment rmtmp$address() {
        return rmtmp.ADDR;
    }

    /**
     * {@snippet lang = c : * int rmtmp()
     * }
     */
    public static int rmtmp() {
        var mh$ = rmtmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmtmp");
            }
            return (int) mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * {@snippet lang = c : * typedef double max_align_t
     * }
     */
    public static final OfDouble max_align_t = opusfile_h.C_DOUBLE;
    /**
     * {@snippet lang = c : * typedef signed char int8_t
     * }
     */
    public static final OfByte int8_t = opusfile_h.C_CHAR;
    /**
     * {@snippet lang = c : * typedef short int16_t
     * }
     */
    public static final OfShort int16_t = opusfile_h.C_SHORT;
    /**
     * {@snippet lang = c : * typedef int int32_t
     * }
     */
    public static final OfInt int32_t = opusfile_h.C_INT;
    /**
     * {@snippet lang = c : * typedef long long int64_t
     * }
     */
    public static final OfLong int64_t = opusfile_h.C_LONG_LONG;
    /**
     * {@snippet lang = c : * typedef unsigned char uint8_t
     * }
     */
    public static final OfByte uint8_t = opusfile_h.C_CHAR;
    /**
     * {@snippet lang = c : * typedef unsigned short uint16_t
     * }
     */
    public static final OfShort uint16_t = opusfile_h.C_SHORT;
    /**
     * {@snippet lang = c : * typedef unsigned int uint32_t
     * }
     */
    public static final OfInt uint32_t = opusfile_h.C_INT;
    /**
     * {@snippet lang = c : * typedef unsigned long long uint64_t
     * }
     */
    public static final OfLong uint64_t = opusfile_h.C_LONG_LONG;
    /**
     * {@snippet lang = c : * typedef signed char int_least8_t
     * }
     */
    public static final OfByte int_least8_t = opusfile_h.C_CHAR;
    /**
     * {@snippet lang = c : * typedef short int_least16_t
     * }
     */
    public static final OfShort int_least16_t = opusfile_h.C_SHORT;
    /**
     * {@snippet lang = c : * typedef int int_least32_t
     * }
     */
    public static final OfInt int_least32_t = opusfile_h.C_INT;
    /**
     * {@snippet lang = c : * typedef long long int_least64_t
     * }
     */
    public static final OfLong int_least64_t = opusfile_h.C_LONG_LONG;
    /**
     * {@snippet lang = c : * typedef unsigned char uint_least8_t
     * }
     */
    public static final OfByte uint_least8_t = opusfile_h.C_CHAR;
    /**
     * {@snippet lang = c : * typedef unsigned short uint_least16_t
     * }
     */
    public static final OfShort uint_least16_t = opusfile_h.C_SHORT;
    /**
     * {@snippet lang = c : * typedef unsigned int uint_least32_t
     * }
     */
    public static final OfInt uint_least32_t = opusfile_h.C_INT;
    /**
     * {@snippet lang = c : * typedef unsigned long long uint_least64_t
     * }
     */
    public static final OfLong uint_least64_t = opusfile_h.C_LONG_LONG;
    /**
     * {@snippet lang = c : * typedef signed char int_fast8_t
     * }
     */
    public static final OfByte int_fast8_t = opusfile_h.C_CHAR;
    /**
     * {@snippet lang = c : * typedef int int_fast16_t
     * }
     */
    public static final OfInt int_fast16_t = opusfile_h.C_INT;
    /**
     * {@snippet lang = c : * typedef int int_fast32_t
     * }
     */
    public static final OfInt int_fast32_t = opusfile_h.C_INT;
    /**
     * {@snippet lang = c : * typedef long long int_fast64_t
     * }
     */
    public static final OfLong int_fast64_t = opusfile_h.C_LONG_LONG;
    /**
     * {@snippet lang = c : * typedef unsigned char uint_fast8_t
     * }
     */
    public static final OfByte uint_fast8_t = opusfile_h.C_CHAR;
    /**
     * {@snippet lang = c : * typedef unsigned int uint_fast16_t
     * }
     */
    public static final OfInt uint_fast16_t = opusfile_h.C_INT;
    /**
     * {@snippet lang = c : * typedef unsigned int uint_fast32_t
     * }
     */
    public static final OfInt uint_fast32_t = opusfile_h.C_INT;
    /**
     * {@snippet lang = c : * typedef unsigned long long uint_fast64_t
     * }
     */
    public static final OfLong uint_fast64_t = opusfile_h.C_LONG_LONG;
    /**
     * {@snippet lang = c : * typedef long long intmax_t
     * }
     */
    public static final OfLong intmax_t = opusfile_h.C_LONG_LONG;
    /**
     * {@snippet lang = c : * typedef unsigned long long uintmax_t
     * }
     */
    public static final OfLong uintmax_t = opusfile_h.C_LONG_LONG;
    /**
     * {@snippet lang = c : * typedef int16_t ogg_int16_t
     * }
     */
    public static final OfShort ogg_int16_t = opusfile_h.C_SHORT;
    /**
     * {@snippet lang = c : * typedef uint16_t ogg_uint16_t
     * }
     */
    public static final OfShort ogg_uint16_t = opusfile_h.C_SHORT;
    /**
     * {@snippet lang = c : * typedef int32_t ogg_int32_t
     * }
     */
    public static final OfInt ogg_int32_t = opusfile_h.C_INT;
    /**
     * {@snippet lang = c : * typedef uint32_t ogg_uint32_t
     * }
     */
    public static final OfInt ogg_uint32_t = opusfile_h.C_INT;
    /**
     * {@snippet lang = c : * typedef int64_t ogg_int64_t
     * }
     */
    public static final OfLong ogg_int64_t = opusfile_h.C_LONG_LONG;
    /**
     * {@snippet lang = c : * typedef uint64_t ogg_uint64_t
     * }
     */
    public static final OfLong ogg_uint64_t = opusfile_h.C_LONG_LONG;

    private static class oggpack_writeinit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("oggpack_writeinit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * extern void oggpack_writeinit(oggpack_buffer *b)
     * }
     */
    public static FunctionDescriptor oggpack_writeinit$descriptor() {
        return oggpack_writeinit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * extern void oggpack_writeinit(oggpack_buffer *b)
     * }
     */
    public static MethodHandle oggpack_writeinit$handle() {
        return oggpack_writeinit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * extern void oggpack_writeinit(oggpack_buffer *b)
     * }
     */
    public static MemorySegment oggpack_writeinit$address() {
        return oggpack_writeinit.ADDR;
    }

    /**
     * {@snippet lang = c : * extern void oggpack_writeinit(oggpack_buffer *b)
     * }
     */
    public static void oggpack_writeinit(MemorySegment b) {
        var mh$ = oggpack_writeinit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("oggpack_writeinit", b);
            }
            mh$.invokeExact(b);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class oggpack_writecheck {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("oggpack_writecheck");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * extern int oggpack_writecheck(oggpack_buffer *b)
     * }
     */
    public static FunctionDescriptor oggpack_writecheck$descriptor() {
        return oggpack_writecheck.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * extern int oggpack_writecheck(oggpack_buffer *b)
     * }
     */
    public static MethodHandle oggpack_writecheck$handle() {
        return oggpack_writecheck.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * extern int oggpack_writecheck(oggpack_buffer *b)
     * }
     */
    public static MemorySegment oggpack_writecheck$address() {
        return oggpack_writecheck.ADDR;
    }

    /**
     * {@snippet lang = c : * extern int oggpack_writecheck(oggpack_buffer *b)
     * }
     */
    public static int oggpack_writecheck(MemorySegment b) {
        var mh$ = oggpack_writecheck.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("oggpack_writecheck", b);
            }
            return (int) mh$.invokeExact(b);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class oggpack_writetrunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER,
                opusfile_h.C_LONG);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("oggpack_writetrunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * extern void oggpack_writetrunc(oggpack_buffer *b, long bits)
     * }
     */
    public static FunctionDescriptor oggpack_writetrunc$descriptor() {
        return oggpack_writetrunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * extern void oggpack_writetrunc(oggpack_buffer *b, long bits)
     * }
     */
    public static MethodHandle oggpack_writetrunc$handle() {
        return oggpack_writetrunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * extern void oggpack_writetrunc(oggpack_buffer *b, long bits)
     * }
     */
    public static MemorySegment oggpack_writetrunc$address() {
        return oggpack_writetrunc.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * extern void oggpack_writetrunc(oggpack_buffer *b, long bits)
     * }
     */
    public static void oggpack_writetrunc(MemorySegment b, int bits) {
        var mh$ = oggpack_writetrunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("oggpack_writetrunc", b, bits);
            }
            mh$.invokeExact(b, bits);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class oggpack_writealign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("oggpack_writealign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * extern void oggpack_writealign(oggpack_buffer *b)
     * }
     */
    public static FunctionDescriptor oggpack_writealign$descriptor() {
        return oggpack_writealign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * extern void oggpack_writealign(oggpack_buffer *b)
     * }
     */
    public static MethodHandle oggpack_writealign$handle() {
        return oggpack_writealign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * extern void oggpack_writealign(oggpack_buffer *b)
     * }
     */
    public static MemorySegment oggpack_writealign$address() {
        return oggpack_writealign.ADDR;
    }

    /**
     * {@snippet lang = c : * extern void oggpack_writealign(oggpack_buffer *b)
     * }
     */
    public static void oggpack_writealign(MemorySegment b) {
        var mh$ = oggpack_writealign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("oggpack_writealign", b);
            }
            mh$.invokeExact(b);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class oggpack_writecopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_LONG);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("oggpack_writecopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * extern void oggpack_writecopy(oggpack_buffer *b, void *source, long bits)
     * }
     */
    public static FunctionDescriptor oggpack_writecopy$descriptor() {
        return oggpack_writecopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * extern void oggpack_writecopy(oggpack_buffer *b, void *source, long bits)
     * }
     */
    public static MethodHandle oggpack_writecopy$handle() {
        return oggpack_writecopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * extern void oggpack_writecopy(oggpack_buffer *b, void *source, long bits)
     * }
     */
    public static MemorySegment oggpack_writecopy$address() {
        return oggpack_writecopy.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * extern void oggpack_writecopy(oggpack_buffer *b, void *source, long bits)
     * }
     */
    public static void oggpack_writecopy(MemorySegment b, MemorySegment source, int bits) {
        var mh$ = oggpack_writecopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("oggpack_writecopy", b, source, bits);
            }
            mh$.invokeExact(b, source, bits);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class oggpack_reset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("oggpack_reset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * extern void oggpack_reset(oggpack_buffer *b)
     * }
     */
    public static FunctionDescriptor oggpack_reset$descriptor() {
        return oggpack_reset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * extern void oggpack_reset(oggpack_buffer *b)
     * }
     */
    public static MethodHandle oggpack_reset$handle() {
        return oggpack_reset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * extern void oggpack_reset(oggpack_buffer *b)
     * }
     */
    public static MemorySegment oggpack_reset$address() {
        return oggpack_reset.ADDR;
    }

    /**
     * {@snippet lang = c : * extern void oggpack_reset(oggpack_buffer *b)
     * }
     */
    public static void oggpack_reset(MemorySegment b) {
        var mh$ = oggpack_reset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("oggpack_reset", b);
            }
            mh$.invokeExact(b);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class oggpack_writeclear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("oggpack_writeclear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * extern void oggpack_writeclear(oggpack_buffer *b)
     * }
     */
    public static FunctionDescriptor oggpack_writeclear$descriptor() {
        return oggpack_writeclear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * extern void oggpack_writeclear(oggpack_buffer *b)
     * }
     */
    public static MethodHandle oggpack_writeclear$handle() {
        return oggpack_writeclear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * extern void oggpack_writeclear(oggpack_buffer *b)
     * }
     */
    public static MemorySegment oggpack_writeclear$address() {
        return oggpack_writeclear.ADDR;
    }

    /**
     * {@snippet lang = c : * extern void oggpack_writeclear(oggpack_buffer *b)
     * }
     */
    public static void oggpack_writeclear(MemorySegment b) {
        var mh$ = oggpack_writeclear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("oggpack_writeclear", b);
            }
            mh$.invokeExact(b);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class oggpack_readinit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("oggpack_readinit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * extern void oggpack_readinit(oggpack_buffer *b, unsigned char *buf, int bytes)
     * }
     */
    public static FunctionDescriptor oggpack_readinit$descriptor() {
        return oggpack_readinit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * extern void oggpack_readinit(oggpack_buffer *b, unsigned char *buf, int bytes)
     * }
     */
    public static MethodHandle oggpack_readinit$handle() {
        return oggpack_readinit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * extern void oggpack_readinit(oggpack_buffer *b, unsigned char *buf, int bytes)
     * }
     */
    public static MemorySegment oggpack_readinit$address() {
        return oggpack_readinit.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * extern void oggpack_readinit(oggpack_buffer *b, unsigned char *buf, int bytes)
     * }
     */
    public static void oggpack_readinit(MemorySegment b, MemorySegment buf, int bytes) {
        var mh$ = oggpack_readinit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("oggpack_readinit", b, buf, bytes);
            }
            mh$.invokeExact(b, buf, bytes);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class oggpack_write {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER,
                opusfile_h.C_LONG,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("oggpack_write");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * extern void oggpack_write(oggpack_buffer *b, unsigned long value, int bits)
     * }
     */
    public static FunctionDescriptor oggpack_write$descriptor() {
        return oggpack_write.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * extern void oggpack_write(oggpack_buffer *b, unsigned long value, int bits)
     * }
     */
    public static MethodHandle oggpack_write$handle() {
        return oggpack_write.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * extern void oggpack_write(oggpack_buffer *b, unsigned long value, int bits)
     * }
     */
    public static MemorySegment oggpack_write$address() {
        return oggpack_write.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * extern void oggpack_write(oggpack_buffer *b, unsigned long value, int bits)
     * }
     */
    public static void oggpack_write(MemorySegment b, int value, int bits) {
        var mh$ = oggpack_write.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("oggpack_write", b, value, bits);
            }
            mh$.invokeExact(b, value, bits);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class oggpack_look {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_LONG,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("oggpack_look");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * extern long oggpack_look(oggpack_buffer *b, int bits)
     * }
     */
    public static FunctionDescriptor oggpack_look$descriptor() {
        return oggpack_look.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * extern long oggpack_look(oggpack_buffer *b, int bits)
     * }
     */
    public static MethodHandle oggpack_look$handle() {
        return oggpack_look.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * extern long oggpack_look(oggpack_buffer *b, int bits)
     * }
     */
    public static MemorySegment oggpack_look$address() {
        return oggpack_look.ADDR;
    }

    /**
     * {@snippet lang = c : * extern long oggpack_look(oggpack_buffer *b, int bits)
     * }
     */
    public static int oggpack_look(MemorySegment b, int bits) {
        var mh$ = oggpack_look.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("oggpack_look", b, bits);
            }
            return (int) mh$.invokeExact(b, bits);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class oggpack_look1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_LONG,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("oggpack_look1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * extern long oggpack_look1(oggpack_buffer *b)
     * }
     */
    public static FunctionDescriptor oggpack_look1$descriptor() {
        return oggpack_look1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * extern long oggpack_look1(oggpack_buffer *b)
     * }
     */
    public static MethodHandle oggpack_look1$handle() {
        return oggpack_look1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * extern long oggpack_look1(oggpack_buffer *b)
     * }
     */
    public static MemorySegment oggpack_look1$address() {
        return oggpack_look1.ADDR;
    }

    /**
     * {@snippet lang = c : * extern long oggpack_look1(oggpack_buffer *b)
     * }
     */
    public static int oggpack_look1(MemorySegment b) {
        var mh$ = oggpack_look1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("oggpack_look1", b);
            }
            return (int) mh$.invokeExact(b);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class oggpack_adv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("oggpack_adv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * extern void oggpack_adv(oggpack_buffer *b, int bits)
     * }
     */
    public static FunctionDescriptor oggpack_adv$descriptor() {
        return oggpack_adv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * extern void oggpack_adv(oggpack_buffer *b, int bits)
     * }
     */
    public static MethodHandle oggpack_adv$handle() {
        return oggpack_adv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * extern void oggpack_adv(oggpack_buffer *b, int bits)
     * }
     */
    public static MemorySegment oggpack_adv$address() {
        return oggpack_adv.ADDR;
    }

    /**
     * {@snippet lang = c : * extern void oggpack_adv(oggpack_buffer *b, int bits)
     * }
     */
    public static void oggpack_adv(MemorySegment b, int bits) {
        var mh$ = oggpack_adv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("oggpack_adv", b, bits);
            }
            mh$.invokeExact(b, bits);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class oggpack_adv1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("oggpack_adv1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * extern void oggpack_adv1(oggpack_buffer *b)
     * }
     */
    public static FunctionDescriptor oggpack_adv1$descriptor() {
        return oggpack_adv1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * extern void oggpack_adv1(oggpack_buffer *b)
     * }
     */
    public static MethodHandle oggpack_adv1$handle() {
        return oggpack_adv1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * extern void oggpack_adv1(oggpack_buffer *b)
     * }
     */
    public static MemorySegment oggpack_adv1$address() {
        return oggpack_adv1.ADDR;
    }

    /**
     * {@snippet lang = c : * extern void oggpack_adv1(oggpack_buffer *b)
     * }
     */
    public static void oggpack_adv1(MemorySegment b) {
        var mh$ = oggpack_adv1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("oggpack_adv1", b);
            }
            mh$.invokeExact(b);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class oggpack_read {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_LONG,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("oggpack_read");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * extern long oggpack_read(oggpack_buffer *b, int bits)
     * }
     */
    public static FunctionDescriptor oggpack_read$descriptor() {
        return oggpack_read.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * extern long oggpack_read(oggpack_buffer *b, int bits)
     * }
     */
    public static MethodHandle oggpack_read$handle() {
        return oggpack_read.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * extern long oggpack_read(oggpack_buffer *b, int bits)
     * }
     */
    public static MemorySegment oggpack_read$address() {
        return oggpack_read.ADDR;
    }

    /**
     * {@snippet lang = c : * extern long oggpack_read(oggpack_buffer *b, int bits)
     * }
     */
    public static int oggpack_read(MemorySegment b, int bits) {
        var mh$ = oggpack_read.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("oggpack_read", b, bits);
            }
            return (int) mh$.invokeExact(b, bits);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class oggpack_read1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_LONG,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("oggpack_read1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * extern long oggpack_read1(oggpack_buffer *b)
     * }
     */
    public static FunctionDescriptor oggpack_read1$descriptor() {
        return oggpack_read1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * extern long oggpack_read1(oggpack_buffer *b)
     * }
     */
    public static MethodHandle oggpack_read1$handle() {
        return oggpack_read1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * extern long oggpack_read1(oggpack_buffer *b)
     * }
     */
    public static MemorySegment oggpack_read1$address() {
        return oggpack_read1.ADDR;
    }

    /**
     * {@snippet lang = c : * extern long oggpack_read1(oggpack_buffer *b)
     * }
     */
    public static int oggpack_read1(MemorySegment b) {
        var mh$ = oggpack_read1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("oggpack_read1", b);
            }
            return (int) mh$.invokeExact(b);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class oggpack_bytes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_LONG,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("oggpack_bytes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * extern long oggpack_bytes(oggpack_buffer *b)
     * }
     */
    public static FunctionDescriptor oggpack_bytes$descriptor() {
        return oggpack_bytes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * extern long oggpack_bytes(oggpack_buffer *b)
     * }
     */
    public static MethodHandle oggpack_bytes$handle() {
        return oggpack_bytes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * extern long oggpack_bytes(oggpack_buffer *b)
     * }
     */
    public static MemorySegment oggpack_bytes$address() {
        return oggpack_bytes.ADDR;
    }

    /**
     * {@snippet lang = c : * extern long oggpack_bytes(oggpack_buffer *b)
     * }
     */
    public static int oggpack_bytes(MemorySegment b) {
        var mh$ = oggpack_bytes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("oggpack_bytes", b);
            }
            return (int) mh$.invokeExact(b);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class oggpack_bits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_LONG,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("oggpack_bits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * extern long oggpack_bits(oggpack_buffer *b)
     * }
     */
    public static FunctionDescriptor oggpack_bits$descriptor() {
        return oggpack_bits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * extern long oggpack_bits(oggpack_buffer *b)
     * }
     */
    public static MethodHandle oggpack_bits$handle() {
        return oggpack_bits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * extern long oggpack_bits(oggpack_buffer *b)
     * }
     */
    public static MemorySegment oggpack_bits$address() {
        return oggpack_bits.ADDR;
    }

    /**
     * {@snippet lang = c : * extern long oggpack_bits(oggpack_buffer *b)
     * }
     */
    public static int oggpack_bits(MemorySegment b) {
        var mh$ = oggpack_bits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("oggpack_bits", b);
            }
            return (int) mh$.invokeExact(b);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class oggpack_get_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("oggpack_get_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * extern unsigned char *oggpack_get_buffer(oggpack_buffer *b)
     * }
     */
    public static FunctionDescriptor oggpack_get_buffer$descriptor() {
        return oggpack_get_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * extern unsigned char *oggpack_get_buffer(oggpack_buffer *b)
     * }
     */
    public static MethodHandle oggpack_get_buffer$handle() {
        return oggpack_get_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * extern unsigned char *oggpack_get_buffer(oggpack_buffer *b)
     * }
     */
    public static MemorySegment oggpack_get_buffer$address() {
        return oggpack_get_buffer.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * extern unsigned char *oggpack_get_buffer(oggpack_buffer *b)
     * }
     */
    public static MemorySegment oggpack_get_buffer(MemorySegment b) {
        var mh$ = oggpack_get_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("oggpack_get_buffer", b);
            }
            return (MemorySegment) mh$.invokeExact(b);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class oggpackB_writeinit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("oggpackB_writeinit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * extern void oggpackB_writeinit(oggpack_buffer *b)
     * }
     */
    public static FunctionDescriptor oggpackB_writeinit$descriptor() {
        return oggpackB_writeinit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * extern void oggpackB_writeinit(oggpack_buffer *b)
     * }
     */
    public static MethodHandle oggpackB_writeinit$handle() {
        return oggpackB_writeinit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * extern void oggpackB_writeinit(oggpack_buffer *b)
     * }
     */
    public static MemorySegment oggpackB_writeinit$address() {
        return oggpackB_writeinit.ADDR;
    }

    /**
     * {@snippet lang = c : * extern void oggpackB_writeinit(oggpack_buffer *b)
     * }
     */
    public static void oggpackB_writeinit(MemorySegment b) {
        var mh$ = oggpackB_writeinit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("oggpackB_writeinit", b);
            }
            mh$.invokeExact(b);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class oggpackB_writecheck {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("oggpackB_writecheck");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * extern int oggpackB_writecheck(oggpack_buffer *b)
     * }
     */
    public static FunctionDescriptor oggpackB_writecheck$descriptor() {
        return oggpackB_writecheck.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * extern int oggpackB_writecheck(oggpack_buffer *b)
     * }
     */
    public static MethodHandle oggpackB_writecheck$handle() {
        return oggpackB_writecheck.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * extern int oggpackB_writecheck(oggpack_buffer *b)
     * }
     */
    public static MemorySegment oggpackB_writecheck$address() {
        return oggpackB_writecheck.ADDR;
    }

    /**
     * {@snippet lang = c : * extern int oggpackB_writecheck(oggpack_buffer *b)
     * }
     */
    public static int oggpackB_writecheck(MemorySegment b) {
        var mh$ = oggpackB_writecheck.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("oggpackB_writecheck", b);
            }
            return (int) mh$.invokeExact(b);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class oggpackB_writetrunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER,
                opusfile_h.C_LONG);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("oggpackB_writetrunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * extern void oggpackB_writetrunc(oggpack_buffer *b, long bits)
     * }
     */
    public static FunctionDescriptor oggpackB_writetrunc$descriptor() {
        return oggpackB_writetrunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * extern void oggpackB_writetrunc(oggpack_buffer *b, long bits)
     * }
     */
    public static MethodHandle oggpackB_writetrunc$handle() {
        return oggpackB_writetrunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * extern void oggpackB_writetrunc(oggpack_buffer *b, long bits)
     * }
     */
    public static MemorySegment oggpackB_writetrunc$address() {
        return oggpackB_writetrunc.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * extern void oggpackB_writetrunc(oggpack_buffer *b, long bits)
     * }
     */
    public static void oggpackB_writetrunc(MemorySegment b, int bits) {
        var mh$ = oggpackB_writetrunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("oggpackB_writetrunc", b, bits);
            }
            mh$.invokeExact(b, bits);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class oggpackB_writealign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("oggpackB_writealign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * extern void oggpackB_writealign(oggpack_buffer *b)
     * }
     */
    public static FunctionDescriptor oggpackB_writealign$descriptor() {
        return oggpackB_writealign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * extern void oggpackB_writealign(oggpack_buffer *b)
     * }
     */
    public static MethodHandle oggpackB_writealign$handle() {
        return oggpackB_writealign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * extern void oggpackB_writealign(oggpack_buffer *b)
     * }
     */
    public static MemorySegment oggpackB_writealign$address() {
        return oggpackB_writealign.ADDR;
    }

    /**
     * {@snippet lang = c : * extern void oggpackB_writealign(oggpack_buffer *b)
     * }
     */
    public static void oggpackB_writealign(MemorySegment b) {
        var mh$ = oggpackB_writealign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("oggpackB_writealign", b);
            }
            mh$.invokeExact(b);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class oggpackB_writecopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_LONG);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("oggpackB_writecopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * extern void oggpackB_writecopy(oggpack_buffer *b, void *source, long bits)
     * }
     */
    public static FunctionDescriptor oggpackB_writecopy$descriptor() {
        return oggpackB_writecopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * extern void oggpackB_writecopy(oggpack_buffer *b, void *source, long bits)
     * }
     */
    public static MethodHandle oggpackB_writecopy$handle() {
        return oggpackB_writecopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * extern void oggpackB_writecopy(oggpack_buffer *b, void *source, long bits)
     * }
     */
    public static MemorySegment oggpackB_writecopy$address() {
        return oggpackB_writecopy.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * extern void oggpackB_writecopy(oggpack_buffer *b, void *source, long bits)
     * }
     */
    public static void oggpackB_writecopy(MemorySegment b, MemorySegment source, int bits) {
        var mh$ = oggpackB_writecopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("oggpackB_writecopy", b, source, bits);
            }
            mh$.invokeExact(b, source, bits);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class oggpackB_reset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("oggpackB_reset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * extern void oggpackB_reset(oggpack_buffer *b)
     * }
     */
    public static FunctionDescriptor oggpackB_reset$descriptor() {
        return oggpackB_reset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * extern void oggpackB_reset(oggpack_buffer *b)
     * }
     */
    public static MethodHandle oggpackB_reset$handle() {
        return oggpackB_reset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * extern void oggpackB_reset(oggpack_buffer *b)
     * }
     */
    public static MemorySegment oggpackB_reset$address() {
        return oggpackB_reset.ADDR;
    }

    /**
     * {@snippet lang = c : * extern void oggpackB_reset(oggpack_buffer *b)
     * }
     */
    public static void oggpackB_reset(MemorySegment b) {
        var mh$ = oggpackB_reset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("oggpackB_reset", b);
            }
            mh$.invokeExact(b);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class oggpackB_writeclear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("oggpackB_writeclear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * extern void oggpackB_writeclear(oggpack_buffer *b)
     * }
     */
    public static FunctionDescriptor oggpackB_writeclear$descriptor() {
        return oggpackB_writeclear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * extern void oggpackB_writeclear(oggpack_buffer *b)
     * }
     */
    public static MethodHandle oggpackB_writeclear$handle() {
        return oggpackB_writeclear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * extern void oggpackB_writeclear(oggpack_buffer *b)
     * }
     */
    public static MemorySegment oggpackB_writeclear$address() {
        return oggpackB_writeclear.ADDR;
    }

    /**
     * {@snippet lang = c : * extern void oggpackB_writeclear(oggpack_buffer *b)
     * }
     */
    public static void oggpackB_writeclear(MemorySegment b) {
        var mh$ = oggpackB_writeclear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("oggpackB_writeclear", b);
            }
            mh$.invokeExact(b);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class oggpackB_readinit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("oggpackB_readinit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * extern void oggpackB_readinit(oggpack_buffer *b, unsigned char *buf, int bytes)
     * }
     */
    public static FunctionDescriptor oggpackB_readinit$descriptor() {
        return oggpackB_readinit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * extern void oggpackB_readinit(oggpack_buffer *b, unsigned char *buf, int bytes)
     * }
     */
    public static MethodHandle oggpackB_readinit$handle() {
        return oggpackB_readinit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * extern void oggpackB_readinit(oggpack_buffer *b, unsigned char *buf, int bytes)
     * }
     */
    public static MemorySegment oggpackB_readinit$address() {
        return oggpackB_readinit.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * extern void oggpackB_readinit(oggpack_buffer *b, unsigned char *buf, int bytes)
     * }
     */
    public static void oggpackB_readinit(MemorySegment b, MemorySegment buf, int bytes) {
        var mh$ = oggpackB_readinit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("oggpackB_readinit", b, buf, bytes);
            }
            mh$.invokeExact(b, buf, bytes);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class oggpackB_write {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER,
                opusfile_h.C_LONG,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("oggpackB_write");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * extern void oggpackB_write(oggpack_buffer *b, unsigned long value, int bits)
     * }
     */
    public static FunctionDescriptor oggpackB_write$descriptor() {
        return oggpackB_write.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * extern void oggpackB_write(oggpack_buffer *b, unsigned long value, int bits)
     * }
     */
    public static MethodHandle oggpackB_write$handle() {
        return oggpackB_write.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * extern void oggpackB_write(oggpack_buffer *b, unsigned long value, int bits)
     * }
     */
    public static MemorySegment oggpackB_write$address() {
        return oggpackB_write.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * extern void oggpackB_write(oggpack_buffer *b, unsigned long value, int bits)
     * }
     */
    public static void oggpackB_write(MemorySegment b, int value, int bits) {
        var mh$ = oggpackB_write.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("oggpackB_write", b, value, bits);
            }
            mh$.invokeExact(b, value, bits);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class oggpackB_look {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_LONG,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("oggpackB_look");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * extern long oggpackB_look(oggpack_buffer *b, int bits)
     * }
     */
    public static FunctionDescriptor oggpackB_look$descriptor() {
        return oggpackB_look.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * extern long oggpackB_look(oggpack_buffer *b, int bits)
     * }
     */
    public static MethodHandle oggpackB_look$handle() {
        return oggpackB_look.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * extern long oggpackB_look(oggpack_buffer *b, int bits)
     * }
     */
    public static MemorySegment oggpackB_look$address() {
        return oggpackB_look.ADDR;
    }

    /**
     * {@snippet lang = c : * extern long oggpackB_look(oggpack_buffer *b, int bits)
     * }
     */
    public static int oggpackB_look(MemorySegment b, int bits) {
        var mh$ = oggpackB_look.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("oggpackB_look", b, bits);
            }
            return (int) mh$.invokeExact(b, bits);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class oggpackB_look1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_LONG,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("oggpackB_look1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * extern long oggpackB_look1(oggpack_buffer *b)
     * }
     */
    public static FunctionDescriptor oggpackB_look1$descriptor() {
        return oggpackB_look1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * extern long oggpackB_look1(oggpack_buffer *b)
     * }
     */
    public static MethodHandle oggpackB_look1$handle() {
        return oggpackB_look1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * extern long oggpackB_look1(oggpack_buffer *b)
     * }
     */
    public static MemorySegment oggpackB_look1$address() {
        return oggpackB_look1.ADDR;
    }

    /**
     * {@snippet lang = c : * extern long oggpackB_look1(oggpack_buffer *b)
     * }
     */
    public static int oggpackB_look1(MemorySegment b) {
        var mh$ = oggpackB_look1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("oggpackB_look1", b);
            }
            return (int) mh$.invokeExact(b);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class oggpackB_adv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("oggpackB_adv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * extern void oggpackB_adv(oggpack_buffer *b, int bits)
     * }
     */
    public static FunctionDescriptor oggpackB_adv$descriptor() {
        return oggpackB_adv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * extern void oggpackB_adv(oggpack_buffer *b, int bits)
     * }
     */
    public static MethodHandle oggpackB_adv$handle() {
        return oggpackB_adv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * extern void oggpackB_adv(oggpack_buffer *b, int bits)
     * }
     */
    public static MemorySegment oggpackB_adv$address() {
        return oggpackB_adv.ADDR;
    }

    /**
     * {@snippet lang = c : * extern void oggpackB_adv(oggpack_buffer *b, int bits)
     * }
     */
    public static void oggpackB_adv(MemorySegment b, int bits) {
        var mh$ = oggpackB_adv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("oggpackB_adv", b, bits);
            }
            mh$.invokeExact(b, bits);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class oggpackB_adv1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("oggpackB_adv1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * extern void oggpackB_adv1(oggpack_buffer *b)
     * }
     */
    public static FunctionDescriptor oggpackB_adv1$descriptor() {
        return oggpackB_adv1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * extern void oggpackB_adv1(oggpack_buffer *b)
     * }
     */
    public static MethodHandle oggpackB_adv1$handle() {
        return oggpackB_adv1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * extern void oggpackB_adv1(oggpack_buffer *b)
     * }
     */
    public static MemorySegment oggpackB_adv1$address() {
        return oggpackB_adv1.ADDR;
    }

    /**
     * {@snippet lang = c : * extern void oggpackB_adv1(oggpack_buffer *b)
     * }
     */
    public static void oggpackB_adv1(MemorySegment b) {
        var mh$ = oggpackB_adv1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("oggpackB_adv1", b);
            }
            mh$.invokeExact(b);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class oggpackB_read {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_LONG,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("oggpackB_read");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * extern long oggpackB_read(oggpack_buffer *b, int bits)
     * }
     */
    public static FunctionDescriptor oggpackB_read$descriptor() {
        return oggpackB_read.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * extern long oggpackB_read(oggpack_buffer *b, int bits)
     * }
     */
    public static MethodHandle oggpackB_read$handle() {
        return oggpackB_read.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * extern long oggpackB_read(oggpack_buffer *b, int bits)
     * }
     */
    public static MemorySegment oggpackB_read$address() {
        return oggpackB_read.ADDR;
    }

    /**
     * {@snippet lang = c : * extern long oggpackB_read(oggpack_buffer *b, int bits)
     * }
     */
    public static int oggpackB_read(MemorySegment b, int bits) {
        var mh$ = oggpackB_read.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("oggpackB_read", b, bits);
            }
            return (int) mh$.invokeExact(b, bits);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class oggpackB_read1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_LONG,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("oggpackB_read1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * extern long oggpackB_read1(oggpack_buffer *b)
     * }
     */
    public static FunctionDescriptor oggpackB_read1$descriptor() {
        return oggpackB_read1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * extern long oggpackB_read1(oggpack_buffer *b)
     * }
     */
    public static MethodHandle oggpackB_read1$handle() {
        return oggpackB_read1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * extern long oggpackB_read1(oggpack_buffer *b)
     * }
     */
    public static MemorySegment oggpackB_read1$address() {
        return oggpackB_read1.ADDR;
    }

    /**
     * {@snippet lang = c : * extern long oggpackB_read1(oggpack_buffer *b)
     * }
     */
    public static int oggpackB_read1(MemorySegment b) {
        var mh$ = oggpackB_read1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("oggpackB_read1", b);
            }
            return (int) mh$.invokeExact(b);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class oggpackB_bytes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_LONG,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("oggpackB_bytes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * extern long oggpackB_bytes(oggpack_buffer *b)
     * }
     */
    public static FunctionDescriptor oggpackB_bytes$descriptor() {
        return oggpackB_bytes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * extern long oggpackB_bytes(oggpack_buffer *b)
     * }
     */
    public static MethodHandle oggpackB_bytes$handle() {
        return oggpackB_bytes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * extern long oggpackB_bytes(oggpack_buffer *b)
     * }
     */
    public static MemorySegment oggpackB_bytes$address() {
        return oggpackB_bytes.ADDR;
    }

    /**
     * {@snippet lang = c : * extern long oggpackB_bytes(oggpack_buffer *b)
     * }
     */
    public static int oggpackB_bytes(MemorySegment b) {
        var mh$ = oggpackB_bytes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("oggpackB_bytes", b);
            }
            return (int) mh$.invokeExact(b);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class oggpackB_bits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_LONG,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("oggpackB_bits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * extern long oggpackB_bits(oggpack_buffer *b)
     * }
     */
    public static FunctionDescriptor oggpackB_bits$descriptor() {
        return oggpackB_bits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * extern long oggpackB_bits(oggpack_buffer *b)
     * }
     */
    public static MethodHandle oggpackB_bits$handle() {
        return oggpackB_bits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * extern long oggpackB_bits(oggpack_buffer *b)
     * }
     */
    public static MemorySegment oggpackB_bits$address() {
        return oggpackB_bits.ADDR;
    }

    /**
     * {@snippet lang = c : * extern long oggpackB_bits(oggpack_buffer *b)
     * }
     */
    public static int oggpackB_bits(MemorySegment b) {
        var mh$ = oggpackB_bits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("oggpackB_bits", b);
            }
            return (int) mh$.invokeExact(b);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class oggpackB_get_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("oggpackB_get_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * extern unsigned char *oggpackB_get_buffer(oggpack_buffer *b)
     * }
     */
    public static FunctionDescriptor oggpackB_get_buffer$descriptor() {
        return oggpackB_get_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * extern unsigned char *oggpackB_get_buffer(oggpack_buffer *b)
     * }
     */
    public static MethodHandle oggpackB_get_buffer$handle() {
        return oggpackB_get_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * extern unsigned char *oggpackB_get_buffer(oggpack_buffer *b)
     * }
     */
    public static MemorySegment oggpackB_get_buffer$address() {
        return oggpackB_get_buffer.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * extern unsigned char *oggpackB_get_buffer(oggpack_buffer *b)
     * }
     */
    public static MemorySegment oggpackB_get_buffer(MemorySegment b) {
        var mh$ = oggpackB_get_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("oggpackB_get_buffer", b);
            }
            return (MemorySegment) mh$.invokeExact(b);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ogg_stream_packetin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ogg_stream_packetin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * extern int ogg_stream_packetin(ogg_stream_state *os, ogg_packet *op)
     * }
     */
    public static FunctionDescriptor ogg_stream_packetin$descriptor() {
        return ogg_stream_packetin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * extern int ogg_stream_packetin(ogg_stream_state *os, ogg_packet *op)
     * }
     */
    public static MethodHandle ogg_stream_packetin$handle() {
        return ogg_stream_packetin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * extern int ogg_stream_packetin(ogg_stream_state *os, ogg_packet *op)
     * }
     */
    public static MemorySegment ogg_stream_packetin$address() {
        return ogg_stream_packetin.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * extern int ogg_stream_packetin(ogg_stream_state *os, ogg_packet *op)
     * }
     */
    public static int ogg_stream_packetin(MemorySegment os, MemorySegment op) {
        var mh$ = ogg_stream_packetin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ogg_stream_packetin", os, op);
            }
            return (int) mh$.invokeExact(os, op);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ogg_stream_iovecin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_LONG,
                opusfile_h.C_LONG_LONG);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ogg_stream_iovecin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * extern int ogg_stream_iovecin(ogg_stream_state *os, ogg_iovec_t *iov, int count, long e_o_s, ogg_int64_t granulepos)
     * }
     */
    public static FunctionDescriptor ogg_stream_iovecin$descriptor() {
        return ogg_stream_iovecin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * extern int ogg_stream_iovecin(ogg_stream_state *os, ogg_iovec_t *iov, int count, long e_o_s, ogg_int64_t granulepos)
     * }
     */
    public static MethodHandle ogg_stream_iovecin$handle() {
        return ogg_stream_iovecin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * extern int ogg_stream_iovecin(ogg_stream_state *os, ogg_iovec_t *iov, int count, long e_o_s, ogg_int64_t granulepos)
     * }
     */
    public static MemorySegment ogg_stream_iovecin$address() {
        return ogg_stream_iovecin.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * extern int ogg_stream_iovecin(ogg_stream_state *os, ogg_iovec_t *iov, int count, long e_o_s, ogg_int64_t granulepos)
     * }
     */
    public static int ogg_stream_iovecin(MemorySegment os, MemorySegment iov, int count, int e_o_s, long granulepos) {
        var mh$ = ogg_stream_iovecin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ogg_stream_iovecin", os, iov, count, e_o_s, granulepos);
            }
            return (int) mh$.invokeExact(os, iov, count, e_o_s, granulepos);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ogg_stream_pageout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ogg_stream_pageout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * extern int ogg_stream_pageout(ogg_stream_state *os, ogg_page *og)
     * }
     */
    public static FunctionDescriptor ogg_stream_pageout$descriptor() {
        return ogg_stream_pageout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * extern int ogg_stream_pageout(ogg_stream_state *os, ogg_page *og)
     * }
     */
    public static MethodHandle ogg_stream_pageout$handle() {
        return ogg_stream_pageout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * extern int ogg_stream_pageout(ogg_stream_state *os, ogg_page *og)
     * }
     */
    public static MemorySegment ogg_stream_pageout$address() {
        return ogg_stream_pageout.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * extern int ogg_stream_pageout(ogg_stream_state *os, ogg_page *og)
     * }
     */
    public static int ogg_stream_pageout(MemorySegment os, MemorySegment og) {
        var mh$ = ogg_stream_pageout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ogg_stream_pageout", os, og);
            }
            return (int) mh$.invokeExact(os, og);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ogg_stream_pageout_fill {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ogg_stream_pageout_fill");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * extern int ogg_stream_pageout_fill(ogg_stream_state *os, ogg_page *og, int nfill)
     * }
     */
    public static FunctionDescriptor ogg_stream_pageout_fill$descriptor() {
        return ogg_stream_pageout_fill.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * extern int ogg_stream_pageout_fill(ogg_stream_state *os, ogg_page *og, int nfill)
     * }
     */
    public static MethodHandle ogg_stream_pageout_fill$handle() {
        return ogg_stream_pageout_fill.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * extern int ogg_stream_pageout_fill(ogg_stream_state *os, ogg_page *og, int nfill)
     * }
     */
    public static MemorySegment ogg_stream_pageout_fill$address() {
        return ogg_stream_pageout_fill.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * extern int ogg_stream_pageout_fill(ogg_stream_state *os, ogg_page *og, int nfill)
     * }
     */
    public static int ogg_stream_pageout_fill(MemorySegment os, MemorySegment og, int nfill) {
        var mh$ = ogg_stream_pageout_fill.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ogg_stream_pageout_fill", os, og, nfill);
            }
            return (int) mh$.invokeExact(os, og, nfill);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ogg_stream_flush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ogg_stream_flush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * extern int ogg_stream_flush(ogg_stream_state *os, ogg_page *og)
     * }
     */
    public static FunctionDescriptor ogg_stream_flush$descriptor() {
        return ogg_stream_flush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * extern int ogg_stream_flush(ogg_stream_state *os, ogg_page *og)
     * }
     */
    public static MethodHandle ogg_stream_flush$handle() {
        return ogg_stream_flush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * extern int ogg_stream_flush(ogg_stream_state *os, ogg_page *og)
     * }
     */
    public static MemorySegment ogg_stream_flush$address() {
        return ogg_stream_flush.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * extern int ogg_stream_flush(ogg_stream_state *os, ogg_page *og)
     * }
     */
    public static int ogg_stream_flush(MemorySegment os, MemorySegment og) {
        var mh$ = ogg_stream_flush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ogg_stream_flush", os, og);
            }
            return (int) mh$.invokeExact(os, og);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ogg_stream_flush_fill {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ogg_stream_flush_fill");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * extern int ogg_stream_flush_fill(ogg_stream_state *os, ogg_page *og, int nfill)
     * }
     */
    public static FunctionDescriptor ogg_stream_flush_fill$descriptor() {
        return ogg_stream_flush_fill.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * extern int ogg_stream_flush_fill(ogg_stream_state *os, ogg_page *og, int nfill)
     * }
     */
    public static MethodHandle ogg_stream_flush_fill$handle() {
        return ogg_stream_flush_fill.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * extern int ogg_stream_flush_fill(ogg_stream_state *os, ogg_page *og, int nfill)
     * }
     */
    public static MemorySegment ogg_stream_flush_fill$address() {
        return ogg_stream_flush_fill.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * extern int ogg_stream_flush_fill(ogg_stream_state *os, ogg_page *og, int nfill)
     * }
     */
    public static int ogg_stream_flush_fill(MemorySegment os, MemorySegment og, int nfill) {
        var mh$ = ogg_stream_flush_fill.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ogg_stream_flush_fill", os, og, nfill);
            }
            return (int) mh$.invokeExact(os, og, nfill);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ogg_sync_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ogg_sync_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * extern int ogg_sync_init(ogg_sync_state *oy)
     * }
     */
    public static FunctionDescriptor ogg_sync_init$descriptor() {
        return ogg_sync_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * extern int ogg_sync_init(ogg_sync_state *oy)
     * }
     */
    public static MethodHandle ogg_sync_init$handle() {
        return ogg_sync_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * extern int ogg_sync_init(ogg_sync_state *oy)
     * }
     */
    public static MemorySegment ogg_sync_init$address() {
        return ogg_sync_init.ADDR;
    }

    /**
     * {@snippet lang = c : * extern int ogg_sync_init(ogg_sync_state *oy)
     * }
     */
    public static int ogg_sync_init(MemorySegment oy) {
        var mh$ = ogg_sync_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ogg_sync_init", oy);
            }
            return (int) mh$.invokeExact(oy);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ogg_sync_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ogg_sync_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * extern int ogg_sync_clear(ogg_sync_state *oy)
     * }
     */
    public static FunctionDescriptor ogg_sync_clear$descriptor() {
        return ogg_sync_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * extern int ogg_sync_clear(ogg_sync_state *oy)
     * }
     */
    public static MethodHandle ogg_sync_clear$handle() {
        return ogg_sync_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * extern int ogg_sync_clear(ogg_sync_state *oy)
     * }
     */
    public static MemorySegment ogg_sync_clear$address() {
        return ogg_sync_clear.ADDR;
    }

    /**
     * {@snippet lang = c : * extern int ogg_sync_clear(ogg_sync_state *oy)
     * }
     */
    public static int ogg_sync_clear(MemorySegment oy) {
        var mh$ = ogg_sync_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ogg_sync_clear", oy);
            }
            return (int) mh$.invokeExact(oy);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ogg_sync_reset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ogg_sync_reset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * extern int ogg_sync_reset(ogg_sync_state *oy)
     * }
     */
    public static FunctionDescriptor ogg_sync_reset$descriptor() {
        return ogg_sync_reset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * extern int ogg_sync_reset(ogg_sync_state *oy)
     * }
     */
    public static MethodHandle ogg_sync_reset$handle() {
        return ogg_sync_reset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * extern int ogg_sync_reset(ogg_sync_state *oy)
     * }
     */
    public static MemorySegment ogg_sync_reset$address() {
        return ogg_sync_reset.ADDR;
    }

    /**
     * {@snippet lang = c : * extern int ogg_sync_reset(ogg_sync_state *oy)
     * }
     */
    public static int ogg_sync_reset(MemorySegment oy) {
        var mh$ = ogg_sync_reset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ogg_sync_reset", oy);
            }
            return (int) mh$.invokeExact(oy);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ogg_sync_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ogg_sync_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * extern int ogg_sync_destroy(ogg_sync_state *oy)
     * }
     */
    public static FunctionDescriptor ogg_sync_destroy$descriptor() {
        return ogg_sync_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * extern int ogg_sync_destroy(ogg_sync_state *oy)
     * }
     */
    public static MethodHandle ogg_sync_destroy$handle() {
        return ogg_sync_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * extern int ogg_sync_destroy(ogg_sync_state *oy)
     * }
     */
    public static MemorySegment ogg_sync_destroy$address() {
        return ogg_sync_destroy.ADDR;
    }

    /**
     * {@snippet lang = c : * extern int ogg_sync_destroy(ogg_sync_state *oy)
     * }
     */
    public static int ogg_sync_destroy(MemorySegment oy) {
        var mh$ = ogg_sync_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ogg_sync_destroy", oy);
            }
            return (int) mh$.invokeExact(oy);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ogg_sync_check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ogg_sync_check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * extern int ogg_sync_check(ogg_sync_state *oy)
     * }
     */
    public static FunctionDescriptor ogg_sync_check$descriptor() {
        return ogg_sync_check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * extern int ogg_sync_check(ogg_sync_state *oy)
     * }
     */
    public static MethodHandle ogg_sync_check$handle() {
        return ogg_sync_check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * extern int ogg_sync_check(ogg_sync_state *oy)
     * }
     */
    public static MemorySegment ogg_sync_check$address() {
        return ogg_sync_check.ADDR;
    }

    /**
     * {@snippet lang = c : * extern int ogg_sync_check(ogg_sync_state *oy)
     * }
     */
    public static int ogg_sync_check(MemorySegment oy) {
        var mh$ = ogg_sync_check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ogg_sync_check", oy);
            }
            return (int) mh$.invokeExact(oy);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ogg_sync_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_LONG);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ogg_sync_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * extern char *ogg_sync_buffer(ogg_sync_state *oy, long size)
     * }
     */
    public static FunctionDescriptor ogg_sync_buffer$descriptor() {
        return ogg_sync_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * extern char *ogg_sync_buffer(ogg_sync_state *oy, long size)
     * }
     */
    public static MethodHandle ogg_sync_buffer$handle() {
        return ogg_sync_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * extern char *ogg_sync_buffer(ogg_sync_state *oy, long size)
     * }
     */
    public static MemorySegment ogg_sync_buffer$address() {
        return ogg_sync_buffer.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * extern char *ogg_sync_buffer(ogg_sync_state *oy, long size)
     * }
     */
    public static MemorySegment ogg_sync_buffer(MemorySegment oy, int size) {
        var mh$ = ogg_sync_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ogg_sync_buffer", oy, size);
            }
            return (MemorySegment) mh$.invokeExact(oy, size);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ogg_sync_wrote {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_LONG);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ogg_sync_wrote");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * extern int ogg_sync_wrote(ogg_sync_state *oy, long bytes)
     * }
     */
    public static FunctionDescriptor ogg_sync_wrote$descriptor() {
        return ogg_sync_wrote.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * extern int ogg_sync_wrote(ogg_sync_state *oy, long bytes)
     * }
     */
    public static MethodHandle ogg_sync_wrote$handle() {
        return ogg_sync_wrote.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * extern int ogg_sync_wrote(ogg_sync_state *oy, long bytes)
     * }
     */
    public static MemorySegment ogg_sync_wrote$address() {
        return ogg_sync_wrote.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * extern int ogg_sync_wrote(ogg_sync_state *oy, long bytes)
     * }
     */
    public static int ogg_sync_wrote(MemorySegment oy, int bytes) {
        var mh$ = ogg_sync_wrote.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ogg_sync_wrote", oy, bytes);
            }
            return (int) mh$.invokeExact(oy, bytes);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ogg_sync_pageseek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_LONG,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ogg_sync_pageseek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * extern long ogg_sync_pageseek(ogg_sync_state *oy, ogg_page *og)
     * }
     */
    public static FunctionDescriptor ogg_sync_pageseek$descriptor() {
        return ogg_sync_pageseek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * extern long ogg_sync_pageseek(ogg_sync_state *oy, ogg_page *og)
     * }
     */
    public static MethodHandle ogg_sync_pageseek$handle() {
        return ogg_sync_pageseek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * extern long ogg_sync_pageseek(ogg_sync_state *oy, ogg_page *og)
     * }
     */
    public static MemorySegment ogg_sync_pageseek$address() {
        return ogg_sync_pageseek.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * extern long ogg_sync_pageseek(ogg_sync_state *oy, ogg_page *og)
     * }
     */
    public static int ogg_sync_pageseek(MemorySegment oy, MemorySegment og) {
        var mh$ = ogg_sync_pageseek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ogg_sync_pageseek", oy, og);
            }
            return (int) mh$.invokeExact(oy, og);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ogg_sync_pageout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ogg_sync_pageout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * extern int ogg_sync_pageout(ogg_sync_state *oy, ogg_page *og)
     * }
     */
    public static FunctionDescriptor ogg_sync_pageout$descriptor() {
        return ogg_sync_pageout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * extern int ogg_sync_pageout(ogg_sync_state *oy, ogg_page *og)
     * }
     */
    public static MethodHandle ogg_sync_pageout$handle() {
        return ogg_sync_pageout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * extern int ogg_sync_pageout(ogg_sync_state *oy, ogg_page *og)
     * }
     */
    public static MemorySegment ogg_sync_pageout$address() {
        return ogg_sync_pageout.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * extern int ogg_sync_pageout(ogg_sync_state *oy, ogg_page *og)
     * }
     */
    public static int ogg_sync_pageout(MemorySegment oy, MemorySegment og) {
        var mh$ = ogg_sync_pageout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ogg_sync_pageout", oy, og);
            }
            return (int) mh$.invokeExact(oy, og);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ogg_stream_pagein {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ogg_stream_pagein");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * extern int ogg_stream_pagein(ogg_stream_state *os, ogg_page *og)
     * }
     */
    public static FunctionDescriptor ogg_stream_pagein$descriptor() {
        return ogg_stream_pagein.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * extern int ogg_stream_pagein(ogg_stream_state *os, ogg_page *og)
     * }
     */
    public static MethodHandle ogg_stream_pagein$handle() {
        return ogg_stream_pagein.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * extern int ogg_stream_pagein(ogg_stream_state *os, ogg_page *og)
     * }
     */
    public static MemorySegment ogg_stream_pagein$address() {
        return ogg_stream_pagein.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * extern int ogg_stream_pagein(ogg_stream_state *os, ogg_page *og)
     * }
     */
    public static int ogg_stream_pagein(MemorySegment os, MemorySegment og) {
        var mh$ = ogg_stream_pagein.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ogg_stream_pagein", os, og);
            }
            return (int) mh$.invokeExact(os, og);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ogg_stream_packetout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ogg_stream_packetout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * extern int ogg_stream_packetout(ogg_stream_state *os, ogg_packet *op)
     * }
     */
    public static FunctionDescriptor ogg_stream_packetout$descriptor() {
        return ogg_stream_packetout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * extern int ogg_stream_packetout(ogg_stream_state *os, ogg_packet *op)
     * }
     */
    public static MethodHandle ogg_stream_packetout$handle() {
        return ogg_stream_packetout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * extern int ogg_stream_packetout(ogg_stream_state *os, ogg_packet *op)
     * }
     */
    public static MemorySegment ogg_stream_packetout$address() {
        return ogg_stream_packetout.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * extern int ogg_stream_packetout(ogg_stream_state *os, ogg_packet *op)
     * }
     */
    public static int ogg_stream_packetout(MemorySegment os, MemorySegment op) {
        var mh$ = ogg_stream_packetout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ogg_stream_packetout", os, op);
            }
            return (int) mh$.invokeExact(os, op);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ogg_stream_packetpeek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ogg_stream_packetpeek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * extern int ogg_stream_packetpeek(ogg_stream_state *os, ogg_packet *op)
     * }
     */
    public static FunctionDescriptor ogg_stream_packetpeek$descriptor() {
        return ogg_stream_packetpeek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * extern int ogg_stream_packetpeek(ogg_stream_state *os, ogg_packet *op)
     * }
     */
    public static MethodHandle ogg_stream_packetpeek$handle() {
        return ogg_stream_packetpeek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * extern int ogg_stream_packetpeek(ogg_stream_state *os, ogg_packet *op)
     * }
     */
    public static MemorySegment ogg_stream_packetpeek$address() {
        return ogg_stream_packetpeek.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * extern int ogg_stream_packetpeek(ogg_stream_state *os, ogg_packet *op)
     * }
     */
    public static int ogg_stream_packetpeek(MemorySegment os, MemorySegment op) {
        var mh$ = ogg_stream_packetpeek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ogg_stream_packetpeek", os, op);
            }
            return (int) mh$.invokeExact(os, op);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ogg_stream_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ogg_stream_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * extern int ogg_stream_init(ogg_stream_state *os, int serialno)
     * }
     */
    public static FunctionDescriptor ogg_stream_init$descriptor() {
        return ogg_stream_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * extern int ogg_stream_init(ogg_stream_state *os, int serialno)
     * }
     */
    public static MethodHandle ogg_stream_init$handle() {
        return ogg_stream_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * extern int ogg_stream_init(ogg_stream_state *os, int serialno)
     * }
     */
    public static MemorySegment ogg_stream_init$address() {
        return ogg_stream_init.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * extern int ogg_stream_init(ogg_stream_state *os, int serialno)
     * }
     */
    public static int ogg_stream_init(MemorySegment os, int serialno) {
        var mh$ = ogg_stream_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ogg_stream_init", os, serialno);
            }
            return (int) mh$.invokeExact(os, serialno);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ogg_stream_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ogg_stream_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * extern int ogg_stream_clear(ogg_stream_state *os)
     * }
     */
    public static FunctionDescriptor ogg_stream_clear$descriptor() {
        return ogg_stream_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * extern int ogg_stream_clear(ogg_stream_state *os)
     * }
     */
    public static MethodHandle ogg_stream_clear$handle() {
        return ogg_stream_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * extern int ogg_stream_clear(ogg_stream_state *os)
     * }
     */
    public static MemorySegment ogg_stream_clear$address() {
        return ogg_stream_clear.ADDR;
    }

    /**
     * {@snippet lang = c : * extern int ogg_stream_clear(ogg_stream_state *os)
     * }
     */
    public static int ogg_stream_clear(MemorySegment os) {
        var mh$ = ogg_stream_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ogg_stream_clear", os);
            }
            return (int) mh$.invokeExact(os);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ogg_stream_reset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ogg_stream_reset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * extern int ogg_stream_reset(ogg_stream_state *os)
     * }
     */
    public static FunctionDescriptor ogg_stream_reset$descriptor() {
        return ogg_stream_reset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * extern int ogg_stream_reset(ogg_stream_state *os)
     * }
     */
    public static MethodHandle ogg_stream_reset$handle() {
        return ogg_stream_reset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * extern int ogg_stream_reset(ogg_stream_state *os)
     * }
     */
    public static MemorySegment ogg_stream_reset$address() {
        return ogg_stream_reset.ADDR;
    }

    /**
     * {@snippet lang = c : * extern int ogg_stream_reset(ogg_stream_state *os)
     * }
     */
    public static int ogg_stream_reset(MemorySegment os) {
        var mh$ = ogg_stream_reset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ogg_stream_reset", os);
            }
            return (int) mh$.invokeExact(os);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ogg_stream_reset_serialno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ogg_stream_reset_serialno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * extern int ogg_stream_reset_serialno(ogg_stream_state *os, int serialno)
     * }
     */
    public static FunctionDescriptor ogg_stream_reset_serialno$descriptor() {
        return ogg_stream_reset_serialno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * extern int ogg_stream_reset_serialno(ogg_stream_state *os, int serialno)
     * }
     */
    public static MethodHandle ogg_stream_reset_serialno$handle() {
        return ogg_stream_reset_serialno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * extern int ogg_stream_reset_serialno(ogg_stream_state *os, int serialno)
     * }
     */
    public static MemorySegment ogg_stream_reset_serialno$address() {
        return ogg_stream_reset_serialno.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * extern int ogg_stream_reset_serialno(ogg_stream_state *os, int serialno)
     * }
     */
    public static int ogg_stream_reset_serialno(MemorySegment os, int serialno) {
        var mh$ = ogg_stream_reset_serialno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ogg_stream_reset_serialno", os, serialno);
            }
            return (int) mh$.invokeExact(os, serialno);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ogg_stream_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ogg_stream_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * extern int ogg_stream_destroy(ogg_stream_state *os)
     * }
     */
    public static FunctionDescriptor ogg_stream_destroy$descriptor() {
        return ogg_stream_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * extern int ogg_stream_destroy(ogg_stream_state *os)
     * }
     */
    public static MethodHandle ogg_stream_destroy$handle() {
        return ogg_stream_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * extern int ogg_stream_destroy(ogg_stream_state *os)
     * }
     */
    public static MemorySegment ogg_stream_destroy$address() {
        return ogg_stream_destroy.ADDR;
    }

    /**
     * {@snippet lang = c : * extern int ogg_stream_destroy(ogg_stream_state *os)
     * }
     */
    public static int ogg_stream_destroy(MemorySegment os) {
        var mh$ = ogg_stream_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ogg_stream_destroy", os);
            }
            return (int) mh$.invokeExact(os);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ogg_stream_check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ogg_stream_check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * extern int ogg_stream_check(ogg_stream_state *os)
     * }
     */
    public static FunctionDescriptor ogg_stream_check$descriptor() {
        return ogg_stream_check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * extern int ogg_stream_check(ogg_stream_state *os)
     * }
     */
    public static MethodHandle ogg_stream_check$handle() {
        return ogg_stream_check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * extern int ogg_stream_check(ogg_stream_state *os)
     * }
     */
    public static MemorySegment ogg_stream_check$address() {
        return ogg_stream_check.ADDR;
    }

    /**
     * {@snippet lang = c : * extern int ogg_stream_check(ogg_stream_state *os)
     * }
     */
    public static int ogg_stream_check(MemorySegment os) {
        var mh$ = ogg_stream_check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ogg_stream_check", os);
            }
            return (int) mh$.invokeExact(os);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ogg_stream_eos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ogg_stream_eos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * extern int ogg_stream_eos(ogg_stream_state *os)
     * }
     */
    public static FunctionDescriptor ogg_stream_eos$descriptor() {
        return ogg_stream_eos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * extern int ogg_stream_eos(ogg_stream_state *os)
     * }
     */
    public static MethodHandle ogg_stream_eos$handle() {
        return ogg_stream_eos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * extern int ogg_stream_eos(ogg_stream_state *os)
     * }
     */
    public static MemorySegment ogg_stream_eos$address() {
        return ogg_stream_eos.ADDR;
    }

    /**
     * {@snippet lang = c : * extern int ogg_stream_eos(ogg_stream_state *os)
     * }
     */
    public static int ogg_stream_eos(MemorySegment os) {
        var mh$ = ogg_stream_eos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ogg_stream_eos", os);
            }
            return (int) mh$.invokeExact(os);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ogg_page_checksum_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ogg_page_checksum_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * extern void ogg_page_checksum_set(ogg_page *og)
     * }
     */
    public static FunctionDescriptor ogg_page_checksum_set$descriptor() {
        return ogg_page_checksum_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * extern void ogg_page_checksum_set(ogg_page *og)
     * }
     */
    public static MethodHandle ogg_page_checksum_set$handle() {
        return ogg_page_checksum_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * extern void ogg_page_checksum_set(ogg_page *og)
     * }
     */
    public static MemorySegment ogg_page_checksum_set$address() {
        return ogg_page_checksum_set.ADDR;
    }

    /**
     * {@snippet lang = c : * extern void ogg_page_checksum_set(ogg_page *og)
     * }
     */
    public static void ogg_page_checksum_set(MemorySegment og) {
        var mh$ = ogg_page_checksum_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ogg_page_checksum_set", og);
            }
            mh$.invokeExact(og);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ogg_page_version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ogg_page_version");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * extern int ogg_page_version(const ogg_page *og)
     * }
     */
    public static FunctionDescriptor ogg_page_version$descriptor() {
        return ogg_page_version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * extern int ogg_page_version(const ogg_page *og)
     * }
     */
    public static MethodHandle ogg_page_version$handle() {
        return ogg_page_version.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * extern int ogg_page_version(const ogg_page *og)
     * }
     */
    public static MemorySegment ogg_page_version$address() {
        return ogg_page_version.ADDR;
    }

    /**
     * {@snippet lang = c : * extern int ogg_page_version(const ogg_page *og)
     * }
     */
    public static int ogg_page_version(MemorySegment og) {
        var mh$ = ogg_page_version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ogg_page_version", og);
            }
            return (int) mh$.invokeExact(og);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ogg_page_continued {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ogg_page_continued");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * extern int ogg_page_continued(const ogg_page *og)
     * }
     */
    public static FunctionDescriptor ogg_page_continued$descriptor() {
        return ogg_page_continued.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * extern int ogg_page_continued(const ogg_page *og)
     * }
     */
    public static MethodHandle ogg_page_continued$handle() {
        return ogg_page_continued.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * extern int ogg_page_continued(const ogg_page *og)
     * }
     */
    public static MemorySegment ogg_page_continued$address() {
        return ogg_page_continued.ADDR;
    }

    /**
     * {@snippet lang = c : * extern int ogg_page_continued(const ogg_page *og)
     * }
     */
    public static int ogg_page_continued(MemorySegment og) {
        var mh$ = ogg_page_continued.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ogg_page_continued", og);
            }
            return (int) mh$.invokeExact(og);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ogg_page_bos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ogg_page_bos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * extern int ogg_page_bos(const ogg_page *og)
     * }
     */
    public static FunctionDescriptor ogg_page_bos$descriptor() {
        return ogg_page_bos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * extern int ogg_page_bos(const ogg_page *og)
     * }
     */
    public static MethodHandle ogg_page_bos$handle() {
        return ogg_page_bos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * extern int ogg_page_bos(const ogg_page *og)
     * }
     */
    public static MemorySegment ogg_page_bos$address() {
        return ogg_page_bos.ADDR;
    }

    /**
     * {@snippet lang = c : * extern int ogg_page_bos(const ogg_page *og)
     * }
     */
    public static int ogg_page_bos(MemorySegment og) {
        var mh$ = ogg_page_bos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ogg_page_bos", og);
            }
            return (int) mh$.invokeExact(og);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ogg_page_eos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ogg_page_eos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * extern int ogg_page_eos(const ogg_page *og)
     * }
     */
    public static FunctionDescriptor ogg_page_eos$descriptor() {
        return ogg_page_eos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * extern int ogg_page_eos(const ogg_page *og)
     * }
     */
    public static MethodHandle ogg_page_eos$handle() {
        return ogg_page_eos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * extern int ogg_page_eos(const ogg_page *og)
     * }
     */
    public static MemorySegment ogg_page_eos$address() {
        return ogg_page_eos.ADDR;
    }

    /**
     * {@snippet lang = c : * extern int ogg_page_eos(const ogg_page *og)
     * }
     */
    public static int ogg_page_eos(MemorySegment og) {
        var mh$ = ogg_page_eos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ogg_page_eos", og);
            }
            return (int) mh$.invokeExact(og);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ogg_page_granulepos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ogg_page_granulepos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * extern ogg_int64_t ogg_page_granulepos(const ogg_page *og)
     * }
     */
    public static FunctionDescriptor ogg_page_granulepos$descriptor() {
        return ogg_page_granulepos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * extern ogg_int64_t ogg_page_granulepos(const ogg_page *og)
     * }
     */
    public static MethodHandle ogg_page_granulepos$handle() {
        return ogg_page_granulepos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * extern ogg_int64_t ogg_page_granulepos(const ogg_page *og)
     * }
     */
    public static MemorySegment ogg_page_granulepos$address() {
        return ogg_page_granulepos.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * extern ogg_int64_t ogg_page_granulepos(const ogg_page *og)
     * }
     */
    public static long ogg_page_granulepos(MemorySegment og) {
        var mh$ = ogg_page_granulepos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ogg_page_granulepos", og);
            }
            return (long) mh$.invokeExact(og);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ogg_page_serialno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ogg_page_serialno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * extern int ogg_page_serialno(const ogg_page *og)
     * }
     */
    public static FunctionDescriptor ogg_page_serialno$descriptor() {
        return ogg_page_serialno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * extern int ogg_page_serialno(const ogg_page *og)
     * }
     */
    public static MethodHandle ogg_page_serialno$handle() {
        return ogg_page_serialno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * extern int ogg_page_serialno(const ogg_page *og)
     * }
     */
    public static MemorySegment ogg_page_serialno$address() {
        return ogg_page_serialno.ADDR;
    }

    /**
     * {@snippet lang = c : * extern int ogg_page_serialno(const ogg_page *og)
     * }
     */
    public static int ogg_page_serialno(MemorySegment og) {
        var mh$ = ogg_page_serialno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ogg_page_serialno", og);
            }
            return (int) mh$.invokeExact(og);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ogg_page_pageno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_LONG,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ogg_page_pageno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * extern long ogg_page_pageno(const ogg_page *og)
     * }
     */
    public static FunctionDescriptor ogg_page_pageno$descriptor() {
        return ogg_page_pageno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * extern long ogg_page_pageno(const ogg_page *og)
     * }
     */
    public static MethodHandle ogg_page_pageno$handle() {
        return ogg_page_pageno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * extern long ogg_page_pageno(const ogg_page *og)
     * }
     */
    public static MemorySegment ogg_page_pageno$address() {
        return ogg_page_pageno.ADDR;
    }

    /**
     * {@snippet lang = c : * extern long ogg_page_pageno(const ogg_page *og)
     * }
     */
    public static int ogg_page_pageno(MemorySegment og) {
        var mh$ = ogg_page_pageno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ogg_page_pageno", og);
            }
            return (int) mh$.invokeExact(og);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ogg_page_packets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ogg_page_packets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * extern int ogg_page_packets(const ogg_page *og)
     * }
     */
    public static FunctionDescriptor ogg_page_packets$descriptor() {
        return ogg_page_packets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * extern int ogg_page_packets(const ogg_page *og)
     * }
     */
    public static MethodHandle ogg_page_packets$handle() {
        return ogg_page_packets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * extern int ogg_page_packets(const ogg_page *og)
     * }
     */
    public static MemorySegment ogg_page_packets$address() {
        return ogg_page_packets.ADDR;
    }

    /**
     * {@snippet lang = c : * extern int ogg_page_packets(const ogg_page *og)
     * }
     */
    public static int ogg_page_packets(MemorySegment og) {
        var mh$ = ogg_page_packets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ogg_page_packets", og);
            }
            return (int) mh$.invokeExact(og);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ogg_packet_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ogg_packet_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * extern void ogg_packet_clear(ogg_packet *op)
     * }
     */
    public static FunctionDescriptor ogg_packet_clear$descriptor() {
        return ogg_packet_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * extern void ogg_packet_clear(ogg_packet *op)
     * }
     */
    public static MethodHandle ogg_packet_clear$handle() {
        return ogg_packet_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * extern void ogg_packet_clear(ogg_packet *op)
     * }
     */
    public static MemorySegment ogg_packet_clear$address() {
        return ogg_packet_clear.ADDR;
    }

    /**
     * {@snippet lang = c : * extern void ogg_packet_clear(ogg_packet *op)
     * }
     */
    public static void ogg_packet_clear(MemorySegment op) {
        var mh$ = ogg_packet_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ogg_packet_clear", op);
            }
            mh$.invokeExact(op);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * {@snippet lang = c : * typedef int opus_int32
     * }
     */
    public static final OfInt opus_int32 = opusfile_h.C_INT;
    /**
     * {@snippet lang = c : * typedef unsigned int opus_uint32
     * }
     */
    public static final OfInt opus_uint32 = opusfile_h.C_INT;
    /**
     * {@snippet lang = c : * typedef short opus_int16
     * }
     */
    public static final OfShort opus_int16 = opusfile_h.C_SHORT;
    /**
     * {@snippet lang = c : * typedef unsigned short opus_uint16
     * }
     */
    public static final OfShort opus_uint16 = opusfile_h.C_SHORT;

    private static class opus_strerror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_strerror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * const char *opus_strerror(int error)
     * }
     */
    public static FunctionDescriptor opus_strerror$descriptor() {
        return opus_strerror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * const char *opus_strerror(int error)
     * }
     */
    public static MethodHandle opus_strerror$handle() {
        return opus_strerror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * const char *opus_strerror(int error)
     * }
     */
    public static MemorySegment opus_strerror$address() {
        return opus_strerror.ADDR;
    }

    /**
     * {@snippet lang = c : * const char *opus_strerror(int error)
     * }
     */
    public static MemorySegment opus_strerror(int error) {
        var mh$ = opus_strerror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_strerror", error);
            }
            return (MemorySegment) mh$.invokeExact(error);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_get_version_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_get_version_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * const char *opus_get_version_string()
     * }
     */
    public static FunctionDescriptor opus_get_version_string$descriptor() {
        return opus_get_version_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * const char *opus_get_version_string()
     * }
     */
    public static MethodHandle opus_get_version_string$handle() {
        return opus_get_version_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * const char *opus_get_version_string()
     * }
     */
    public static MemorySegment opus_get_version_string$address() {
        return opus_get_version_string.ADDR;
    }

    /**
     * {@snippet lang = c : * const char *opus_get_version_string()
     * }
     */
    public static MemorySegment opus_get_version_string() {
        var mh$ = opus_get_version_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_get_version_string");
            }
            return (MemorySegment) mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_encoder_get_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_encoder_get_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int opus_encoder_get_size(int channels)
     * }
     */
    public static FunctionDescriptor opus_encoder_get_size$descriptor() {
        return opus_encoder_get_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int opus_encoder_get_size(int channels)
     * }
     */
    public static MethodHandle opus_encoder_get_size$handle() {
        return opus_encoder_get_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int opus_encoder_get_size(int channels)
     * }
     */
    public static MemorySegment opus_encoder_get_size$address() {
        return opus_encoder_get_size.ADDR;
    }

    /**
     * {@snippet lang = c : * int opus_encoder_get_size(int channels)
     * }
     */
    public static int opus_encoder_get_size(int channels) {
        var mh$ = opus_encoder_get_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_encoder_get_size", channels);
            }
            return (int) mh$.invokeExact(channels);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_encoder_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_INT,
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_encoder_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * OpusEncoder *opus_encoder_create(opus_int32 Fs, int channels, int application, int *error)
     * }
     */
    public static FunctionDescriptor opus_encoder_create$descriptor() {
        return opus_encoder_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * OpusEncoder *opus_encoder_create(opus_int32 Fs, int channels, int application, int *error)
     * }
     */
    public static MethodHandle opus_encoder_create$handle() {
        return opus_encoder_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * OpusEncoder *opus_encoder_create(opus_int32 Fs, int channels, int application, int *error)
     * }
     */
    public static MemorySegment opus_encoder_create$address() {
        return opus_encoder_create.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * OpusEncoder *opus_encoder_create(opus_int32 Fs, int channels, int application, int *error)
     * }
     */
    public static MemorySegment opus_encoder_create(int Fs, int channels, int application, MemorySegment error) {
        var mh$ = opus_encoder_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_encoder_create", Fs, channels, application, error);
            }
            return (MemorySegment) mh$.invokeExact(Fs, channels, application, error);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_encoder_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_INT,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_encoder_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int opus_encoder_init(OpusEncoder *st, opus_int32 Fs, int channels, int application)
     * }
     */
    public static FunctionDescriptor opus_encoder_init$descriptor() {
        return opus_encoder_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int opus_encoder_init(OpusEncoder *st, opus_int32 Fs, int channels, int application)
     * }
     */
    public static MethodHandle opus_encoder_init$handle() {
        return opus_encoder_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int opus_encoder_init(OpusEncoder *st, opus_int32 Fs, int channels, int application)
     * }
     */
    public static MemorySegment opus_encoder_init$address() {
        return opus_encoder_init.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int opus_encoder_init(OpusEncoder *st, opus_int32 Fs, int channels, int application)
     * }
     */
    public static int opus_encoder_init(MemorySegment st, int Fs, int channels, int application) {
        var mh$ = opus_encoder_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_encoder_init", st, Fs, channels, application);
            }
            return (int) mh$.invokeExact(st, Fs, channels, application);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_encode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_encode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * opus_int32 opus_encode(OpusEncoder *st, const opus_int16 *pcm, int frame_size, unsigned char *data, opus_int32 max_data_bytes)
     * }
     */
    public static FunctionDescriptor opus_encode$descriptor() {
        return opus_encode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * opus_int32 opus_encode(OpusEncoder *st, const opus_int16 *pcm, int frame_size, unsigned char *data, opus_int32 max_data_bytes)
     * }
     */
    public static MethodHandle opus_encode$handle() {
        return opus_encode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * opus_int32 opus_encode(OpusEncoder *st, const opus_int16 *pcm, int frame_size, unsigned char *data, opus_int32 max_data_bytes)
     * }
     */
    public static MemorySegment opus_encode$address() {
        return opus_encode.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * opus_int32 opus_encode(OpusEncoder *st, const opus_int16 *pcm, int frame_size, unsigned char *data, opus_int32 max_data_bytes)
     * }
     */
    public static int opus_encode(MemorySegment st, MemorySegment pcm, int frame_size, MemorySegment data,
            int max_data_bytes) {
        var mh$ = opus_encode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_encode", st, pcm, frame_size, data, max_data_bytes);
            }
            return (int) mh$.invokeExact(st, pcm, frame_size, data, max_data_bytes);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_encode24 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_encode24");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * opus_int32 opus_encode24(OpusEncoder *st, const opus_int32 *pcm, int frame_size, unsigned char *data, opus_int32 max_data_bytes)
     * }
     */
    public static FunctionDescriptor opus_encode24$descriptor() {
        return opus_encode24.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * opus_int32 opus_encode24(OpusEncoder *st, const opus_int32 *pcm, int frame_size, unsigned char *data, opus_int32 max_data_bytes)
     * }
     */
    public static MethodHandle opus_encode24$handle() {
        return opus_encode24.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * opus_int32 opus_encode24(OpusEncoder *st, const opus_int32 *pcm, int frame_size, unsigned char *data, opus_int32 max_data_bytes)
     * }
     */
    public static MemorySegment opus_encode24$address() {
        return opus_encode24.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * opus_int32 opus_encode24(OpusEncoder *st, const opus_int32 *pcm, int frame_size, unsigned char *data, opus_int32 max_data_bytes)
     * }
     */
    public static int opus_encode24(MemorySegment st, MemorySegment pcm, int frame_size, MemorySegment data,
            int max_data_bytes) {
        var mh$ = opus_encode24.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_encode24", st, pcm, frame_size, data, max_data_bytes);
            }
            return (int) mh$.invokeExact(st, pcm, frame_size, data, max_data_bytes);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_encode_float {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_encode_float");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * opus_int32 opus_encode_float(OpusEncoder *st, const float *pcm, int frame_size, unsigned char *data, opus_int32 max_data_bytes)
     * }
     */
    public static FunctionDescriptor opus_encode_float$descriptor() {
        return opus_encode_float.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * opus_int32 opus_encode_float(OpusEncoder *st, const float *pcm, int frame_size, unsigned char *data, opus_int32 max_data_bytes)
     * }
     */
    public static MethodHandle opus_encode_float$handle() {
        return opus_encode_float.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * opus_int32 opus_encode_float(OpusEncoder *st, const float *pcm, int frame_size, unsigned char *data, opus_int32 max_data_bytes)
     * }
     */
    public static MemorySegment opus_encode_float$address() {
        return opus_encode_float.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * opus_int32 opus_encode_float(OpusEncoder *st, const float *pcm, int frame_size, unsigned char *data, opus_int32 max_data_bytes)
     * }
     */
    public static int opus_encode_float(MemorySegment st, MemorySegment pcm, int frame_size, MemorySegment data,
            int max_data_bytes) {
        var mh$ = opus_encode_float.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_encode_float", st, pcm, frame_size, data, max_data_bytes);
            }
            return (int) mh$.invokeExact(st, pcm, frame_size, data, max_data_bytes);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_encoder_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_encoder_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * void opus_encoder_destroy(OpusEncoder *st)
     * }
     */
    public static FunctionDescriptor opus_encoder_destroy$descriptor() {
        return opus_encoder_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * void opus_encoder_destroy(OpusEncoder *st)
     * }
     */
    public static MethodHandle opus_encoder_destroy$handle() {
        return opus_encoder_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * void opus_encoder_destroy(OpusEncoder *st)
     * }
     */
    public static MemorySegment opus_encoder_destroy$address() {
        return opus_encoder_destroy.ADDR;
    }

    /**
     * {@snippet lang = c : * void opus_encoder_destroy(OpusEncoder *st)
     * }
     */
    public static void opus_encoder_destroy(MemorySegment st) {
        var mh$ = opus_encoder_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_encoder_destroy", st);
            }
            mh$.invokeExact(st);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang = c
     * : * int opus_encoder_ctl(OpusEncoder *st, int request, ...)
     * }
     */
    public static class opus_encoder_ctl {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_encoder_ctl");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private opus_encoder_ctl(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang = c
         * : * int opus_encoder_ctl(OpusEncoder *st, int request, ...)
         * }
         */
        public static opus_encoder_ctl makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new opus_encoder_ctl(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment st, int request, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("opus_encoder_ctl", st, request, x2);
                }
                return (int) spreader.invokeExact(st, request, x2);
            } catch (IllegalArgumentException | ClassCastException ex$) {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class opus_decoder_get_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_decoder_get_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int opus_decoder_get_size(int channels)
     * }
     */
    public static FunctionDescriptor opus_decoder_get_size$descriptor() {
        return opus_decoder_get_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int opus_decoder_get_size(int channels)
     * }
     */
    public static MethodHandle opus_decoder_get_size$handle() {
        return opus_decoder_get_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int opus_decoder_get_size(int channels)
     * }
     */
    public static MemorySegment opus_decoder_get_size$address() {
        return opus_decoder_get_size.ADDR;
    }

    /**
     * {@snippet lang = c : * int opus_decoder_get_size(int channels)
     * }
     */
    public static int opus_decoder_get_size(int channels) {
        var mh$ = opus_decoder_get_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_decoder_get_size", channels);
            }
            return (int) mh$.invokeExact(channels);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_decoder_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_decoder_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * OpusDecoder *opus_decoder_create(opus_int32 Fs, int channels, int *error)
     * }
     */
    public static FunctionDescriptor opus_decoder_create$descriptor() {
        return opus_decoder_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * OpusDecoder *opus_decoder_create(opus_int32 Fs, int channels, int *error)
     * }
     */
    public static MethodHandle opus_decoder_create$handle() {
        return opus_decoder_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * OpusDecoder *opus_decoder_create(opus_int32 Fs, int channels, int *error)
     * }
     */
    public static MemorySegment opus_decoder_create$address() {
        return opus_decoder_create.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * OpusDecoder *opus_decoder_create(opus_int32 Fs, int channels, int *error)
     * }
     */
    public static MemorySegment opus_decoder_create(int Fs, int channels, MemorySegment error) {
        var mh$ = opus_decoder_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_decoder_create", Fs, channels, error);
            }
            return (MemorySegment) mh$.invokeExact(Fs, channels, error);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_decoder_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_decoder_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int opus_decoder_init(OpusDecoder *st, opus_int32 Fs, int channels)
     * }
     */
    public static FunctionDescriptor opus_decoder_init$descriptor() {
        return opus_decoder_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int opus_decoder_init(OpusDecoder *st, opus_int32 Fs, int channels)
     * }
     */
    public static MethodHandle opus_decoder_init$handle() {
        return opus_decoder_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int opus_decoder_init(OpusDecoder *st, opus_int32 Fs, int channels)
     * }
     */
    public static MemorySegment opus_decoder_init$address() {
        return opus_decoder_init.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int opus_decoder_init(OpusDecoder *st, opus_int32 Fs, int channels)
     * }
     */
    public static int opus_decoder_init(MemorySegment st, int Fs, int channels) {
        var mh$ = opus_decoder_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_decoder_init", st, Fs, channels);
            }
            return (int) mh$.invokeExact(st, Fs, channels);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_decode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_decode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int opus_decode(OpusDecoder *st, const unsigned char *data, opus_int32 len, opus_int16 *pcm, int frame_size, int decode_fec)
     * }
     */
    public static FunctionDescriptor opus_decode$descriptor() {
        return opus_decode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int opus_decode(OpusDecoder *st, const unsigned char *data, opus_int32 len, opus_int16 *pcm, int frame_size, int decode_fec)
     * }
     */
    public static MethodHandle opus_decode$handle() {
        return opus_decode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int opus_decode(OpusDecoder *st, const unsigned char *data, opus_int32 len, opus_int16 *pcm, int frame_size, int decode_fec)
     * }
     */
    public static MemorySegment opus_decode$address() {
        return opus_decode.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int opus_decode(OpusDecoder *st, const unsigned char *data, opus_int32 len, opus_int16 *pcm, int frame_size, int decode_fec)
     * }
     */
    public static int opus_decode(MemorySegment st, MemorySegment data, int len, MemorySegment pcm, int frame_size,
            int decode_fec) {
        var mh$ = opus_decode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_decode", st, data, len, pcm, frame_size, decode_fec);
            }
            return (int) mh$.invokeExact(st, data, len, pcm, frame_size, decode_fec);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_decode24 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_decode24");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int opus_decode24(OpusDecoder *st, const unsigned char *data, opus_int32 len, opus_int32 *pcm, int frame_size, int decode_fec)
     * }
     */
    public static FunctionDescriptor opus_decode24$descriptor() {
        return opus_decode24.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int opus_decode24(OpusDecoder *st, const unsigned char *data, opus_int32 len, opus_int32 *pcm, int frame_size, int decode_fec)
     * }
     */
    public static MethodHandle opus_decode24$handle() {
        return opus_decode24.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int opus_decode24(OpusDecoder *st, const unsigned char *data, opus_int32 len, opus_int32 *pcm, int frame_size, int decode_fec)
     * }
     */
    public static MemorySegment opus_decode24$address() {
        return opus_decode24.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int opus_decode24(OpusDecoder *st, const unsigned char *data, opus_int32 len, opus_int32 *pcm, int frame_size, int decode_fec)
     * }
     */
    public static int opus_decode24(MemorySegment st, MemorySegment data, int len, MemorySegment pcm, int frame_size,
            int decode_fec) {
        var mh$ = opus_decode24.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_decode24", st, data, len, pcm, frame_size, decode_fec);
            }
            return (int) mh$.invokeExact(st, data, len, pcm, frame_size, decode_fec);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_decode_float {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_decode_float");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int opus_decode_float(OpusDecoder *st, const unsigned char *data, opus_int32 len, float *pcm, int frame_size, int decode_fec)
     * }
     */
    public static FunctionDescriptor opus_decode_float$descriptor() {
        return opus_decode_float.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int opus_decode_float(OpusDecoder *st, const unsigned char *data, opus_int32 len, float *pcm, int frame_size, int decode_fec)
     * }
     */
    public static MethodHandle opus_decode_float$handle() {
        return opus_decode_float.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int opus_decode_float(OpusDecoder *st, const unsigned char *data, opus_int32 len, float *pcm, int frame_size, int decode_fec)
     * }
     */
    public static MemorySegment opus_decode_float$address() {
        return opus_decode_float.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int opus_decode_float(OpusDecoder *st, const unsigned char *data, opus_int32 len, float *pcm, int frame_size, int decode_fec)
     * }
     */
    public static int opus_decode_float(MemorySegment st, MemorySegment data, int len, MemorySegment pcm,
            int frame_size, int decode_fec) {
        var mh$ = opus_decode_float.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_decode_float", st, data, len, pcm, frame_size, decode_fec);
            }
            return (int) mh$.invokeExact(st, data, len, pcm, frame_size, decode_fec);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang = c
     * : * int opus_decoder_ctl(OpusDecoder *st, int request, ...)
     * }
     */
    public static class opus_decoder_ctl {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_decoder_ctl");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private opus_decoder_ctl(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang = c
         * : * int opus_decoder_ctl(OpusDecoder *st, int request, ...)
         * }
         */
        public static opus_decoder_ctl makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new opus_decoder_ctl(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment st, int request, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("opus_decoder_ctl", st, request, x2);
                }
                return (int) spreader.invokeExact(st, request, x2);
            } catch (IllegalArgumentException | ClassCastException ex$) {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class opus_decoder_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_decoder_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * void opus_decoder_destroy(OpusDecoder *st)
     * }
     */
    public static FunctionDescriptor opus_decoder_destroy$descriptor() {
        return opus_decoder_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * void opus_decoder_destroy(OpusDecoder *st)
     * }
     */
    public static MethodHandle opus_decoder_destroy$handle() {
        return opus_decoder_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * void opus_decoder_destroy(OpusDecoder *st)
     * }
     */
    public static MemorySegment opus_decoder_destroy$address() {
        return opus_decoder_destroy.ADDR;
    }

    /**
     * {@snippet lang = c : * void opus_decoder_destroy(OpusDecoder *st)
     * }
     */
    public static void opus_decoder_destroy(MemorySegment st) {
        var mh$ = opus_decoder_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_decoder_destroy", st);
            }
            mh$.invokeExact(st);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_dred_decoder_get_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_dred_decoder_get_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int opus_dred_decoder_get_size()
     * }
     */
    public static FunctionDescriptor opus_dred_decoder_get_size$descriptor() {
        return opus_dred_decoder_get_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int opus_dred_decoder_get_size()
     * }
     */
    public static MethodHandle opus_dred_decoder_get_size$handle() {
        return opus_dred_decoder_get_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int opus_dred_decoder_get_size()
     * }
     */
    public static MemorySegment opus_dred_decoder_get_size$address() {
        return opus_dred_decoder_get_size.ADDR;
    }

    /**
     * {@snippet lang = c : * int opus_dred_decoder_get_size()
     * }
     */
    public static int opus_dred_decoder_get_size() {
        var mh$ = opus_dred_decoder_get_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_dred_decoder_get_size");
            }
            return (int) mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_dred_decoder_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_dred_decoder_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * OpusDREDDecoder *opus_dred_decoder_create(int *error)
     * }
     */
    public static FunctionDescriptor opus_dred_decoder_create$descriptor() {
        return opus_dred_decoder_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * OpusDREDDecoder *opus_dred_decoder_create(int *error)
     * }
     */
    public static MethodHandle opus_dred_decoder_create$handle() {
        return opus_dred_decoder_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * OpusDREDDecoder *opus_dred_decoder_create(int *error)
     * }
     */
    public static MemorySegment opus_dred_decoder_create$address() {
        return opus_dred_decoder_create.ADDR;
    }

    /**
     * {@snippet lang = c : * OpusDREDDecoder *opus_dred_decoder_create(int *error)
     * }
     */
    public static MemorySegment opus_dred_decoder_create(MemorySegment error) {
        var mh$ = opus_dred_decoder_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_dred_decoder_create", error);
            }
            return (MemorySegment) mh$.invokeExact(error);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_dred_decoder_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_dred_decoder_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int opus_dred_decoder_init(OpusDREDDecoder *dec)
     * }
     */
    public static FunctionDescriptor opus_dred_decoder_init$descriptor() {
        return opus_dred_decoder_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int opus_dred_decoder_init(OpusDREDDecoder *dec)
     * }
     */
    public static MethodHandle opus_dred_decoder_init$handle() {
        return opus_dred_decoder_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int opus_dred_decoder_init(OpusDREDDecoder *dec)
     * }
     */
    public static MemorySegment opus_dred_decoder_init$address() {
        return opus_dred_decoder_init.ADDR;
    }

    /**
     * {@snippet lang = c : * int opus_dred_decoder_init(OpusDREDDecoder *dec)
     * }
     */
    public static int opus_dred_decoder_init(MemorySegment dec) {
        var mh$ = opus_dred_decoder_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_dred_decoder_init", dec);
            }
            return (int) mh$.invokeExact(dec);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_dred_decoder_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_dred_decoder_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * void opus_dred_decoder_destroy(OpusDREDDecoder *dec)
     * }
     */
    public static FunctionDescriptor opus_dred_decoder_destroy$descriptor() {
        return opus_dred_decoder_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * void opus_dred_decoder_destroy(OpusDREDDecoder *dec)
     * }
     */
    public static MethodHandle opus_dred_decoder_destroy$handle() {
        return opus_dred_decoder_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * void opus_dred_decoder_destroy(OpusDREDDecoder *dec)
     * }
     */
    public static MemorySegment opus_dred_decoder_destroy$address() {
        return opus_dred_decoder_destroy.ADDR;
    }

    /**
     * {@snippet lang = c : * void opus_dred_decoder_destroy(OpusDREDDecoder *dec)
     * }
     */
    public static void opus_dred_decoder_destroy(MemorySegment dec) {
        var mh$ = opus_dred_decoder_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_dred_decoder_destroy", dec);
            }
            mh$.invokeExact(dec);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang = c
     * : * int opus_dred_decoder_ctl(OpusDREDDecoder *dred_dec, int request, ...)
     * }
     */
    public static class opus_dred_decoder_ctl {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_dred_decoder_ctl");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private opus_dred_decoder_ctl(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang = c
         * : * int opus_dred_decoder_ctl(OpusDREDDecoder *dred_dec, int request, ...)
         * }
         */
        public static opus_dred_decoder_ctl makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new opus_dred_decoder_ctl(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment dred_dec, int request, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("opus_dred_decoder_ctl", dred_dec, request, x2);
                }
                return (int) spreader.invokeExact(dred_dec, request, x2);
            } catch (IllegalArgumentException | ClassCastException ex$) {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class opus_dred_get_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_dred_get_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int opus_dred_get_size()
     * }
     */
    public static FunctionDescriptor opus_dred_get_size$descriptor() {
        return opus_dred_get_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int opus_dred_get_size()
     * }
     */
    public static MethodHandle opus_dred_get_size$handle() {
        return opus_dred_get_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int opus_dred_get_size()
     * }
     */
    public static MemorySegment opus_dred_get_size$address() {
        return opus_dred_get_size.ADDR;
    }

    /**
     * {@snippet lang = c : * int opus_dred_get_size()
     * }
     */
    public static int opus_dred_get_size() {
        var mh$ = opus_dred_get_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_dred_get_size");
            }
            return (int) mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_dred_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_dred_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * OpusDRED *opus_dred_alloc(int *error)
     * }
     */
    public static FunctionDescriptor opus_dred_alloc$descriptor() {
        return opus_dred_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * OpusDRED *opus_dred_alloc(int *error)
     * }
     */
    public static MethodHandle opus_dred_alloc$handle() {
        return opus_dred_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * OpusDRED *opus_dred_alloc(int *error)
     * }
     */
    public static MemorySegment opus_dred_alloc$address() {
        return opus_dred_alloc.ADDR;
    }

    /**
     * {@snippet lang = c : * OpusDRED *opus_dred_alloc(int *error)
     * }
     */
    public static MemorySegment opus_dred_alloc(MemorySegment error) {
        var mh$ = opus_dred_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_dred_alloc", error);
            }
            return (MemorySegment) mh$.invokeExact(error);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_dred_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_dred_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * void opus_dred_free(OpusDRED *dec)
     * }
     */
    public static FunctionDescriptor opus_dred_free$descriptor() {
        return opus_dred_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * void opus_dred_free(OpusDRED *dec)
     * }
     */
    public static MethodHandle opus_dred_free$handle() {
        return opus_dred_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * void opus_dred_free(OpusDRED *dec)
     * }
     */
    public static MemorySegment opus_dred_free$address() {
        return opus_dred_free.ADDR;
    }

    /**
     * {@snippet lang = c : * void opus_dred_free(OpusDRED *dec)
     * }
     */
    public static void opus_dred_free(MemorySegment dec) {
        var mh$ = opus_dred_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_dred_free", dec);
            }
            mh$.invokeExact(dec);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_dred_parse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_INT,
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_dred_parse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int opus_dred_parse(OpusDREDDecoder *dred_dec, OpusDRED *dred, const unsigned char *data, opus_int32 len, opus_int32 max_dred_samples, opus_int32 sampling_rate, int *dred_end, int defer_processing)
     * }
     */
    public static FunctionDescriptor opus_dred_parse$descriptor() {
        return opus_dred_parse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int opus_dred_parse(OpusDREDDecoder *dred_dec, OpusDRED *dred, const unsigned char *data, opus_int32 len, opus_int32 max_dred_samples, opus_int32 sampling_rate, int *dred_end, int defer_processing)
     * }
     */
    public static MethodHandle opus_dred_parse$handle() {
        return opus_dred_parse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int opus_dred_parse(OpusDREDDecoder *dred_dec, OpusDRED *dred, const unsigned char *data, opus_int32 len, opus_int32 max_dred_samples, opus_int32 sampling_rate, int *dred_end, int defer_processing)
     * }
     */
    public static MemorySegment opus_dred_parse$address() {
        return opus_dred_parse.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int opus_dred_parse(OpusDREDDecoder *dred_dec, OpusDRED *dred, const unsigned char *data, opus_int32 len, opus_int32 max_dred_samples, opus_int32 sampling_rate, int *dred_end, int defer_processing)
     * }
     */
    public static int opus_dred_parse(MemorySegment dred_dec, MemorySegment dred, MemorySegment data, int len,
            int max_dred_samples, int sampling_rate, MemorySegment dred_end, int defer_processing) {
        var mh$ = opus_dred_parse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_dred_parse", dred_dec, dred, data, len, max_dred_samples, sampling_rate, dred_end,
                        defer_processing);
            }
            return (int) mh$.invokeExact(dred_dec, dred, data, len, max_dred_samples, sampling_rate, dred_end,
                    defer_processing);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_dred_process {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_dred_process");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int opus_dred_process(OpusDREDDecoder *dred_dec, const OpusDRED *src, OpusDRED *dst)
     * }
     */
    public static FunctionDescriptor opus_dred_process$descriptor() {
        return opus_dred_process.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int opus_dred_process(OpusDREDDecoder *dred_dec, const OpusDRED *src, OpusDRED *dst)
     * }
     */
    public static MethodHandle opus_dred_process$handle() {
        return opus_dred_process.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int opus_dred_process(OpusDREDDecoder *dred_dec, const OpusDRED *src, OpusDRED *dst)
     * }
     */
    public static MemorySegment opus_dred_process$address() {
        return opus_dred_process.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int opus_dred_process(OpusDREDDecoder *dred_dec, const OpusDRED *src, OpusDRED *dst)
     * }
     */
    public static int opus_dred_process(MemorySegment dred_dec, MemorySegment src, MemorySegment dst) {
        var mh$ = opus_dred_process.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_dred_process", dred_dec, src, dst);
            }
            return (int) mh$.invokeExact(dred_dec, src, dst);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_decoder_dred_decode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_decoder_dred_decode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int opus_decoder_dred_decode(OpusDecoder *st, const OpusDRED *dred, opus_int32 dred_offset, opus_int16 *pcm, opus_int32 frame_size)
     * }
     */
    public static FunctionDescriptor opus_decoder_dred_decode$descriptor() {
        return opus_decoder_dred_decode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int opus_decoder_dred_decode(OpusDecoder *st, const OpusDRED *dred, opus_int32 dred_offset, opus_int16 *pcm, opus_int32 frame_size)
     * }
     */
    public static MethodHandle opus_decoder_dred_decode$handle() {
        return opus_decoder_dred_decode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int opus_decoder_dred_decode(OpusDecoder *st, const OpusDRED *dred, opus_int32 dred_offset, opus_int16 *pcm, opus_int32 frame_size)
     * }
     */
    public static MemorySegment opus_decoder_dred_decode$address() {
        return opus_decoder_dred_decode.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int opus_decoder_dred_decode(OpusDecoder *st, const OpusDRED *dred, opus_int32 dred_offset, opus_int16 *pcm, opus_int32 frame_size)
     * }
     */
    public static int opus_decoder_dred_decode(MemorySegment st, MemorySegment dred, int dred_offset, MemorySegment pcm,
            int frame_size) {
        var mh$ = opus_decoder_dred_decode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_decoder_dred_decode", st, dred, dred_offset, pcm, frame_size);
            }
            return (int) mh$.invokeExact(st, dred, dred_offset, pcm, frame_size);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_decoder_dred_decode24 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_decoder_dred_decode24");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int opus_decoder_dred_decode24(OpusDecoder *st, const OpusDRED *dred, opus_int32 dred_offset, opus_int32 *pcm, opus_int32 frame_size)
     * }
     */
    public static FunctionDescriptor opus_decoder_dred_decode24$descriptor() {
        return opus_decoder_dred_decode24.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int opus_decoder_dred_decode24(OpusDecoder *st, const OpusDRED *dred, opus_int32 dred_offset, opus_int32 *pcm, opus_int32 frame_size)
     * }
     */
    public static MethodHandle opus_decoder_dred_decode24$handle() {
        return opus_decoder_dred_decode24.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int opus_decoder_dred_decode24(OpusDecoder *st, const OpusDRED *dred, opus_int32 dred_offset, opus_int32 *pcm, opus_int32 frame_size)
     * }
     */
    public static MemorySegment opus_decoder_dred_decode24$address() {
        return opus_decoder_dred_decode24.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int opus_decoder_dred_decode24(OpusDecoder *st, const OpusDRED *dred, opus_int32 dred_offset, opus_int32 *pcm, opus_int32 frame_size)
     * }
     */
    public static int opus_decoder_dred_decode24(MemorySegment st, MemorySegment dred, int dred_offset,
            MemorySegment pcm, int frame_size) {
        var mh$ = opus_decoder_dred_decode24.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_decoder_dred_decode24", st, dred, dred_offset, pcm, frame_size);
            }
            return (int) mh$.invokeExact(st, dred, dred_offset, pcm, frame_size);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_decoder_dred_decode_float {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_decoder_dred_decode_float");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int opus_decoder_dred_decode_float(OpusDecoder *st, const OpusDRED *dred, opus_int32 dred_offset, float *pcm, opus_int32 frame_size)
     * }
     */
    public static FunctionDescriptor opus_decoder_dred_decode_float$descriptor() {
        return opus_decoder_dred_decode_float.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int opus_decoder_dred_decode_float(OpusDecoder *st, const OpusDRED *dred, opus_int32 dred_offset, float *pcm, opus_int32 frame_size)
     * }
     */
    public static MethodHandle opus_decoder_dred_decode_float$handle() {
        return opus_decoder_dred_decode_float.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int opus_decoder_dred_decode_float(OpusDecoder *st, const OpusDRED *dred, opus_int32 dred_offset, float *pcm, opus_int32 frame_size)
     * }
     */
    public static MemorySegment opus_decoder_dred_decode_float$address() {
        return opus_decoder_dred_decode_float.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int opus_decoder_dred_decode_float(OpusDecoder *st, const OpusDRED *dred, opus_int32 dred_offset, float *pcm, opus_int32 frame_size)
     * }
     */
    public static int opus_decoder_dred_decode_float(MemorySegment st, MemorySegment dred, int dred_offset,
            MemorySegment pcm, int frame_size) {
        var mh$ = opus_decoder_dred_decode_float.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_decoder_dred_decode_float", st, dred, dred_offset, pcm, frame_size);
            }
            return (int) mh$.invokeExact(st, dred, dred_offset, pcm, frame_size);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_packet_parse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_packet_parse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int opus_packet_parse(const unsigned char *data, opus_int32 len, unsigned char *out_toc, const unsigned char *frames[48], opus_int16 size[48], int *payload_offset)
     * }
     */
    public static FunctionDescriptor opus_packet_parse$descriptor() {
        return opus_packet_parse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int opus_packet_parse(const unsigned char *data, opus_int32 len, unsigned char *out_toc, const unsigned char *frames[48], opus_int16 size[48], int *payload_offset)
     * }
     */
    public static MethodHandle opus_packet_parse$handle() {
        return opus_packet_parse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int opus_packet_parse(const unsigned char *data, opus_int32 len, unsigned char *out_toc, const unsigned char *frames[48], opus_int16 size[48], int *payload_offset)
     * }
     */
    public static MemorySegment opus_packet_parse$address() {
        return opus_packet_parse.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int opus_packet_parse(const unsigned char *data, opus_int32 len, unsigned char *out_toc, const unsigned char *frames[48], opus_int16 size[48], int *payload_offset)
     * }
     */
    public static int opus_packet_parse(MemorySegment data, int len, MemorySegment out_toc, MemorySegment frames,
            MemorySegment size, MemorySegment payload_offset) {
        var mh$ = opus_packet_parse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_packet_parse", data, len, out_toc, frames, size, payload_offset);
            }
            return (int) mh$.invokeExact(data, len, out_toc, frames, size, payload_offset);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_packet_get_bandwidth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_packet_get_bandwidth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int opus_packet_get_bandwidth(const unsigned char *data)
     * }
     */
    public static FunctionDescriptor opus_packet_get_bandwidth$descriptor() {
        return opus_packet_get_bandwidth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int opus_packet_get_bandwidth(const unsigned char *data)
     * }
     */
    public static MethodHandle opus_packet_get_bandwidth$handle() {
        return opus_packet_get_bandwidth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int opus_packet_get_bandwidth(const unsigned char *data)
     * }
     */
    public static MemorySegment opus_packet_get_bandwidth$address() {
        return opus_packet_get_bandwidth.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int opus_packet_get_bandwidth(const unsigned char *data)
     * }
     */
    public static int opus_packet_get_bandwidth(MemorySegment data) {
        var mh$ = opus_packet_get_bandwidth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_packet_get_bandwidth", data);
            }
            return (int) mh$.invokeExact(data);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_packet_get_samples_per_frame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_packet_get_samples_per_frame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int opus_packet_get_samples_per_frame(const unsigned char *data, opus_int32 Fs)
     * }
     */
    public static FunctionDescriptor opus_packet_get_samples_per_frame$descriptor() {
        return opus_packet_get_samples_per_frame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int opus_packet_get_samples_per_frame(const unsigned char *data, opus_int32 Fs)
     * }
     */
    public static MethodHandle opus_packet_get_samples_per_frame$handle() {
        return opus_packet_get_samples_per_frame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int opus_packet_get_samples_per_frame(const unsigned char *data, opus_int32 Fs)
     * }
     */
    public static MemorySegment opus_packet_get_samples_per_frame$address() {
        return opus_packet_get_samples_per_frame.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int opus_packet_get_samples_per_frame(const unsigned char *data, opus_int32 Fs)
     * }
     */
    public static int opus_packet_get_samples_per_frame(MemorySegment data, int Fs) {
        var mh$ = opus_packet_get_samples_per_frame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_packet_get_samples_per_frame", data, Fs);
            }
            return (int) mh$.invokeExact(data, Fs);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_packet_get_nb_channels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_packet_get_nb_channels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int opus_packet_get_nb_channels(const unsigned char *data)
     * }
     */
    public static FunctionDescriptor opus_packet_get_nb_channels$descriptor() {
        return opus_packet_get_nb_channels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int opus_packet_get_nb_channels(const unsigned char *data)
     * }
     */
    public static MethodHandle opus_packet_get_nb_channels$handle() {
        return opus_packet_get_nb_channels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int opus_packet_get_nb_channels(const unsigned char *data)
     * }
     */
    public static MemorySegment opus_packet_get_nb_channels$address() {
        return opus_packet_get_nb_channels.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int opus_packet_get_nb_channels(const unsigned char *data)
     * }
     */
    public static int opus_packet_get_nb_channels(MemorySegment data) {
        var mh$ = opus_packet_get_nb_channels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_packet_get_nb_channels", data);
            }
            return (int) mh$.invokeExact(data);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_packet_get_nb_frames {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_packet_get_nb_frames");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int opus_packet_get_nb_frames(const unsigned char packet[], opus_int32 len)
     * }
     */
    public static FunctionDescriptor opus_packet_get_nb_frames$descriptor() {
        return opus_packet_get_nb_frames.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int opus_packet_get_nb_frames(const unsigned char packet[], opus_int32 len)
     * }
     */
    public static MethodHandle opus_packet_get_nb_frames$handle() {
        return opus_packet_get_nb_frames.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int opus_packet_get_nb_frames(const unsigned char packet[], opus_int32 len)
     * }
     */
    public static MemorySegment opus_packet_get_nb_frames$address() {
        return opus_packet_get_nb_frames.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int opus_packet_get_nb_frames(const unsigned char packet[], opus_int32 len)
     * }
     */
    public static int opus_packet_get_nb_frames(MemorySegment packet, int len) {
        var mh$ = opus_packet_get_nb_frames.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_packet_get_nb_frames", packet, len);
            }
            return (int) mh$.invokeExact(packet, len);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_packet_get_nb_samples {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_packet_get_nb_samples");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int opus_packet_get_nb_samples(const unsigned char packet[], opus_int32 len, opus_int32 Fs)
     * }
     */
    public static FunctionDescriptor opus_packet_get_nb_samples$descriptor() {
        return opus_packet_get_nb_samples.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int opus_packet_get_nb_samples(const unsigned char packet[], opus_int32 len, opus_int32 Fs)
     * }
     */
    public static MethodHandle opus_packet_get_nb_samples$handle() {
        return opus_packet_get_nb_samples.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int opus_packet_get_nb_samples(const unsigned char packet[], opus_int32 len, opus_int32 Fs)
     * }
     */
    public static MemorySegment opus_packet_get_nb_samples$address() {
        return opus_packet_get_nb_samples.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int opus_packet_get_nb_samples(const unsigned char packet[], opus_int32 len, opus_int32 Fs)
     * }
     */
    public static int opus_packet_get_nb_samples(MemorySegment packet, int len, int Fs) {
        var mh$ = opus_packet_get_nb_samples.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_packet_get_nb_samples", packet, len, Fs);
            }
            return (int) mh$.invokeExact(packet, len, Fs);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_packet_has_lbrr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_packet_has_lbrr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int opus_packet_has_lbrr(const unsigned char packet[], opus_int32 len)
     * }
     */
    public static FunctionDescriptor opus_packet_has_lbrr$descriptor() {
        return opus_packet_has_lbrr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int opus_packet_has_lbrr(const unsigned char packet[], opus_int32 len)
     * }
     */
    public static MethodHandle opus_packet_has_lbrr$handle() {
        return opus_packet_has_lbrr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int opus_packet_has_lbrr(const unsigned char packet[], opus_int32 len)
     * }
     */
    public static MemorySegment opus_packet_has_lbrr$address() {
        return opus_packet_has_lbrr.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int opus_packet_has_lbrr(const unsigned char packet[], opus_int32 len)
     * }
     */
    public static int opus_packet_has_lbrr(MemorySegment packet, int len) {
        var mh$ = opus_packet_has_lbrr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_packet_has_lbrr", packet, len);
            }
            return (int) mh$.invokeExact(packet, len);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_decoder_get_nb_samples {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_decoder_get_nb_samples");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int opus_decoder_get_nb_samples(const OpusDecoder *dec, const unsigned char packet[], opus_int32 len)
     * }
     */
    public static FunctionDescriptor opus_decoder_get_nb_samples$descriptor() {
        return opus_decoder_get_nb_samples.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int opus_decoder_get_nb_samples(const OpusDecoder *dec, const unsigned char packet[], opus_int32 len)
     * }
     */
    public static MethodHandle opus_decoder_get_nb_samples$handle() {
        return opus_decoder_get_nb_samples.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int opus_decoder_get_nb_samples(const OpusDecoder *dec, const unsigned char packet[], opus_int32 len)
     * }
     */
    public static MemorySegment opus_decoder_get_nb_samples$address() {
        return opus_decoder_get_nb_samples.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int opus_decoder_get_nb_samples(const OpusDecoder *dec, const unsigned char packet[], opus_int32 len)
     * }
     */
    public static int opus_decoder_get_nb_samples(MemorySegment dec, MemorySegment packet, int len) {
        var mh$ = opus_decoder_get_nb_samples.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_decoder_get_nb_samples", dec, packet, len);
            }
            return (int) mh$.invokeExact(dec, packet, len);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_pcm_soft_clip {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_pcm_soft_clip");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * void opus_pcm_soft_clip(float *pcm, int frame_size, int channels, float *softclip_mem)
     * }
     */
    public static FunctionDescriptor opus_pcm_soft_clip$descriptor() {
        return opus_pcm_soft_clip.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * void opus_pcm_soft_clip(float *pcm, int frame_size, int channels, float *softclip_mem)
     * }
     */
    public static MethodHandle opus_pcm_soft_clip$handle() {
        return opus_pcm_soft_clip.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * void opus_pcm_soft_clip(float *pcm, int frame_size, int channels, float *softclip_mem)
     * }
     */
    public static MemorySegment opus_pcm_soft_clip$address() {
        return opus_pcm_soft_clip.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * void opus_pcm_soft_clip(float *pcm, int frame_size, int channels, float *softclip_mem)
     * }
     */
    public static void opus_pcm_soft_clip(MemorySegment pcm, int frame_size, int channels, MemorySegment softclip_mem) {
        var mh$ = opus_pcm_soft_clip.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_pcm_soft_clip", pcm, frame_size, channels, softclip_mem);
            }
            mh$.invokeExact(pcm, frame_size, channels, softclip_mem);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_repacketizer_get_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_repacketizer_get_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int opus_repacketizer_get_size()
     * }
     */
    public static FunctionDescriptor opus_repacketizer_get_size$descriptor() {
        return opus_repacketizer_get_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int opus_repacketizer_get_size()
     * }
     */
    public static MethodHandle opus_repacketizer_get_size$handle() {
        return opus_repacketizer_get_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int opus_repacketizer_get_size()
     * }
     */
    public static MemorySegment opus_repacketizer_get_size$address() {
        return opus_repacketizer_get_size.ADDR;
    }

    /**
     * {@snippet lang = c : * int opus_repacketizer_get_size()
     * }
     */
    public static int opus_repacketizer_get_size() {
        var mh$ = opus_repacketizer_get_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_repacketizer_get_size");
            }
            return (int) mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_repacketizer_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_repacketizer_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * OpusRepacketizer *opus_repacketizer_init(OpusRepacketizer *rp)
     * }
     */
    public static FunctionDescriptor opus_repacketizer_init$descriptor() {
        return opus_repacketizer_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * OpusRepacketizer *opus_repacketizer_init(OpusRepacketizer *rp)
     * }
     */
    public static MethodHandle opus_repacketizer_init$handle() {
        return opus_repacketizer_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * OpusRepacketizer *opus_repacketizer_init(OpusRepacketizer *rp)
     * }
     */
    public static MemorySegment opus_repacketizer_init$address() {
        return opus_repacketizer_init.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * OpusRepacketizer *opus_repacketizer_init(OpusRepacketizer *rp)
     * }
     */
    public static MemorySegment opus_repacketizer_init(MemorySegment rp) {
        var mh$ = opus_repacketizer_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_repacketizer_init", rp);
            }
            return (MemorySegment) mh$.invokeExact(rp);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_repacketizer_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_repacketizer_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * OpusRepacketizer *opus_repacketizer_create()
     * }
     */
    public static FunctionDescriptor opus_repacketizer_create$descriptor() {
        return opus_repacketizer_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * OpusRepacketizer *opus_repacketizer_create()
     * }
     */
    public static MethodHandle opus_repacketizer_create$handle() {
        return opus_repacketizer_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * OpusRepacketizer *opus_repacketizer_create()
     * }
     */
    public static MemorySegment opus_repacketizer_create$address() {
        return opus_repacketizer_create.ADDR;
    }

    /**
     * {@snippet lang = c : * OpusRepacketizer *opus_repacketizer_create()
     * }
     */
    public static MemorySegment opus_repacketizer_create() {
        var mh$ = opus_repacketizer_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_repacketizer_create");
            }
            return (MemorySegment) mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_repacketizer_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_repacketizer_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * void opus_repacketizer_destroy(OpusRepacketizer *rp)
     * }
     */
    public static FunctionDescriptor opus_repacketizer_destroy$descriptor() {
        return opus_repacketizer_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * void opus_repacketizer_destroy(OpusRepacketizer *rp)
     * }
     */
    public static MethodHandle opus_repacketizer_destroy$handle() {
        return opus_repacketizer_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * void opus_repacketizer_destroy(OpusRepacketizer *rp)
     * }
     */
    public static MemorySegment opus_repacketizer_destroy$address() {
        return opus_repacketizer_destroy.ADDR;
    }

    /**
     * {@snippet lang = c : * void opus_repacketizer_destroy(OpusRepacketizer *rp)
     * }
     */
    public static void opus_repacketizer_destroy(MemorySegment rp) {
        var mh$ = opus_repacketizer_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_repacketizer_destroy", rp);
            }
            mh$.invokeExact(rp);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_repacketizer_cat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_repacketizer_cat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int opus_repacketizer_cat(OpusRepacketizer *rp, const unsigned char *data, opus_int32 len)
     * }
     */
    public static FunctionDescriptor opus_repacketizer_cat$descriptor() {
        return opus_repacketizer_cat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int opus_repacketizer_cat(OpusRepacketizer *rp, const unsigned char *data, opus_int32 len)
     * }
     */
    public static MethodHandle opus_repacketizer_cat$handle() {
        return opus_repacketizer_cat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int opus_repacketizer_cat(OpusRepacketizer *rp, const unsigned char *data, opus_int32 len)
     * }
     */
    public static MemorySegment opus_repacketizer_cat$address() {
        return opus_repacketizer_cat.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int opus_repacketizer_cat(OpusRepacketizer *rp, const unsigned char *data, opus_int32 len)
     * }
     */
    public static int opus_repacketizer_cat(MemorySegment rp, MemorySegment data, int len) {
        var mh$ = opus_repacketizer_cat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_repacketizer_cat", rp, data, len);
            }
            return (int) mh$.invokeExact(rp, data, len);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_repacketizer_out_range {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_repacketizer_out_range");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * opus_int32 opus_repacketizer_out_range(OpusRepacketizer *rp, int begin, int end, unsigned char *data, opus_int32 maxlen)
     * }
     */
    public static FunctionDescriptor opus_repacketizer_out_range$descriptor() {
        return opus_repacketizer_out_range.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * opus_int32 opus_repacketizer_out_range(OpusRepacketizer *rp, int begin, int end, unsigned char *data, opus_int32 maxlen)
     * }
     */
    public static MethodHandle opus_repacketizer_out_range$handle() {
        return opus_repacketizer_out_range.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * opus_int32 opus_repacketizer_out_range(OpusRepacketizer *rp, int begin, int end, unsigned char *data, opus_int32 maxlen)
     * }
     */
    public static MemorySegment opus_repacketizer_out_range$address() {
        return opus_repacketizer_out_range.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * opus_int32 opus_repacketizer_out_range(OpusRepacketizer *rp, int begin, int end, unsigned char *data, opus_int32 maxlen)
     * }
     */
    public static int opus_repacketizer_out_range(MemorySegment rp, int begin, int end, MemorySegment data,
            int maxlen) {
        var mh$ = opus_repacketizer_out_range.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_repacketizer_out_range", rp, begin, end, data, maxlen);
            }
            return (int) mh$.invokeExact(rp, begin, end, data, maxlen);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_repacketizer_get_nb_frames {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_repacketizer_get_nb_frames");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int opus_repacketizer_get_nb_frames(OpusRepacketizer *rp)
     * }
     */
    public static FunctionDescriptor opus_repacketizer_get_nb_frames$descriptor() {
        return opus_repacketizer_get_nb_frames.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int opus_repacketizer_get_nb_frames(OpusRepacketizer *rp)
     * }
     */
    public static MethodHandle opus_repacketizer_get_nb_frames$handle() {
        return opus_repacketizer_get_nb_frames.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int opus_repacketizer_get_nb_frames(OpusRepacketizer *rp)
     * }
     */
    public static MemorySegment opus_repacketizer_get_nb_frames$address() {
        return opus_repacketizer_get_nb_frames.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int opus_repacketizer_get_nb_frames(OpusRepacketizer *rp)
     * }
     */
    public static int opus_repacketizer_get_nb_frames(MemorySegment rp) {
        var mh$ = opus_repacketizer_get_nb_frames.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_repacketizer_get_nb_frames", rp);
            }
            return (int) mh$.invokeExact(rp);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_repacketizer_out {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_repacketizer_out");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * opus_int32 opus_repacketizer_out(OpusRepacketizer *rp, unsigned char *data, opus_int32 maxlen)
     * }
     */
    public static FunctionDescriptor opus_repacketizer_out$descriptor() {
        return opus_repacketizer_out.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * opus_int32 opus_repacketizer_out(OpusRepacketizer *rp, unsigned char *data, opus_int32 maxlen)
     * }
     */
    public static MethodHandle opus_repacketizer_out$handle() {
        return opus_repacketizer_out.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * opus_int32 opus_repacketizer_out(OpusRepacketizer *rp, unsigned char *data, opus_int32 maxlen)
     * }
     */
    public static MemorySegment opus_repacketizer_out$address() {
        return opus_repacketizer_out.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * opus_int32 opus_repacketizer_out(OpusRepacketizer *rp, unsigned char *data, opus_int32 maxlen)
     * }
     */
    public static int opus_repacketizer_out(MemorySegment rp, MemorySegment data, int maxlen) {
        var mh$ = opus_repacketizer_out.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_repacketizer_out", rp, data, maxlen);
            }
            return (int) mh$.invokeExact(rp, data, maxlen);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_packet_pad {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_packet_pad");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int opus_packet_pad(unsigned char *data, opus_int32 len, opus_int32 new_len)
     * }
     */
    public static FunctionDescriptor opus_packet_pad$descriptor() {
        return opus_packet_pad.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int opus_packet_pad(unsigned char *data, opus_int32 len, opus_int32 new_len)
     * }
     */
    public static MethodHandle opus_packet_pad$handle() {
        return opus_packet_pad.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int opus_packet_pad(unsigned char *data, opus_int32 len, opus_int32 new_len)
     * }
     */
    public static MemorySegment opus_packet_pad$address() {
        return opus_packet_pad.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int opus_packet_pad(unsigned char *data, opus_int32 len, opus_int32 new_len)
     * }
     */
    public static int opus_packet_pad(MemorySegment data, int len, int new_len) {
        var mh$ = opus_packet_pad.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_packet_pad", data, len, new_len);
            }
            return (int) mh$.invokeExact(data, len, new_len);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_packet_unpad {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_packet_unpad");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * opus_int32 opus_packet_unpad(unsigned char *data, opus_int32 len)
     * }
     */
    public static FunctionDescriptor opus_packet_unpad$descriptor() {
        return opus_packet_unpad.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * opus_int32 opus_packet_unpad(unsigned char *data, opus_int32 len)
     * }
     */
    public static MethodHandle opus_packet_unpad$handle() {
        return opus_packet_unpad.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * opus_int32 opus_packet_unpad(unsigned char *data, opus_int32 len)
     * }
     */
    public static MemorySegment opus_packet_unpad$address() {
        return opus_packet_unpad.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * opus_int32 opus_packet_unpad(unsigned char *data, opus_int32 len)
     * }
     */
    public static int opus_packet_unpad(MemorySegment data, int len) {
        var mh$ = opus_packet_unpad.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_packet_unpad", data, len);
            }
            return (int) mh$.invokeExact(data, len);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_multistream_packet_pad {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_INT,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_multistream_packet_pad");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int opus_multistream_packet_pad(unsigned char *data, opus_int32 len, opus_int32 new_len, int nb_streams)
     * }
     */
    public static FunctionDescriptor opus_multistream_packet_pad$descriptor() {
        return opus_multistream_packet_pad.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int opus_multistream_packet_pad(unsigned char *data, opus_int32 len, opus_int32 new_len, int nb_streams)
     * }
     */
    public static MethodHandle opus_multistream_packet_pad$handle() {
        return opus_multistream_packet_pad.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int opus_multistream_packet_pad(unsigned char *data, opus_int32 len, opus_int32 new_len, int nb_streams)
     * }
     */
    public static MemorySegment opus_multistream_packet_pad$address() {
        return opus_multistream_packet_pad.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int opus_multistream_packet_pad(unsigned char *data, opus_int32 len, opus_int32 new_len, int nb_streams)
     * }
     */
    public static int opus_multistream_packet_pad(MemorySegment data, int len, int new_len, int nb_streams) {
        var mh$ = opus_multistream_packet_pad.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_multistream_packet_pad", data, len, new_len, nb_streams);
            }
            return (int) mh$.invokeExact(data, len, new_len, nb_streams);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_multistream_packet_unpad {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_multistream_packet_unpad");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * opus_int32 opus_multistream_packet_unpad(unsigned char *data, opus_int32 len, int nb_streams)
     * }
     */
    public static FunctionDescriptor opus_multistream_packet_unpad$descriptor() {
        return opus_multistream_packet_unpad.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * opus_int32 opus_multistream_packet_unpad(unsigned char *data, opus_int32 len, int nb_streams)
     * }
     */
    public static MethodHandle opus_multistream_packet_unpad$handle() {
        return opus_multistream_packet_unpad.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * opus_int32 opus_multistream_packet_unpad(unsigned char *data, opus_int32 len, int nb_streams)
     * }
     */
    public static MemorySegment opus_multistream_packet_unpad$address() {
        return opus_multistream_packet_unpad.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * opus_int32 opus_multistream_packet_unpad(unsigned char *data, opus_int32 len, int nb_streams)
     * }
     */
    public static int opus_multistream_packet_unpad(MemorySegment data, int len, int nb_streams) {
        var mh$ = opus_multistream_packet_unpad.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_multistream_packet_unpad", data, len, nb_streams);
            }
            return (int) mh$.invokeExact(data, len, nb_streams);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_multistream_encoder_get_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_INT,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_multistream_encoder_get_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * opus_int32 opus_multistream_encoder_get_size(int streams, int coupled_streams)
     * }
     */
    public static FunctionDescriptor opus_multistream_encoder_get_size$descriptor() {
        return opus_multistream_encoder_get_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * opus_int32 opus_multistream_encoder_get_size(int streams, int coupled_streams)
     * }
     */
    public static MethodHandle opus_multistream_encoder_get_size$handle() {
        return opus_multistream_encoder_get_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * opus_int32 opus_multistream_encoder_get_size(int streams, int coupled_streams)
     * }
     */
    public static MemorySegment opus_multistream_encoder_get_size$address() {
        return opus_multistream_encoder_get_size.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * opus_int32 opus_multistream_encoder_get_size(int streams, int coupled_streams)
     * }
     */
    public static int opus_multistream_encoder_get_size(int streams, int coupled_streams) {
        var mh$ = opus_multistream_encoder_get_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_multistream_encoder_get_size", streams, coupled_streams);
            }
            return (int) mh$.invokeExact(streams, coupled_streams);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_multistream_surround_encoder_get_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_INT,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP
                .findOrThrow("opus_multistream_surround_encoder_get_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * opus_int32 opus_multistream_surround_encoder_get_size(int channels, int mapping_family)
     * }
     */
    public static FunctionDescriptor opus_multistream_surround_encoder_get_size$descriptor() {
        return opus_multistream_surround_encoder_get_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * opus_int32 opus_multistream_surround_encoder_get_size(int channels, int mapping_family)
     * }
     */
    public static MethodHandle opus_multistream_surround_encoder_get_size$handle() {
        return opus_multistream_surround_encoder_get_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * opus_int32 opus_multistream_surround_encoder_get_size(int channels, int mapping_family)
     * }
     */
    public static MemorySegment opus_multistream_surround_encoder_get_size$address() {
        return opus_multistream_surround_encoder_get_size.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * opus_int32 opus_multistream_surround_encoder_get_size(int channels, int mapping_family)
     * }
     */
    public static int opus_multistream_surround_encoder_get_size(int channels, int mapping_family) {
        var mh$ = opus_multistream_surround_encoder_get_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_multistream_surround_encoder_get_size", channels, mapping_family);
            }
            return (int) mh$.invokeExact(channels, mapping_family);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_multistream_encoder_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_INT,
                opusfile_h.C_INT,
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_multistream_encoder_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * OpusMSEncoder *opus_multistream_encoder_create(opus_int32 Fs, int channels, int streams, int coupled_streams, const unsigned char *mapping, int application, int *error)
     * }
     */
    public static FunctionDescriptor opus_multistream_encoder_create$descriptor() {
        return opus_multistream_encoder_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * OpusMSEncoder *opus_multistream_encoder_create(opus_int32 Fs, int channels, int streams, int coupled_streams, const unsigned char *mapping, int application, int *error)
     * }
     */
    public static MethodHandle opus_multistream_encoder_create$handle() {
        return opus_multistream_encoder_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * OpusMSEncoder *opus_multistream_encoder_create(opus_int32 Fs, int channels, int streams, int coupled_streams, const unsigned char *mapping, int application, int *error)
     * }
     */
    public static MemorySegment opus_multistream_encoder_create$address() {
        return opus_multistream_encoder_create.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * OpusMSEncoder *opus_multistream_encoder_create(opus_int32 Fs, int channels, int streams, int coupled_streams, const unsigned char *mapping, int application, int *error)
     * }
     */
    public static MemorySegment opus_multistream_encoder_create(int Fs, int channels, int streams, int coupled_streams,
            MemorySegment mapping, int application, MemorySegment error) {
        var mh$ = opus_multistream_encoder_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_multistream_encoder_create", Fs, channels, streams, coupled_streams, mapping,
                        application, error);
            }
            return (MemorySegment) mh$.invokeExact(Fs, channels, streams, coupled_streams, mapping, application, error);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_multistream_surround_encoder_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_INT,
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_multistream_surround_encoder_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * OpusMSEncoder *opus_multistream_surround_encoder_create(opus_int32 Fs, int channels, int mapping_family, int *streams, int *coupled_streams, unsigned char *mapping, int application, int *error)
     * }
     */
    public static FunctionDescriptor opus_multistream_surround_encoder_create$descriptor() {
        return opus_multistream_surround_encoder_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * OpusMSEncoder *opus_multistream_surround_encoder_create(opus_int32 Fs, int channels, int mapping_family, int *streams, int *coupled_streams, unsigned char *mapping, int application, int *error)
     * }
     */
    public static MethodHandle opus_multistream_surround_encoder_create$handle() {
        return opus_multistream_surround_encoder_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * OpusMSEncoder *opus_multistream_surround_encoder_create(opus_int32 Fs, int channels, int mapping_family, int *streams, int *coupled_streams, unsigned char *mapping, int application, int *error)
     * }
     */
    public static MemorySegment opus_multistream_surround_encoder_create$address() {
        return opus_multistream_surround_encoder_create.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * OpusMSEncoder *opus_multistream_surround_encoder_create(opus_int32 Fs, int channels, int mapping_family, int *streams, int *coupled_streams, unsigned char *mapping, int application, int *error)
     * }
     */
    public static MemorySegment opus_multistream_surround_encoder_create(int Fs, int channels, int mapping_family,
            MemorySegment streams, MemorySegment coupled_streams, MemorySegment mapping, int application,
            MemorySegment error) {
        var mh$ = opus_multistream_surround_encoder_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_multistream_surround_encoder_create", Fs, channels, mapping_family, streams,
                        coupled_streams, mapping, application, error);
            }
            return (MemorySegment) mh$.invokeExact(Fs, channels, mapping_family, streams, coupled_streams, mapping,
                    application, error);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_multistream_encoder_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_INT,
                opusfile_h.C_INT,
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_multistream_encoder_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int opus_multistream_encoder_init(OpusMSEncoder *st, opus_int32 Fs, int channels, int streams, int coupled_streams, const unsigned char *mapping, int application)
     * }
     */
    public static FunctionDescriptor opus_multistream_encoder_init$descriptor() {
        return opus_multistream_encoder_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int opus_multistream_encoder_init(OpusMSEncoder *st, opus_int32 Fs, int channels, int streams, int coupled_streams, const unsigned char *mapping, int application)
     * }
     */
    public static MethodHandle opus_multistream_encoder_init$handle() {
        return opus_multistream_encoder_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int opus_multistream_encoder_init(OpusMSEncoder *st, opus_int32 Fs, int channels, int streams, int coupled_streams, const unsigned char *mapping, int application)
     * }
     */
    public static MemorySegment opus_multistream_encoder_init$address() {
        return opus_multistream_encoder_init.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int opus_multistream_encoder_init(OpusMSEncoder *st, opus_int32 Fs, int channels, int streams, int coupled_streams, const unsigned char *mapping, int application)
     * }
     */
    public static int opus_multistream_encoder_init(MemorySegment st, int Fs, int channels, int streams,
            int coupled_streams, MemorySegment mapping, int application) {
        var mh$ = opus_multistream_encoder_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_multistream_encoder_init", st, Fs, channels, streams, coupled_streams, mapping,
                        application);
            }
            return (int) mh$.invokeExact(st, Fs, channels, streams, coupled_streams, mapping, application);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_multistream_surround_encoder_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_INT,
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_multistream_surround_encoder_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int opus_multistream_surround_encoder_init(OpusMSEncoder *st, opus_int32 Fs, int channels, int mapping_family, int *streams, int *coupled_streams, unsigned char *mapping, int application)
     * }
     */
    public static FunctionDescriptor opus_multistream_surround_encoder_init$descriptor() {
        return opus_multistream_surround_encoder_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int opus_multistream_surround_encoder_init(OpusMSEncoder *st, opus_int32 Fs, int channels, int mapping_family, int *streams, int *coupled_streams, unsigned char *mapping, int application)
     * }
     */
    public static MethodHandle opus_multistream_surround_encoder_init$handle() {
        return opus_multistream_surround_encoder_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int opus_multistream_surround_encoder_init(OpusMSEncoder *st, opus_int32 Fs, int channels, int mapping_family, int *streams, int *coupled_streams, unsigned char *mapping, int application)
     * }
     */
    public static MemorySegment opus_multistream_surround_encoder_init$address() {
        return opus_multistream_surround_encoder_init.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int opus_multistream_surround_encoder_init(OpusMSEncoder *st, opus_int32 Fs, int channels, int mapping_family, int *streams, int *coupled_streams, unsigned char *mapping, int application)
     * }
     */
    public static int opus_multistream_surround_encoder_init(MemorySegment st, int Fs, int channels, int mapping_family,
            MemorySegment streams, MemorySegment coupled_streams, MemorySegment mapping, int application) {
        var mh$ = opus_multistream_surround_encoder_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_multistream_surround_encoder_init", st, Fs, channels, mapping_family, streams,
                        coupled_streams, mapping, application);
            }
            return (int) mh$.invokeExact(st, Fs, channels, mapping_family, streams, coupled_streams, mapping,
                    application);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_multistream_encode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_multistream_encode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int opus_multistream_encode(OpusMSEncoder *st, const opus_int16 *pcm, int frame_size, unsigned char *data, opus_int32 max_data_bytes)
     * }
     */
    public static FunctionDescriptor opus_multistream_encode$descriptor() {
        return opus_multistream_encode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int opus_multistream_encode(OpusMSEncoder *st, const opus_int16 *pcm, int frame_size, unsigned char *data, opus_int32 max_data_bytes)
     * }
     */
    public static MethodHandle opus_multistream_encode$handle() {
        return opus_multistream_encode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int opus_multistream_encode(OpusMSEncoder *st, const opus_int16 *pcm, int frame_size, unsigned char *data, opus_int32 max_data_bytes)
     * }
     */
    public static MemorySegment opus_multistream_encode$address() {
        return opus_multistream_encode.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int opus_multistream_encode(OpusMSEncoder *st, const opus_int16 *pcm, int frame_size, unsigned char *data, opus_int32 max_data_bytes)
     * }
     */
    public static int opus_multistream_encode(MemorySegment st, MemorySegment pcm, int frame_size, MemorySegment data,
            int max_data_bytes) {
        var mh$ = opus_multistream_encode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_multistream_encode", st, pcm, frame_size, data, max_data_bytes);
            }
            return (int) mh$.invokeExact(st, pcm, frame_size, data, max_data_bytes);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_multistream_encode24 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_multistream_encode24");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int opus_multistream_encode24(OpusMSEncoder *st, const opus_int32 *pcm, int frame_size, unsigned char *data, opus_int32 max_data_bytes)
     * }
     */
    public static FunctionDescriptor opus_multistream_encode24$descriptor() {
        return opus_multistream_encode24.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int opus_multistream_encode24(OpusMSEncoder *st, const opus_int32 *pcm, int frame_size, unsigned char *data, opus_int32 max_data_bytes)
     * }
     */
    public static MethodHandle opus_multistream_encode24$handle() {
        return opus_multistream_encode24.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int opus_multistream_encode24(OpusMSEncoder *st, const opus_int32 *pcm, int frame_size, unsigned char *data, opus_int32 max_data_bytes)
     * }
     */
    public static MemorySegment opus_multistream_encode24$address() {
        return opus_multistream_encode24.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int opus_multistream_encode24(OpusMSEncoder *st, const opus_int32 *pcm, int frame_size, unsigned char *data, opus_int32 max_data_bytes)
     * }
     */
    public static int opus_multistream_encode24(MemorySegment st, MemorySegment pcm, int frame_size, MemorySegment data,
            int max_data_bytes) {
        var mh$ = opus_multistream_encode24.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_multistream_encode24", st, pcm, frame_size, data, max_data_bytes);
            }
            return (int) mh$.invokeExact(st, pcm, frame_size, data, max_data_bytes);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_multistream_encode_float {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_multistream_encode_float");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int opus_multistream_encode_float(OpusMSEncoder *st, const float *pcm, int frame_size, unsigned char *data, opus_int32 max_data_bytes)
     * }
     */
    public static FunctionDescriptor opus_multistream_encode_float$descriptor() {
        return opus_multistream_encode_float.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int opus_multistream_encode_float(OpusMSEncoder *st, const float *pcm, int frame_size, unsigned char *data, opus_int32 max_data_bytes)
     * }
     */
    public static MethodHandle opus_multistream_encode_float$handle() {
        return opus_multistream_encode_float.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int opus_multistream_encode_float(OpusMSEncoder *st, const float *pcm, int frame_size, unsigned char *data, opus_int32 max_data_bytes)
     * }
     */
    public static MemorySegment opus_multistream_encode_float$address() {
        return opus_multistream_encode_float.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int opus_multistream_encode_float(OpusMSEncoder *st, const float *pcm, int frame_size, unsigned char *data, opus_int32 max_data_bytes)
     * }
     */
    public static int opus_multistream_encode_float(MemorySegment st, MemorySegment pcm, int frame_size,
            MemorySegment data, int max_data_bytes) {
        var mh$ = opus_multistream_encode_float.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_multistream_encode_float", st, pcm, frame_size, data, max_data_bytes);
            }
            return (int) mh$.invokeExact(st, pcm, frame_size, data, max_data_bytes);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_multistream_encoder_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_multistream_encoder_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * void opus_multistream_encoder_destroy(OpusMSEncoder *st)
     * }
     */
    public static FunctionDescriptor opus_multistream_encoder_destroy$descriptor() {
        return opus_multistream_encoder_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * void opus_multistream_encoder_destroy(OpusMSEncoder *st)
     * }
     */
    public static MethodHandle opus_multistream_encoder_destroy$handle() {
        return opus_multistream_encoder_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * void opus_multistream_encoder_destroy(OpusMSEncoder *st)
     * }
     */
    public static MemorySegment opus_multistream_encoder_destroy$address() {
        return opus_multistream_encoder_destroy.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * void opus_multistream_encoder_destroy(OpusMSEncoder *st)
     * }
     */
    public static void opus_multistream_encoder_destroy(MemorySegment st) {
        var mh$ = opus_multistream_encoder_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_multistream_encoder_destroy", st);
            }
            mh$.invokeExact(st);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang = c
     * : * int opus_multistream_encoder_ctl(OpusMSEncoder *st, int request, ...)
     * }
     */
    public static class opus_multistream_encoder_ctl {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_multistream_encoder_ctl");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private opus_multistream_encoder_ctl(MethodHandle handle, FunctionDescriptor descriptor,
                MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang = c
         * : * int opus_multistream_encoder_ctl(OpusMSEncoder *st, int request, ...)
         * }
         */
        public static opus_multistream_encoder_ctl makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new opus_multistream_encoder_ctl(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment st, int request, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("opus_multistream_encoder_ctl", st, request, x2);
                }
                return (int) spreader.invokeExact(st, request, x2);
            } catch (IllegalArgumentException | ClassCastException ex$) {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class opus_multistream_decoder_get_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_INT,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_multistream_decoder_get_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * opus_int32 opus_multistream_decoder_get_size(int streams, int coupled_streams)
     * }
     */
    public static FunctionDescriptor opus_multistream_decoder_get_size$descriptor() {
        return opus_multistream_decoder_get_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * opus_int32 opus_multistream_decoder_get_size(int streams, int coupled_streams)
     * }
     */
    public static MethodHandle opus_multistream_decoder_get_size$handle() {
        return opus_multistream_decoder_get_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * opus_int32 opus_multistream_decoder_get_size(int streams, int coupled_streams)
     * }
     */
    public static MemorySegment opus_multistream_decoder_get_size$address() {
        return opus_multistream_decoder_get_size.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * opus_int32 opus_multistream_decoder_get_size(int streams, int coupled_streams)
     * }
     */
    public static int opus_multistream_decoder_get_size(int streams, int coupled_streams) {
        var mh$ = opus_multistream_decoder_get_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_multistream_decoder_get_size", streams, coupled_streams);
            }
            return (int) mh$.invokeExact(streams, coupled_streams);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_multistream_decoder_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_INT,
                opusfile_h.C_INT,
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_multistream_decoder_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * OpusMSDecoder *opus_multistream_decoder_create(opus_int32 Fs, int channels, int streams, int coupled_streams, const unsigned char *mapping, int *error)
     * }
     */
    public static FunctionDescriptor opus_multistream_decoder_create$descriptor() {
        return opus_multistream_decoder_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * OpusMSDecoder *opus_multistream_decoder_create(opus_int32 Fs, int channels, int streams, int coupled_streams, const unsigned char *mapping, int *error)
     * }
     */
    public static MethodHandle opus_multistream_decoder_create$handle() {
        return opus_multistream_decoder_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * OpusMSDecoder *opus_multistream_decoder_create(opus_int32 Fs, int channels, int streams, int coupled_streams, const unsigned char *mapping, int *error)
     * }
     */
    public static MemorySegment opus_multistream_decoder_create$address() {
        return opus_multistream_decoder_create.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * OpusMSDecoder *opus_multistream_decoder_create(opus_int32 Fs, int channels, int streams, int coupled_streams, const unsigned char *mapping, int *error)
     * }
     */
    public static MemorySegment opus_multistream_decoder_create(int Fs, int channels, int streams, int coupled_streams,
            MemorySegment mapping, MemorySegment error) {
        var mh$ = opus_multistream_decoder_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_multistream_decoder_create", Fs, channels, streams, coupled_streams, mapping,
                        error);
            }
            return (MemorySegment) mh$.invokeExact(Fs, channels, streams, coupled_streams, mapping, error);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_multistream_decoder_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_INT,
                opusfile_h.C_INT,
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_multistream_decoder_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int opus_multistream_decoder_init(OpusMSDecoder *st, opus_int32 Fs, int channels, int streams, int coupled_streams, const unsigned char *mapping)
     * }
     */
    public static FunctionDescriptor opus_multistream_decoder_init$descriptor() {
        return opus_multistream_decoder_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int opus_multistream_decoder_init(OpusMSDecoder *st, opus_int32 Fs, int channels, int streams, int coupled_streams, const unsigned char *mapping)
     * }
     */
    public static MethodHandle opus_multistream_decoder_init$handle() {
        return opus_multistream_decoder_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int opus_multistream_decoder_init(OpusMSDecoder *st, opus_int32 Fs, int channels, int streams, int coupled_streams, const unsigned char *mapping)
     * }
     */
    public static MemorySegment opus_multistream_decoder_init$address() {
        return opus_multistream_decoder_init.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int opus_multistream_decoder_init(OpusMSDecoder *st, opus_int32 Fs, int channels, int streams, int coupled_streams, const unsigned char *mapping)
     * }
     */
    public static int opus_multistream_decoder_init(MemorySegment st, int Fs, int channels, int streams,
            int coupled_streams, MemorySegment mapping) {
        var mh$ = opus_multistream_decoder_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_multistream_decoder_init", st, Fs, channels, streams, coupled_streams, mapping);
            }
            return (int) mh$.invokeExact(st, Fs, channels, streams, coupled_streams, mapping);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_multistream_decode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_multistream_decode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int opus_multistream_decode(OpusMSDecoder *st, const unsigned char *data, opus_int32 len, opus_int16 *pcm, int frame_size, int decode_fec)
     * }
     */
    public static FunctionDescriptor opus_multistream_decode$descriptor() {
        return opus_multistream_decode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int opus_multistream_decode(OpusMSDecoder *st, const unsigned char *data, opus_int32 len, opus_int16 *pcm, int frame_size, int decode_fec)
     * }
     */
    public static MethodHandle opus_multistream_decode$handle() {
        return opus_multistream_decode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int opus_multistream_decode(OpusMSDecoder *st, const unsigned char *data, opus_int32 len, opus_int16 *pcm, int frame_size, int decode_fec)
     * }
     */
    public static MemorySegment opus_multistream_decode$address() {
        return opus_multistream_decode.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int opus_multistream_decode(OpusMSDecoder *st, const unsigned char *data, opus_int32 len, opus_int16 *pcm, int frame_size, int decode_fec)
     * }
     */
    public static int opus_multistream_decode(MemorySegment st, MemorySegment data, int len, MemorySegment pcm,
            int frame_size, int decode_fec) {
        var mh$ = opus_multistream_decode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_multistream_decode", st, data, len, pcm, frame_size, decode_fec);
            }
            return (int) mh$.invokeExact(st, data, len, pcm, frame_size, decode_fec);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_multistream_decode24 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_multistream_decode24");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int opus_multistream_decode24(OpusMSDecoder *st, const unsigned char *data, opus_int32 len, opus_int32 *pcm, int frame_size, int decode_fec)
     * }
     */
    public static FunctionDescriptor opus_multistream_decode24$descriptor() {
        return opus_multistream_decode24.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int opus_multistream_decode24(OpusMSDecoder *st, const unsigned char *data, opus_int32 len, opus_int32 *pcm, int frame_size, int decode_fec)
     * }
     */
    public static MethodHandle opus_multistream_decode24$handle() {
        return opus_multistream_decode24.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int opus_multistream_decode24(OpusMSDecoder *st, const unsigned char *data, opus_int32 len, opus_int32 *pcm, int frame_size, int decode_fec)
     * }
     */
    public static MemorySegment opus_multistream_decode24$address() {
        return opus_multistream_decode24.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int opus_multistream_decode24(OpusMSDecoder *st, const unsigned char *data, opus_int32 len, opus_int32 *pcm, int frame_size, int decode_fec)
     * }
     */
    public static int opus_multistream_decode24(MemorySegment st, MemorySegment data, int len, MemorySegment pcm,
            int frame_size, int decode_fec) {
        var mh$ = opus_multistream_decode24.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_multistream_decode24", st, data, len, pcm, frame_size, decode_fec);
            }
            return (int) mh$.invokeExact(st, data, len, pcm, frame_size, decode_fec);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_multistream_decode_float {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_multistream_decode_float");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int opus_multistream_decode_float(OpusMSDecoder *st, const unsigned char *data, opus_int32 len, float *pcm, int frame_size, int decode_fec)
     * }
     */
    public static FunctionDescriptor opus_multistream_decode_float$descriptor() {
        return opus_multistream_decode_float.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int opus_multistream_decode_float(OpusMSDecoder *st, const unsigned char *data, opus_int32 len, float *pcm, int frame_size, int decode_fec)
     * }
     */
    public static MethodHandle opus_multistream_decode_float$handle() {
        return opus_multistream_decode_float.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int opus_multistream_decode_float(OpusMSDecoder *st, const unsigned char *data, opus_int32 len, float *pcm, int frame_size, int decode_fec)
     * }
     */
    public static MemorySegment opus_multistream_decode_float$address() {
        return opus_multistream_decode_float.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int opus_multistream_decode_float(OpusMSDecoder *st, const unsigned char *data, opus_int32 len, float *pcm, int frame_size, int decode_fec)
     * }
     */
    public static int opus_multistream_decode_float(MemorySegment st, MemorySegment data, int len, MemorySegment pcm,
            int frame_size, int decode_fec) {
        var mh$ = opus_multistream_decode_float.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_multistream_decode_float", st, data, len, pcm, frame_size, decode_fec);
            }
            return (int) mh$.invokeExact(st, data, len, pcm, frame_size, decode_fec);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang = c
     * : * int opus_multistream_decoder_ctl(OpusMSDecoder *st, int request, ...)
     * }
     */
    public static class opus_multistream_decoder_ctl {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_multistream_decoder_ctl");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private opus_multistream_decoder_ctl(MethodHandle handle, FunctionDescriptor descriptor,
                MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang = c
         * : * int opus_multistream_decoder_ctl(OpusMSDecoder *st, int request, ...)
         * }
         */
        public static opus_multistream_decoder_ctl makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new opus_multistream_decoder_ctl(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment st, int request, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("opus_multistream_decoder_ctl", st, request, x2);
                }
                return (int) spreader.invokeExact(st, request, x2);
            } catch (IllegalArgumentException | ClassCastException ex$) {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class opus_multistream_decoder_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_multistream_decoder_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * void opus_multistream_decoder_destroy(OpusMSDecoder *st)
     * }
     */
    public static FunctionDescriptor opus_multistream_decoder_destroy$descriptor() {
        return opus_multistream_decoder_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * void opus_multistream_decoder_destroy(OpusMSDecoder *st)
     * }
     */
    public static MethodHandle opus_multistream_decoder_destroy$handle() {
        return opus_multistream_decoder_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * void opus_multistream_decoder_destroy(OpusMSDecoder *st)
     * }
     */
    public static MemorySegment opus_multistream_decoder_destroy$address() {
        return opus_multistream_decoder_destroy.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * void opus_multistream_decoder_destroy(OpusMSDecoder *st)
     * }
     */
    public static void opus_multistream_decoder_destroy(MemorySegment st) {
        var mh$ = opus_multistream_decoder_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_multistream_decoder_destroy", st);
            }
            mh$.invokeExact(st);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_head_parse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_LONG_LONG);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_head_parse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int opus_head_parse(OpusHead *_head, const unsigned char *_data, size_t _len)
     * }
     */
    public static FunctionDescriptor opus_head_parse$descriptor() {
        return opus_head_parse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int opus_head_parse(OpusHead *_head, const unsigned char *_data, size_t _len)
     * }
     */
    public static MethodHandle opus_head_parse$handle() {
        return opus_head_parse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int opus_head_parse(OpusHead *_head, const unsigned char *_data, size_t _len)
     * }
     */
    public static MemorySegment opus_head_parse$address() {
        return opus_head_parse.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int opus_head_parse(OpusHead *_head, const unsigned char *_data, size_t _len)
     * }
     */
    public static int opus_head_parse(MemorySegment _head, MemorySegment _data, long _len) {
        var mh$ = opus_head_parse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_head_parse", _head, _data, _len);
            }
            return (int) mh$.invokeExact(_head, _data, _len);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_granule_sample {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER,
                opusfile_h.C_LONG_LONG);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_granule_sample");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * ogg_int64_t opus_granule_sample(const OpusHead *_head, ogg_int64_t _gp)
     * }
     */
    public static FunctionDescriptor opus_granule_sample$descriptor() {
        return opus_granule_sample.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * ogg_int64_t opus_granule_sample(const OpusHead *_head, ogg_int64_t _gp)
     * }
     */
    public static MethodHandle opus_granule_sample$handle() {
        return opus_granule_sample.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * ogg_int64_t opus_granule_sample(const OpusHead *_head, ogg_int64_t _gp)
     * }
     */
    public static MemorySegment opus_granule_sample$address() {
        return opus_granule_sample.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * ogg_int64_t opus_granule_sample(const OpusHead *_head, ogg_int64_t _gp)
     * }
     */
    public static long opus_granule_sample(MemorySegment _head, long _gp) {
        var mh$ = opus_granule_sample.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_granule_sample", _head, _gp);
            }
            return (long) mh$.invokeExact(_head, _gp);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_tags_parse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_LONG_LONG);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_tags_parse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int opus_tags_parse(OpusTags *_tags, const unsigned char *_data, size_t _len)
     * }
     */
    public static FunctionDescriptor opus_tags_parse$descriptor() {
        return opus_tags_parse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int opus_tags_parse(OpusTags *_tags, const unsigned char *_data, size_t _len)
     * }
     */
    public static MethodHandle opus_tags_parse$handle() {
        return opus_tags_parse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int opus_tags_parse(OpusTags *_tags, const unsigned char *_data, size_t _len)
     * }
     */
    public static MemorySegment opus_tags_parse$address() {
        return opus_tags_parse.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int opus_tags_parse(OpusTags *_tags, const unsigned char *_data, size_t _len)
     * }
     */
    public static int opus_tags_parse(MemorySegment _tags, MemorySegment _data, long _len) {
        var mh$ = opus_tags_parse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_tags_parse", _tags, _data, _len);
            }
            return (int) mh$.invokeExact(_tags, _data, _len);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_tags_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_tags_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int opus_tags_copy(OpusTags *_dst, const OpusTags *_src)
     * }
     */
    public static FunctionDescriptor opus_tags_copy$descriptor() {
        return opus_tags_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int opus_tags_copy(OpusTags *_dst, const OpusTags *_src)
     * }
     */
    public static MethodHandle opus_tags_copy$handle() {
        return opus_tags_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int opus_tags_copy(OpusTags *_dst, const OpusTags *_src)
     * }
     */
    public static MemorySegment opus_tags_copy$address() {
        return opus_tags_copy.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int opus_tags_copy(OpusTags *_dst, const OpusTags *_src)
     * }
     */
    public static int opus_tags_copy(MemorySegment _dst, MemorySegment _src) {
        var mh$ = opus_tags_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_tags_copy", _dst, _src);
            }
            return (int) mh$.invokeExact(_dst, _src);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_tags_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_tags_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * void opus_tags_init(OpusTags *_tags)
     * }
     */
    public static FunctionDescriptor opus_tags_init$descriptor() {
        return opus_tags_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * void opus_tags_init(OpusTags *_tags)
     * }
     */
    public static MethodHandle opus_tags_init$handle() {
        return opus_tags_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * void opus_tags_init(OpusTags *_tags)
     * }
     */
    public static MemorySegment opus_tags_init$address() {
        return opus_tags_init.ADDR;
    }

    /**
     * {@snippet lang = c : * void opus_tags_init(OpusTags *_tags)
     * }
     */
    public static void opus_tags_init(MemorySegment _tags) {
        var mh$ = opus_tags_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_tags_init", _tags);
            }
            mh$.invokeExact(_tags);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_tags_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_tags_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int opus_tags_add(OpusTags *_tags, const char *_tag, const char *_value)
     * }
     */
    public static FunctionDescriptor opus_tags_add$descriptor() {
        return opus_tags_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int opus_tags_add(OpusTags *_tags, const char *_tag, const char *_value)
     * }
     */
    public static MethodHandle opus_tags_add$handle() {
        return opus_tags_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int opus_tags_add(OpusTags *_tags, const char *_tag, const char *_value)
     * }
     */
    public static MemorySegment opus_tags_add$address() {
        return opus_tags_add.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int opus_tags_add(OpusTags *_tags, const char *_tag, const char *_value)
     * }
     */
    public static int opus_tags_add(MemorySegment _tags, MemorySegment _tag, MemorySegment _value) {
        var mh$ = opus_tags_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_tags_add", _tags, _tag, _value);
            }
            return (int) mh$.invokeExact(_tags, _tag, _value);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_tags_add_comment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_tags_add_comment");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int opus_tags_add_comment(OpusTags *_tags, const char *_comment)
     * }
     */
    public static FunctionDescriptor opus_tags_add_comment$descriptor() {
        return opus_tags_add_comment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int opus_tags_add_comment(OpusTags *_tags, const char *_comment)
     * }
     */
    public static MethodHandle opus_tags_add_comment$handle() {
        return opus_tags_add_comment.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int opus_tags_add_comment(OpusTags *_tags, const char *_comment)
     * }
     */
    public static MemorySegment opus_tags_add_comment$address() {
        return opus_tags_add_comment.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int opus_tags_add_comment(OpusTags *_tags, const char *_comment)
     * }
     */
    public static int opus_tags_add_comment(MemorySegment _tags, MemorySegment _comment) {
        var mh$ = opus_tags_add_comment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_tags_add_comment", _tags, _comment);
            }
            return (int) mh$.invokeExact(_tags, _comment);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_tags_set_binary_suffix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_tags_set_binary_suffix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int opus_tags_set_binary_suffix(OpusTags *_tags, const unsigned char *_data, int _len)
     * }
     */
    public static FunctionDescriptor opus_tags_set_binary_suffix$descriptor() {
        return opus_tags_set_binary_suffix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int opus_tags_set_binary_suffix(OpusTags *_tags, const unsigned char *_data, int _len)
     * }
     */
    public static MethodHandle opus_tags_set_binary_suffix$handle() {
        return opus_tags_set_binary_suffix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int opus_tags_set_binary_suffix(OpusTags *_tags, const unsigned char *_data, int _len)
     * }
     */
    public static MemorySegment opus_tags_set_binary_suffix$address() {
        return opus_tags_set_binary_suffix.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int opus_tags_set_binary_suffix(OpusTags *_tags, const unsigned char *_data, int _len)
     * }
     */
    public static int opus_tags_set_binary_suffix(MemorySegment _tags, MemorySegment _data, int _len) {
        var mh$ = opus_tags_set_binary_suffix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_tags_set_binary_suffix", _tags, _data, _len);
            }
            return (int) mh$.invokeExact(_tags, _data, _len);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_tags_query {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_tags_query");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * const char *opus_tags_query(const OpusTags *_tags, const char *_tag, int _count)
     * }
     */
    public static FunctionDescriptor opus_tags_query$descriptor() {
        return opus_tags_query.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * const char *opus_tags_query(const OpusTags *_tags, const char *_tag, int _count)
     * }
     */
    public static MethodHandle opus_tags_query$handle() {
        return opus_tags_query.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * const char *opus_tags_query(const OpusTags *_tags, const char *_tag, int _count)
     * }
     */
    public static MemorySegment opus_tags_query$address() {
        return opus_tags_query.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * const char *opus_tags_query(const OpusTags *_tags, const char *_tag, int _count)
     * }
     */
    public static MemorySegment opus_tags_query(MemorySegment _tags, MemorySegment _tag, int _count) {
        var mh$ = opus_tags_query.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_tags_query", _tags, _tag, _count);
            }
            return (MemorySegment) mh$.invokeExact(_tags, _tag, _count);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_tags_query_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_tags_query_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int opus_tags_query_count(const OpusTags *_tags, const char *_tag)
     * }
     */
    public static FunctionDescriptor opus_tags_query_count$descriptor() {
        return opus_tags_query_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int opus_tags_query_count(const OpusTags *_tags, const char *_tag)
     * }
     */
    public static MethodHandle opus_tags_query_count$handle() {
        return opus_tags_query_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int opus_tags_query_count(const OpusTags *_tags, const char *_tag)
     * }
     */
    public static MemorySegment opus_tags_query_count$address() {
        return opus_tags_query_count.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int opus_tags_query_count(const OpusTags *_tags, const char *_tag)
     * }
     */
    public static int opus_tags_query_count(MemorySegment _tags, MemorySegment _tag) {
        var mh$ = opus_tags_query_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_tags_query_count", _tags, _tag);
            }
            return (int) mh$.invokeExact(_tags, _tag);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_tags_get_binary_suffix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_tags_get_binary_suffix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * const unsigned char *opus_tags_get_binary_suffix(const OpusTags *_tags, int *_len)
     * }
     */
    public static FunctionDescriptor opus_tags_get_binary_suffix$descriptor() {
        return opus_tags_get_binary_suffix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * const unsigned char *opus_tags_get_binary_suffix(const OpusTags *_tags, int *_len)
     * }
     */
    public static MethodHandle opus_tags_get_binary_suffix$handle() {
        return opus_tags_get_binary_suffix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * const unsigned char *opus_tags_get_binary_suffix(const OpusTags *_tags, int *_len)
     * }
     */
    public static MemorySegment opus_tags_get_binary_suffix$address() {
        return opus_tags_get_binary_suffix.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * const unsigned char *opus_tags_get_binary_suffix(const OpusTags *_tags, int *_len)
     * }
     */
    public static MemorySegment opus_tags_get_binary_suffix(MemorySegment _tags, MemorySegment _len) {
        var mh$ = opus_tags_get_binary_suffix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_tags_get_binary_suffix", _tags, _len);
            }
            return (MemorySegment) mh$.invokeExact(_tags, _len);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_tags_get_album_gain {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_tags_get_album_gain");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int opus_tags_get_album_gain(const OpusTags *_tags, int *_gain_q8)
     * }
     */
    public static FunctionDescriptor opus_tags_get_album_gain$descriptor() {
        return opus_tags_get_album_gain.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int opus_tags_get_album_gain(const OpusTags *_tags, int *_gain_q8)
     * }
     */
    public static MethodHandle opus_tags_get_album_gain$handle() {
        return opus_tags_get_album_gain.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int opus_tags_get_album_gain(const OpusTags *_tags, int *_gain_q8)
     * }
     */
    public static MemorySegment opus_tags_get_album_gain$address() {
        return opus_tags_get_album_gain.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int opus_tags_get_album_gain(const OpusTags *_tags, int *_gain_q8)
     * }
     */
    public static int opus_tags_get_album_gain(MemorySegment _tags, MemorySegment _gain_q8) {
        var mh$ = opus_tags_get_album_gain.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_tags_get_album_gain", _tags, _gain_q8);
            }
            return (int) mh$.invokeExact(_tags, _gain_q8);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_tags_get_track_gain {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_tags_get_track_gain");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int opus_tags_get_track_gain(const OpusTags *_tags, int *_gain_q8)
     * }
     */
    public static FunctionDescriptor opus_tags_get_track_gain$descriptor() {
        return opus_tags_get_track_gain.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int opus_tags_get_track_gain(const OpusTags *_tags, int *_gain_q8)
     * }
     */
    public static MethodHandle opus_tags_get_track_gain$handle() {
        return opus_tags_get_track_gain.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int opus_tags_get_track_gain(const OpusTags *_tags, int *_gain_q8)
     * }
     */
    public static MemorySegment opus_tags_get_track_gain$address() {
        return opus_tags_get_track_gain.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int opus_tags_get_track_gain(const OpusTags *_tags, int *_gain_q8)
     * }
     */
    public static int opus_tags_get_track_gain(MemorySegment _tags, MemorySegment _gain_q8) {
        var mh$ = opus_tags_get_track_gain.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_tags_get_track_gain", _tags, _gain_q8);
            }
            return (int) mh$.invokeExact(_tags, _gain_q8);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_tags_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_tags_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * void opus_tags_clear(OpusTags *_tags)
     * }
     */
    public static FunctionDescriptor opus_tags_clear$descriptor() {
        return opus_tags_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * void opus_tags_clear(OpusTags *_tags)
     * }
     */
    public static MethodHandle opus_tags_clear$handle() {
        return opus_tags_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * void opus_tags_clear(OpusTags *_tags)
     * }
     */
    public static MemorySegment opus_tags_clear$address() {
        return opus_tags_clear.ADDR;
    }

    /**
     * {@snippet lang = c : * void opus_tags_clear(OpusTags *_tags)
     * }
     */
    public static void opus_tags_clear(MemorySegment _tags) {
        var mh$ = opus_tags_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_tags_clear", _tags);
            }
            mh$.invokeExact(_tags);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_tagcompare {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_tagcompare");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int opus_tagcompare(const char *_tag_name, const char *_comment)
     * }
     */
    public static FunctionDescriptor opus_tagcompare$descriptor() {
        return opus_tagcompare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int opus_tagcompare(const char *_tag_name, const char *_comment)
     * }
     */
    public static MethodHandle opus_tagcompare$handle() {
        return opus_tagcompare.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int opus_tagcompare(const char *_tag_name, const char *_comment)
     * }
     */
    public static MemorySegment opus_tagcompare$address() {
        return opus_tagcompare.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int opus_tagcompare(const char *_tag_name, const char *_comment)
     * }
     */
    public static int opus_tagcompare(MemorySegment _tag_name, MemorySegment _comment) {
        var mh$ = opus_tagcompare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_tagcompare", _tag_name, _comment);
            }
            return (int) mh$.invokeExact(_tag_name, _comment);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_tagncompare {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_tagncompare");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int opus_tagncompare(const char *_tag_name, int _tag_len, const char *_comment)
     * }
     */
    public static FunctionDescriptor opus_tagncompare$descriptor() {
        return opus_tagncompare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int opus_tagncompare(const char *_tag_name, int _tag_len, const char *_comment)
     * }
     */
    public static MethodHandle opus_tagncompare$handle() {
        return opus_tagncompare.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int opus_tagncompare(const char *_tag_name, int _tag_len, const char *_comment)
     * }
     */
    public static MemorySegment opus_tagncompare$address() {
        return opus_tagncompare.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int opus_tagncompare(const char *_tag_name, int _tag_len, const char *_comment)
     * }
     */
    public static int opus_tagncompare(MemorySegment _tag_name, int _tag_len, MemorySegment _comment) {
        var mh$ = opus_tagncompare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_tagncompare", _tag_name, _tag_len, _comment);
            }
            return (int) mh$.invokeExact(_tag_name, _tag_len, _comment);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_picture_tag_parse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_picture_tag_parse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int opus_picture_tag_parse(OpusPictureTag *_pic, const char *_tag)
     * }
     */
    public static FunctionDescriptor opus_picture_tag_parse$descriptor() {
        return opus_picture_tag_parse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int opus_picture_tag_parse(OpusPictureTag *_pic, const char *_tag)
     * }
     */
    public static MethodHandle opus_picture_tag_parse$handle() {
        return opus_picture_tag_parse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int opus_picture_tag_parse(OpusPictureTag *_pic, const char *_tag)
     * }
     */
    public static MemorySegment opus_picture_tag_parse$address() {
        return opus_picture_tag_parse.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int opus_picture_tag_parse(OpusPictureTag *_pic, const char *_tag)
     * }
     */
    public static int opus_picture_tag_parse(MemorySegment _pic, MemorySegment _tag) {
        var mh$ = opus_picture_tag_parse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_picture_tag_parse", _pic, _tag);
            }
            return (int) mh$.invokeExact(_pic, _tag);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_picture_tag_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_picture_tag_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * void opus_picture_tag_init(OpusPictureTag *_pic)
     * }
     */
    public static FunctionDescriptor opus_picture_tag_init$descriptor() {
        return opus_picture_tag_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * void opus_picture_tag_init(OpusPictureTag *_pic)
     * }
     */
    public static MethodHandle opus_picture_tag_init$handle() {
        return opus_picture_tag_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * void opus_picture_tag_init(OpusPictureTag *_pic)
     * }
     */
    public static MemorySegment opus_picture_tag_init$address() {
        return opus_picture_tag_init.ADDR;
    }

    /**
     * {@snippet lang = c : * void opus_picture_tag_init(OpusPictureTag *_pic)
     * }
     */
    public static void opus_picture_tag_init(MemorySegment _pic) {
        var mh$ = opus_picture_tag_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_picture_tag_init", _pic);
            }
            mh$.invokeExact(_pic);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_picture_tag_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_picture_tag_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * void opus_picture_tag_clear(OpusPictureTag *_pic)
     * }
     */
    public static FunctionDescriptor opus_picture_tag_clear$descriptor() {
        return opus_picture_tag_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * void opus_picture_tag_clear(OpusPictureTag *_pic)
     * }
     */
    public static MethodHandle opus_picture_tag_clear$handle() {
        return opus_picture_tag_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * void opus_picture_tag_clear(OpusPictureTag *_pic)
     * }
     */
    public static MemorySegment opus_picture_tag_clear$address() {
        return opus_picture_tag_clear.ADDR;
    }

    /**
     * {@snippet lang = c : * void opus_picture_tag_clear(OpusPictureTag *_pic)
     * }
     */
    public static void opus_picture_tag_clear(MemorySegment _pic) {
        var mh$ = opus_picture_tag_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_picture_tag_clear", _pic);
            }
            mh$.invokeExact(_pic);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_server_info_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_server_info_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * void opus_server_info_init(OpusServerInfo *_info)
     * }
     */
    public static FunctionDescriptor opus_server_info_init$descriptor() {
        return opus_server_info_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * void opus_server_info_init(OpusServerInfo *_info)
     * }
     */
    public static MethodHandle opus_server_info_init$handle() {
        return opus_server_info_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * void opus_server_info_init(OpusServerInfo *_info)
     * }
     */
    public static MemorySegment opus_server_info_init$address() {
        return opus_server_info_init.ADDR;
    }

    /**
     * {@snippet lang = c : * void opus_server_info_init(OpusServerInfo *_info)
     * }
     */
    public static void opus_server_info_init(MemorySegment _info) {
        var mh$ = opus_server_info_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_server_info_init", _info);
            }
            mh$.invokeExact(_info);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class opus_server_info_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("opus_server_info_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * void opus_server_info_clear(OpusServerInfo *_info)
     * }
     */
    public static FunctionDescriptor opus_server_info_clear$descriptor() {
        return opus_server_info_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * void opus_server_info_clear(OpusServerInfo *_info)
     * }
     */
    public static MethodHandle opus_server_info_clear$handle() {
        return opus_server_info_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * void opus_server_info_clear(OpusServerInfo *_info)
     * }
     */
    public static MemorySegment opus_server_info_clear$address() {
        return opus_server_info_clear.ADDR;
    }

    /**
     * {@snippet lang = c : * void opus_server_info_clear(OpusServerInfo *_info)
     * }
     */
    public static void opus_server_info_clear(MemorySegment _info) {
        var mh$ = opus_server_info_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("opus_server_info_clear", _info);
            }
            mh$.invokeExact(_info);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class op_fopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("op_fopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * void *op_fopen(OpusFileCallbacks *_cb, const char *_path, const char *_mode)
     * }
     */
    public static FunctionDescriptor op_fopen$descriptor() {
        return op_fopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * void *op_fopen(OpusFileCallbacks *_cb, const char *_path, const char *_mode)
     * }
     */
    public static MethodHandle op_fopen$handle() {
        return op_fopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * void *op_fopen(OpusFileCallbacks *_cb, const char *_path, const char *_mode)
     * }
     */
    public static MemorySegment op_fopen$address() {
        return op_fopen.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * void *op_fopen(OpusFileCallbacks *_cb, const char *_path, const char *_mode)
     * }
     */
    public static MemorySegment op_fopen(MemorySegment _cb, MemorySegment _path, MemorySegment _mode) {
        var mh$ = op_fopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("op_fopen", _cb, _path, _mode);
            }
            return (MemorySegment) mh$.invokeExact(_cb, _path, _mode);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class op_fdopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("op_fdopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * void *op_fdopen(OpusFileCallbacks *_cb, int _fd, const char *_mode)
     * }
     */
    public static FunctionDescriptor op_fdopen$descriptor() {
        return op_fdopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * void *op_fdopen(OpusFileCallbacks *_cb, int _fd, const char *_mode)
     * }
     */
    public static MethodHandle op_fdopen$handle() {
        return op_fdopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * void *op_fdopen(OpusFileCallbacks *_cb, int _fd, const char *_mode)
     * }
     */
    public static MemorySegment op_fdopen$address() {
        return op_fdopen.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * void *op_fdopen(OpusFileCallbacks *_cb, int _fd, const char *_mode)
     * }
     */
    public static MemorySegment op_fdopen(MemorySegment _cb, int _fd, MemorySegment _mode) {
        var mh$ = op_fdopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("op_fdopen", _cb, _fd, _mode);
            }
            return (MemorySegment) mh$.invokeExact(_cb, _fd, _mode);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class op_freopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("op_freopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * void *op_freopen(OpusFileCallbacks *_cb, const char *_path, const char *_mode, void *_stream)
     * }
     */
    public static FunctionDescriptor op_freopen$descriptor() {
        return op_freopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * void *op_freopen(OpusFileCallbacks *_cb, const char *_path, const char *_mode, void *_stream)
     * }
     */
    public static MethodHandle op_freopen$handle() {
        return op_freopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * void *op_freopen(OpusFileCallbacks *_cb, const char *_path, const char *_mode, void *_stream)
     * }
     */
    public static MemorySegment op_freopen$address() {
        return op_freopen.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * void *op_freopen(OpusFileCallbacks *_cb, const char *_path, const char *_mode, void *_stream)
     * }
     */
    public static MemorySegment op_freopen(MemorySegment _cb, MemorySegment _path, MemorySegment _mode,
            MemorySegment _stream) {
        var mh$ = op_freopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("op_freopen", _cb, _path, _mode, _stream);
            }
            return (MemorySegment) mh$.invokeExact(_cb, _path, _mode, _stream);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class op_mem_stream_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_LONG_LONG);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("op_mem_stream_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * void *op_mem_stream_create(OpusFileCallbacks *_cb, const unsigned char *_data, size_t _size)
     * }
     */
    public static FunctionDescriptor op_mem_stream_create$descriptor() {
        return op_mem_stream_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * void *op_mem_stream_create(OpusFileCallbacks *_cb, const unsigned char *_data, size_t _size)
     * }
     */
    public static MethodHandle op_mem_stream_create$handle() {
        return op_mem_stream_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * void *op_mem_stream_create(OpusFileCallbacks *_cb, const unsigned char *_data, size_t _size)
     * }
     */
    public static MemorySegment op_mem_stream_create$address() {
        return op_mem_stream_create.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * void *op_mem_stream_create(OpusFileCallbacks *_cb, const unsigned char *_data, size_t _size)
     * }
     */
    public static MemorySegment op_mem_stream_create(MemorySegment _cb, MemorySegment _data, long _size) {
        var mh$ = op_mem_stream_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("op_mem_stream_create", _cb, _data, _size);
            }
            return (MemorySegment) mh$.invokeExact(_cb, _data, _size);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class op_url_stream_vcreate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("op_url_stream_vcreate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * void *op_url_stream_vcreate(OpusFileCallbacks *_cb, const char *_url, va_list _ap)
     * }
     */
    public static FunctionDescriptor op_url_stream_vcreate$descriptor() {
        return op_url_stream_vcreate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * void *op_url_stream_vcreate(OpusFileCallbacks *_cb, const char *_url, va_list _ap)
     * }
     */
    public static MethodHandle op_url_stream_vcreate$handle() {
        return op_url_stream_vcreate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * void *op_url_stream_vcreate(OpusFileCallbacks *_cb, const char *_url, va_list _ap)
     * }
     */
    public static MemorySegment op_url_stream_vcreate$address() {
        return op_url_stream_vcreate.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * void *op_url_stream_vcreate(OpusFileCallbacks *_cb, const char *_url, va_list _ap)
     * }
     */
    public static MemorySegment op_url_stream_vcreate(MemorySegment _cb, MemorySegment _url, MemorySegment _ap) {
        var mh$ = op_url_stream_vcreate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("op_url_stream_vcreate", _cb, _url, _ap);
            }
            return (MemorySegment) mh$.invokeExact(_cb, _url, _ap);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang = c
     * : * void *op_url_stream_create(OpusFileCallbacks *_cb, const char *_url, ...)
     * }
     */
    public static class op_url_stream_create {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("op_url_stream_create");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private op_url_stream_create(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang = c
         * : * void *op_url_stream_create(OpusFileCallbacks *_cb, const char *_url, ...)
         * }
         */
        public static op_url_stream_create makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new op_url_stream_create(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment _cb, MemorySegment _url, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("op_url_stream_create", _cb, _url, x2);
                }
                return (MemorySegment) spreader.invokeExact(_cb, _url, x2);
            } catch (IllegalArgumentException | ClassCastException ex$) {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class op_test {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_LONG_LONG);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("op_test");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int op_test(OpusHead *_head, const unsigned char *_initial_data, size_t _initial_bytes)
     * }
     */
    public static FunctionDescriptor op_test$descriptor() {
        return op_test.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int op_test(OpusHead *_head, const unsigned char *_initial_data, size_t _initial_bytes)
     * }
     */
    public static MethodHandle op_test$handle() {
        return op_test.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int op_test(OpusHead *_head, const unsigned char *_initial_data, size_t _initial_bytes)
     * }
     */
    public static MemorySegment op_test$address() {
        return op_test.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int op_test(OpusHead *_head, const unsigned char *_initial_data, size_t _initial_bytes)
     * }
     */
    public static int op_test(MemorySegment _head, MemorySegment _initial_data, long _initial_bytes) {
        var mh$ = op_test.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("op_test", _head, _initial_data, _initial_bytes);
            }
            return (int) mh$.invokeExact(_head, _initial_data, _initial_bytes);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class op_open_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("op_open_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * OggOpusFile *op_open_file(const char *_path, int *_error)
     * }
     */
    public static FunctionDescriptor op_open_file$descriptor() {
        return op_open_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * OggOpusFile *op_open_file(const char *_path, int *_error)
     * }
     */
    public static MethodHandle op_open_file$handle() {
        return op_open_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * OggOpusFile *op_open_file(const char *_path, int *_error)
     * }
     */
    public static MemorySegment op_open_file$address() {
        return op_open_file.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * OggOpusFile *op_open_file(const char *_path, int *_error)
     * }
     */
    public static MemorySegment op_open_file(MemorySegment _path, MemorySegment _error) {
        var mh$ = op_open_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("op_open_file", _path, _error);
            }
            return (MemorySegment) mh$.invokeExact(_path, _error);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class op_open_memory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("op_open_memory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * OggOpusFile *op_open_memory(const unsigned char *_data, size_t _size, int *_error)
     * }
     */
    public static FunctionDescriptor op_open_memory$descriptor() {
        return op_open_memory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * OggOpusFile *op_open_memory(const unsigned char *_data, size_t _size, int *_error)
     * }
     */
    public static MethodHandle op_open_memory$handle() {
        return op_open_memory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * OggOpusFile *op_open_memory(const unsigned char *_data, size_t _size, int *_error)
     * }
     */
    public static MemorySegment op_open_memory$address() {
        return op_open_memory.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * OggOpusFile *op_open_memory(const unsigned char *_data, size_t _size, int *_error)
     * }
     */
    public static MemorySegment op_open_memory(MemorySegment _data, long _size, MemorySegment _error) {
        var mh$ = op_open_memory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("op_open_memory", _data, _size, _error);
            }
            return (MemorySegment) mh$.invokeExact(_data, _size, _error);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class op_vopen_url {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("op_vopen_url");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * OggOpusFile *op_vopen_url(const char *_url, int *_error, va_list _ap)
     * }
     */
    public static FunctionDescriptor op_vopen_url$descriptor() {
        return op_vopen_url.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * OggOpusFile *op_vopen_url(const char *_url, int *_error, va_list _ap)
     * }
     */
    public static MethodHandle op_vopen_url$handle() {
        return op_vopen_url.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * OggOpusFile *op_vopen_url(const char *_url, int *_error, va_list _ap)
     * }
     */
    public static MemorySegment op_vopen_url$address() {
        return op_vopen_url.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * OggOpusFile *op_vopen_url(const char *_url, int *_error, va_list _ap)
     * }
     */
    public static MemorySegment op_vopen_url(MemorySegment _url, MemorySegment _error, MemorySegment _ap) {
        var mh$ = op_vopen_url.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("op_vopen_url", _url, _error, _ap);
            }
            return (MemorySegment) mh$.invokeExact(_url, _error, _ap);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang = c
     * : * OggOpusFile *op_open_url(const char *_url, int *_error, ...)
     * }
     */
    public static class op_open_url {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("op_open_url");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private op_open_url(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang = c
         * : * OggOpusFile *op_open_url(const char *_url, int *_error, ...)
         * }
         */
        public static op_open_url makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new op_open_url(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment _url, MemorySegment _error, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("op_open_url", _url, _error, x2);
                }
                return (MemorySegment) spreader.invokeExact(_url, _error, x2);
            } catch (IllegalArgumentException | ClassCastException ex$) {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class op_open_callbacks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("op_open_callbacks");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * OggOpusFile *op_open_callbacks(void *_stream, const OpusFileCallbacks *_cb, const unsigned char *_initial_data, size_t _initial_bytes, int *_error)
     * }
     */
    public static FunctionDescriptor op_open_callbacks$descriptor() {
        return op_open_callbacks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * OggOpusFile *op_open_callbacks(void *_stream, const OpusFileCallbacks *_cb, const unsigned char *_initial_data, size_t _initial_bytes, int *_error)
     * }
     */
    public static MethodHandle op_open_callbacks$handle() {
        return op_open_callbacks.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * OggOpusFile *op_open_callbacks(void *_stream, const OpusFileCallbacks *_cb, const unsigned char *_initial_data, size_t _initial_bytes, int *_error)
     * }
     */
    public static MemorySegment op_open_callbacks$address() {
        return op_open_callbacks.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * OggOpusFile *op_open_callbacks(void *_stream, const OpusFileCallbacks *_cb, const unsigned char *_initial_data, size_t _initial_bytes, int *_error)
     * }
     */
    public static MemorySegment op_open_callbacks(MemorySegment _stream, MemorySegment _cb, MemorySegment _initial_data,
            long _initial_bytes, MemorySegment _error) {
        var mh$ = op_open_callbacks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("op_open_callbacks", _stream, _cb, _initial_data, _initial_bytes, _error);
            }
            return (MemorySegment) mh$.invokeExact(_stream, _cb, _initial_data, _initial_bytes, _error);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class op_test_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("op_test_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * OggOpusFile *op_test_file(const char *_path, int *_error)
     * }
     */
    public static FunctionDescriptor op_test_file$descriptor() {
        return op_test_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * OggOpusFile *op_test_file(const char *_path, int *_error)
     * }
     */
    public static MethodHandle op_test_file$handle() {
        return op_test_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * OggOpusFile *op_test_file(const char *_path, int *_error)
     * }
     */
    public static MemorySegment op_test_file$address() {
        return op_test_file.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * OggOpusFile *op_test_file(const char *_path, int *_error)
     * }
     */
    public static MemorySegment op_test_file(MemorySegment _path, MemorySegment _error) {
        var mh$ = op_test_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("op_test_file", _path, _error);
            }
            return (MemorySegment) mh$.invokeExact(_path, _error);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class op_test_memory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("op_test_memory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * OggOpusFile *op_test_memory(const unsigned char *_data, size_t _size, int *_error)
     * }
     */
    public static FunctionDescriptor op_test_memory$descriptor() {
        return op_test_memory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * OggOpusFile *op_test_memory(const unsigned char *_data, size_t _size, int *_error)
     * }
     */
    public static MethodHandle op_test_memory$handle() {
        return op_test_memory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * OggOpusFile *op_test_memory(const unsigned char *_data, size_t _size, int *_error)
     * }
     */
    public static MemorySegment op_test_memory$address() {
        return op_test_memory.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * OggOpusFile *op_test_memory(const unsigned char *_data, size_t _size, int *_error)
     * }
     */
    public static MemorySegment op_test_memory(MemorySegment _data, long _size, MemorySegment _error) {
        var mh$ = op_test_memory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("op_test_memory", _data, _size, _error);
            }
            return (MemorySegment) mh$.invokeExact(_data, _size, _error);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class op_vtest_url {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("op_vtest_url");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * OggOpusFile *op_vtest_url(const char *_url, int *_error, va_list _ap)
     * }
     */
    public static FunctionDescriptor op_vtest_url$descriptor() {
        return op_vtest_url.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * OggOpusFile *op_vtest_url(const char *_url, int *_error, va_list _ap)
     * }
     */
    public static MethodHandle op_vtest_url$handle() {
        return op_vtest_url.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * OggOpusFile *op_vtest_url(const char *_url, int *_error, va_list _ap)
     * }
     */
    public static MemorySegment op_vtest_url$address() {
        return op_vtest_url.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * OggOpusFile *op_vtest_url(const char *_url, int *_error, va_list _ap)
     * }
     */
    public static MemorySegment op_vtest_url(MemorySegment _url, MemorySegment _error, MemorySegment _ap) {
        var mh$ = op_vtest_url.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("op_vtest_url", _url, _error, _ap);
            }
            return (MemorySegment) mh$.invokeExact(_url, _error, _ap);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang = c
     * : * OggOpusFile *op_test_url(const char *_url, int *_error, ...)
     * }
     */
    public static class op_test_url {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("op_test_url");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private op_test_url(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang = c
         * : * OggOpusFile *op_test_url(const char *_url, int *_error, ...)
         * }
         */
        public static op_test_url makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new op_test_url(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment _url, MemorySegment _error, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("op_test_url", _url, _error, x2);
                }
                return (MemorySegment) spreader.invokeExact(_url, _error, x2);
            } catch (IllegalArgumentException | ClassCastException ex$) {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class op_test_callbacks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("op_test_callbacks");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * OggOpusFile *op_test_callbacks(void *_stream, const OpusFileCallbacks *_cb, const unsigned char *_initial_data, size_t _initial_bytes, int *_error)
     * }
     */
    public static FunctionDescriptor op_test_callbacks$descriptor() {
        return op_test_callbacks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * OggOpusFile *op_test_callbacks(void *_stream, const OpusFileCallbacks *_cb, const unsigned char *_initial_data, size_t _initial_bytes, int *_error)
     * }
     */
    public static MethodHandle op_test_callbacks$handle() {
        return op_test_callbacks.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * OggOpusFile *op_test_callbacks(void *_stream, const OpusFileCallbacks *_cb, const unsigned char *_initial_data, size_t _initial_bytes, int *_error)
     * }
     */
    public static MemorySegment op_test_callbacks$address() {
        return op_test_callbacks.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * OggOpusFile *op_test_callbacks(void *_stream, const OpusFileCallbacks *_cb, const unsigned char *_initial_data, size_t _initial_bytes, int *_error)
     * }
     */
    public static MemorySegment op_test_callbacks(MemorySegment _stream, MemorySegment _cb, MemorySegment _initial_data,
            long _initial_bytes, MemorySegment _error) {
        var mh$ = op_test_callbacks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("op_test_callbacks", _stream, _cb, _initial_data, _initial_bytes, _error);
            }
            return (MemorySegment) mh$.invokeExact(_stream, _cb, _initial_data, _initial_bytes, _error);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class op_test_open {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("op_test_open");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int op_test_open(OggOpusFile *_of)
     * }
     */
    public static FunctionDescriptor op_test_open$descriptor() {
        return op_test_open.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int op_test_open(OggOpusFile *_of)
     * }
     */
    public static MethodHandle op_test_open$handle() {
        return op_test_open.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int op_test_open(OggOpusFile *_of)
     * }
     */
    public static MemorySegment op_test_open$address() {
        return op_test_open.ADDR;
    }

    /**
     * {@snippet lang = c : * int op_test_open(OggOpusFile *_of)
     * }
     */
    public static int op_test_open(MemorySegment _of) {
        var mh$ = op_test_open.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("op_test_open", _of);
            }
            return (int) mh$.invokeExact(_of);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class op_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("op_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * void op_free(OggOpusFile *_of)
     * }
     */
    public static FunctionDescriptor op_free$descriptor() {
        return op_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * void op_free(OggOpusFile *_of)
     * }
     */
    public static MethodHandle op_free$handle() {
        return op_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * void op_free(OggOpusFile *_of)
     * }
     */
    public static MemorySegment op_free$address() {
        return op_free.ADDR;
    }

    /**
     * {@snippet lang = c : * void op_free(OggOpusFile *_of)
     * }
     */
    public static void op_free(MemorySegment _of) {
        var mh$ = op_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("op_free", _of);
            }
            mh$.invokeExact(_of);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class op_seekable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("op_seekable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int op_seekable(const OggOpusFile *_of)
     * }
     */
    public static FunctionDescriptor op_seekable$descriptor() {
        return op_seekable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int op_seekable(const OggOpusFile *_of)
     * }
     */
    public static MethodHandle op_seekable$handle() {
        return op_seekable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int op_seekable(const OggOpusFile *_of)
     * }
     */
    public static MemorySegment op_seekable$address() {
        return op_seekable.ADDR;
    }

    /**
     * {@snippet lang = c : * int op_seekable(const OggOpusFile *_of)
     * }
     */
    public static int op_seekable(MemorySegment _of) {
        var mh$ = op_seekable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("op_seekable", _of);
            }
            return (int) mh$.invokeExact(_of);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class op_link_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("op_link_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int op_link_count(const OggOpusFile *_of)
     * }
     */
    public static FunctionDescriptor op_link_count$descriptor() {
        return op_link_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int op_link_count(const OggOpusFile *_of)
     * }
     */
    public static MethodHandle op_link_count$handle() {
        return op_link_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int op_link_count(const OggOpusFile *_of)
     * }
     */
    public static MemorySegment op_link_count$address() {
        return op_link_count.ADDR;
    }

    /**
     * {@snippet lang = c : * int op_link_count(const OggOpusFile *_of)
     * }
     */
    public static int op_link_count(MemorySegment _of) {
        var mh$ = op_link_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("op_link_count", _of);
            }
            return (int) mh$.invokeExact(_of);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class op_serialno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("op_serialno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * opus_uint32 op_serialno(const OggOpusFile *_of, int _li)
     * }
     */
    public static FunctionDescriptor op_serialno$descriptor() {
        return op_serialno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * opus_uint32 op_serialno(const OggOpusFile *_of, int _li)
     * }
     */
    public static MethodHandle op_serialno$handle() {
        return op_serialno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * opus_uint32 op_serialno(const OggOpusFile *_of, int _li)
     * }
     */
    public static MemorySegment op_serialno$address() {
        return op_serialno.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * opus_uint32 op_serialno(const OggOpusFile *_of, int _li)
     * }
     */
    public static int op_serialno(MemorySegment _of, int _li) {
        var mh$ = op_serialno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("op_serialno", _of, _li);
            }
            return (int) mh$.invokeExact(_of, _li);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class op_channel_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("op_channel_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int op_channel_count(const OggOpusFile *_of, int _li)
     * }
     */
    public static FunctionDescriptor op_channel_count$descriptor() {
        return op_channel_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int op_channel_count(const OggOpusFile *_of, int _li)
     * }
     */
    public static MethodHandle op_channel_count$handle() {
        return op_channel_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int op_channel_count(const OggOpusFile *_of, int _li)
     * }
     */
    public static MemorySegment op_channel_count$address() {
        return op_channel_count.ADDR;
    }

    /**
     * {@snippet lang = c : * int op_channel_count(const OggOpusFile *_of, int _li)
     * }
     */
    public static int op_channel_count(MemorySegment _of, int _li) {
        var mh$ = op_channel_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("op_channel_count", _of, _li);
            }
            return (int) mh$.invokeExact(_of, _li);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class op_raw_total {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("op_raw_total");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * long long op_raw_total(const OggOpusFile *_of, int _li)
     * }
     */
    public static FunctionDescriptor op_raw_total$descriptor() {
        return op_raw_total.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * long long op_raw_total(const OggOpusFile *_of, int _li)
     * }
     */
    public static MethodHandle op_raw_total$handle() {
        return op_raw_total.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * long long op_raw_total(const OggOpusFile *_of, int _li)
     * }
     */
    public static MemorySegment op_raw_total$address() {
        return op_raw_total.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * long long op_raw_total(const OggOpusFile *_of, int _li)
     * }
     */
    public static long op_raw_total(MemorySegment _of, int _li) {
        var mh$ = op_raw_total.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("op_raw_total", _of, _li);
            }
            return (long) mh$.invokeExact(_of, _li);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class op_pcm_total {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("op_pcm_total");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * ogg_int64_t op_pcm_total(const OggOpusFile *_of, int _li)
     * }
     */
    public static FunctionDescriptor op_pcm_total$descriptor() {
        return op_pcm_total.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * ogg_int64_t op_pcm_total(const OggOpusFile *_of, int _li)
     * }
     */
    public static MethodHandle op_pcm_total$handle() {
        return op_pcm_total.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * ogg_int64_t op_pcm_total(const OggOpusFile *_of, int _li)
     * }
     */
    public static MemorySegment op_pcm_total$address() {
        return op_pcm_total.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * ogg_int64_t op_pcm_total(const OggOpusFile *_of, int _li)
     * }
     */
    public static long op_pcm_total(MemorySegment _of, int _li) {
        var mh$ = op_pcm_total.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("op_pcm_total", _of, _li);
            }
            return (long) mh$.invokeExact(_of, _li);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class op_head {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("op_head");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * const OpusHead *op_head(const OggOpusFile *_of, int _li)
     * }
     */
    public static FunctionDescriptor op_head$descriptor() {
        return op_head.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * const OpusHead *op_head(const OggOpusFile *_of, int _li)
     * }
     */
    public static MethodHandle op_head$handle() {
        return op_head.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * const OpusHead *op_head(const OggOpusFile *_of, int _li)
     * }
     */
    public static MemorySegment op_head$address() {
        return op_head.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * const OpusHead *op_head(const OggOpusFile *_of, int _li)
     * }
     */
    public static MemorySegment op_head(MemorySegment _of, int _li) {
        var mh$ = op_head.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("op_head", _of, _li);
            }
            return (MemorySegment) mh$.invokeExact(_of, _li);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class op_tags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("op_tags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * const OpusTags *op_tags(const OggOpusFile *_of, int _li)
     * }
     */
    public static FunctionDescriptor op_tags$descriptor() {
        return op_tags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * const OpusTags *op_tags(const OggOpusFile *_of, int _li)
     * }
     */
    public static MethodHandle op_tags$handle() {
        return op_tags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * const OpusTags *op_tags(const OggOpusFile *_of, int _li)
     * }
     */
    public static MemorySegment op_tags$address() {
        return op_tags.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * const OpusTags *op_tags(const OggOpusFile *_of, int _li)
     * }
     */
    public static MemorySegment op_tags(MemorySegment _of, int _li) {
        var mh$ = op_tags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("op_tags", _of, _li);
            }
            return (MemorySegment) mh$.invokeExact(_of, _li);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class op_current_link {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("op_current_link");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * int op_current_link(const OggOpusFile *_of)
     * }
     */
    public static FunctionDescriptor op_current_link$descriptor() {
        return op_current_link.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * int op_current_link(const OggOpusFile *_of)
     * }
     */
    public static MethodHandle op_current_link$handle() {
        return op_current_link.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * int op_current_link(const OggOpusFile *_of)
     * }
     */
    public static MemorySegment op_current_link$address() {
        return op_current_link.ADDR;
    }

    /**
     * {@snippet lang = c : * int op_current_link(const OggOpusFile *_of)
     * }
     */
    public static int op_current_link(MemorySegment _of) {
        var mh$ = op_current_link.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("op_current_link", _of);
            }
            return (int) mh$.invokeExact(_of);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class op_bitrate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("op_bitrate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * opus_int32 op_bitrate(const OggOpusFile *_of, int _li)
     * }
     */
    public static FunctionDescriptor op_bitrate$descriptor() {
        return op_bitrate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * opus_int32 op_bitrate(const OggOpusFile *_of, int _li)
     * }
     */
    public static MethodHandle op_bitrate$handle() {
        return op_bitrate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * opus_int32 op_bitrate(const OggOpusFile *_of, int _li)
     * }
     */
    public static MemorySegment op_bitrate$address() {
        return op_bitrate.ADDR;
    }

    /**
     * {@snippet lang = c : * opus_int32 op_bitrate(const OggOpusFile *_of, int _li)
     * }
     */
    public static int op_bitrate(MemorySegment _of, int _li) {
        var mh$ = op_bitrate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("op_bitrate", _of, _li);
            }
            return (int) mh$.invokeExact(_of, _li);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class op_bitrate_instant {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("op_bitrate_instant");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * opus_int32 op_bitrate_instant(OggOpusFile *_of)
     * }
     */
    public static FunctionDescriptor op_bitrate_instant$descriptor() {
        return op_bitrate_instant.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * opus_int32 op_bitrate_instant(OggOpusFile *_of)
     * }
     */
    public static MethodHandle op_bitrate_instant$handle() {
        return op_bitrate_instant.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * opus_int32 op_bitrate_instant(OggOpusFile *_of)
     * }
     */
    public static MemorySegment op_bitrate_instant$address() {
        return op_bitrate_instant.ADDR;
    }

    /**
     * {@snippet lang = c : * opus_int32 op_bitrate_instant(OggOpusFile *_of)
     * }
     */
    public static int op_bitrate_instant(MemorySegment _of) {
        var mh$ = op_bitrate_instant.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("op_bitrate_instant", _of);
            }
            return (int) mh$.invokeExact(_of);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class op_raw_tell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("op_raw_tell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * long long op_raw_tell(const OggOpusFile *_of)
     * }
     */
    public static FunctionDescriptor op_raw_tell$descriptor() {
        return op_raw_tell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * long long op_raw_tell(const OggOpusFile *_of)
     * }
     */
    public static MethodHandle op_raw_tell$handle() {
        return op_raw_tell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * long long op_raw_tell(const OggOpusFile *_of)
     * }
     */
    public static MemorySegment op_raw_tell$address() {
        return op_raw_tell.ADDR;
    }

    /**
     * {@snippet lang = c : * long long op_raw_tell(const OggOpusFile *_of)
     * }
     */
    public static long op_raw_tell(MemorySegment _of) {
        var mh$ = op_raw_tell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("op_raw_tell", _of);
            }
            return (long) mh$.invokeExact(_of);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class op_pcm_tell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_LONG_LONG,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("op_pcm_tell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * ogg_int64_t op_pcm_tell(const OggOpusFile *_of)
     * }
     */
    public static FunctionDescriptor op_pcm_tell$descriptor() {
        return op_pcm_tell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * ogg_int64_t op_pcm_tell(const OggOpusFile *_of)
     * }
     */
    public static MethodHandle op_pcm_tell$handle() {
        return op_pcm_tell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * ogg_int64_t op_pcm_tell(const OggOpusFile *_of)
     * }
     */
    public static MemorySegment op_pcm_tell$address() {
        return op_pcm_tell.ADDR;
    }

    /**
     * {@snippet lang = c : * ogg_int64_t op_pcm_tell(const OggOpusFile *_of)
     * }
     */
    public static long op_pcm_tell(MemorySegment _of) {
        var mh$ = op_pcm_tell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("op_pcm_tell", _of);
            }
            return (long) mh$.invokeExact(_of);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class op_raw_seek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_LONG_LONG);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("op_raw_seek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int op_raw_seek(OggOpusFile *_of, long long _byte_offset)
     * }
     */
    public static FunctionDescriptor op_raw_seek$descriptor() {
        return op_raw_seek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int op_raw_seek(OggOpusFile *_of, long long _byte_offset)
     * }
     */
    public static MethodHandle op_raw_seek$handle() {
        return op_raw_seek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int op_raw_seek(OggOpusFile *_of, long long _byte_offset)
     * }
     */
    public static MemorySegment op_raw_seek$address() {
        return op_raw_seek.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int op_raw_seek(OggOpusFile *_of, long long _byte_offset)
     * }
     */
    public static int op_raw_seek(MemorySegment _of, long _byte_offset) {
        var mh$ = op_raw_seek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("op_raw_seek", _of, _byte_offset);
            }
            return (int) mh$.invokeExact(_of, _byte_offset);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class op_pcm_seek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_LONG_LONG);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("op_pcm_seek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int op_pcm_seek(OggOpusFile *_of, ogg_int64_t _pcm_offset)
     * }
     */
    public static FunctionDescriptor op_pcm_seek$descriptor() {
        return op_pcm_seek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int op_pcm_seek(OggOpusFile *_of, ogg_int64_t _pcm_offset)
     * }
     */
    public static MethodHandle op_pcm_seek$handle() {
        return op_pcm_seek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int op_pcm_seek(OggOpusFile *_of, ogg_int64_t _pcm_offset)
     * }
     */
    public static MemorySegment op_pcm_seek$address() {
        return op_pcm_seek.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int op_pcm_seek(OggOpusFile *_of, ogg_int64_t _pcm_offset)
     * }
     */
    public static int op_pcm_seek(MemorySegment _of, long _pcm_offset) {
        var mh$ = op_pcm_seek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("op_pcm_seek", _of, _pcm_offset);
            }
            return (int) mh$.invokeExact(_of, _pcm_offset);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class op_set_decode_callback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("op_set_decode_callback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * void op_set_decode_callback(OggOpusFile *_of, op_decode_cb_func _decode_cb, void *_ctx)
     * }
     */
    public static FunctionDescriptor op_set_decode_callback$descriptor() {
        return op_set_decode_callback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * void op_set_decode_callback(OggOpusFile *_of, op_decode_cb_func _decode_cb, void *_ctx)
     * }
     */
    public static MethodHandle op_set_decode_callback$handle() {
        return op_set_decode_callback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * void op_set_decode_callback(OggOpusFile *_of, op_decode_cb_func _decode_cb, void *_ctx)
     * }
     */
    public static MemorySegment op_set_decode_callback$address() {
        return op_set_decode_callback.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * void op_set_decode_callback(OggOpusFile *_of, op_decode_cb_func _decode_cb, void *_ctx)
     * }
     */
    public static void op_set_decode_callback(MemorySegment _of, MemorySegment _decode_cb, MemorySegment _ctx) {
        var mh$ = op_set_decode_callback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("op_set_decode_callback", _of, _decode_cb, _ctx);
            }
            mh$.invokeExact(_of, _decode_cb, _ctx);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class op_set_gain_offset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("op_set_gain_offset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int op_set_gain_offset(OggOpusFile *_of, int _gain_type, opus_int32 _gain_offset_q8)
     * }
     */
    public static FunctionDescriptor op_set_gain_offset$descriptor() {
        return op_set_gain_offset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int op_set_gain_offset(OggOpusFile *_of, int _gain_type, opus_int32 _gain_offset_q8)
     * }
     */
    public static MethodHandle op_set_gain_offset$handle() {
        return op_set_gain_offset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int op_set_gain_offset(OggOpusFile *_of, int _gain_type, opus_int32 _gain_offset_q8)
     * }
     */
    public static MemorySegment op_set_gain_offset$address() {
        return op_set_gain_offset.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int op_set_gain_offset(OggOpusFile *_of, int _gain_type, opus_int32 _gain_offset_q8)
     * }
     */
    public static int op_set_gain_offset(MemorySegment _of, int _gain_type, int _gain_offset_q8) {
        var mh$ = op_set_gain_offset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("op_set_gain_offset", _of, _gain_type, _gain_offset_q8);
            }
            return (int) mh$.invokeExact(_of, _gain_type, _gain_offset_q8);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class op_set_dither_enabled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("op_set_dither_enabled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * void op_set_dither_enabled(OggOpusFile *_of, int _enabled)
     * }
     */
    public static FunctionDescriptor op_set_dither_enabled$descriptor() {
        return op_set_dither_enabled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * void op_set_dither_enabled(OggOpusFile *_of, int _enabled)
     * }
     */
    public static MethodHandle op_set_dither_enabled$handle() {
        return op_set_dither_enabled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * void op_set_dither_enabled(OggOpusFile *_of, int _enabled)
     * }
     */
    public static MemorySegment op_set_dither_enabled$address() {
        return op_set_dither_enabled.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * void op_set_dither_enabled(OggOpusFile *_of, int _enabled)
     * }
     */
    public static void op_set_dither_enabled(MemorySegment _of, int _enabled) {
        var mh$ = op_set_dither_enabled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("op_set_dither_enabled", _of, _enabled);
            }
            mh$.invokeExact(_of, _enabled);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class op_read {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("op_read");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int op_read(OggOpusFile *_of, opus_int16 *_pcm, int _buf_size, int *_li)
     * }
     */
    public static FunctionDescriptor op_read$descriptor() {
        return op_read.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int op_read(OggOpusFile *_of, opus_int16 *_pcm, int _buf_size, int *_li)
     * }
     */
    public static MethodHandle op_read$handle() {
        return op_read.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int op_read(OggOpusFile *_of, opus_int16 *_pcm, int _buf_size, int *_li)
     * }
     */
    public static MemorySegment op_read$address() {
        return op_read.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int op_read(OggOpusFile *_of, opus_int16 *_pcm, int _buf_size, int *_li)
     * }
     */
    public static int op_read(MemorySegment _of, MemorySegment _pcm, int _buf_size, MemorySegment _li) {
        var mh$ = op_read.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("op_read", _of, _pcm, _buf_size, _li);
            }
            return (int) mh$.invokeExact(_of, _pcm, _buf_size, _li);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class op_read_float {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT,
                opusfile_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("op_read_float");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int op_read_float(OggOpusFile *_of, float *_pcm, int _buf_size, int *_li)
     * }
     */
    public static FunctionDescriptor op_read_float$descriptor() {
        return op_read_float.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int op_read_float(OggOpusFile *_of, float *_pcm, int _buf_size, int *_li)
     * }
     */
    public static MethodHandle op_read_float$handle() {
        return op_read_float.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int op_read_float(OggOpusFile *_of, float *_pcm, int _buf_size, int *_li)
     * }
     */
    public static MemorySegment op_read_float$address() {
        return op_read_float.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int op_read_float(OggOpusFile *_of, float *_pcm, int _buf_size, int *_li)
     * }
     */
    public static int op_read_float(MemorySegment _of, MemorySegment _pcm, int _buf_size, MemorySegment _li) {
        var mh$ = op_read_float.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("op_read_float", _of, _pcm, _buf_size, _li);
            }
            return (int) mh$.invokeExact(_of, _pcm, _buf_size, _li);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class op_read_stereo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("op_read_stereo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int op_read_stereo(OggOpusFile *_of, opus_int16 *_pcm, int _buf_size)
     * }
     */
    public static FunctionDescriptor op_read_stereo$descriptor() {
        return op_read_stereo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int op_read_stereo(OggOpusFile *_of, opus_int16 *_pcm, int _buf_size)
     * }
     */
    public static MethodHandle op_read_stereo$handle() {
        return op_read_stereo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int op_read_stereo(OggOpusFile *_of, opus_int16 *_pcm, int _buf_size)
     * }
     */
    public static MemorySegment op_read_stereo$address() {
        return op_read_stereo.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int op_read_stereo(OggOpusFile *_of, opus_int16 *_pcm, int _buf_size)
     * }
     */
    public static int op_read_stereo(MemorySegment _of, MemorySegment _pcm, int _buf_size) {
        var mh$ = op_read_stereo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("op_read_stereo", _of, _pcm, _buf_size);
            }
            return (int) mh$.invokeExact(_of, _pcm, _buf_size);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class op_read_float_stereo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                opusfile_h.C_INT,
                opusfile_h.C_POINTER,
                opusfile_h.C_POINTER,
                opusfile_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("op_read_float_stereo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int op_read_float_stereo(OggOpusFile *_of, float *_pcm, int _buf_size)
     * }
     */
    public static FunctionDescriptor op_read_float_stereo$descriptor() {
        return op_read_float_stereo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int op_read_float_stereo(OggOpusFile *_of, float *_pcm, int _buf_size)
     * }
     */
    public static MethodHandle op_read_float_stereo$handle() {
        return op_read_float_stereo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int op_read_float_stereo(OggOpusFile *_of, float *_pcm, int _buf_size)
     * }
     */
    public static MemorySegment op_read_float_stereo$address() {
        return op_read_float_stereo.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int op_read_float_stereo(OggOpusFile *_of, float *_pcm, int _buf_size)
     * }
     */
    public static int op_read_float_stereo(MemorySegment _of, MemorySegment _pcm, int _buf_size) {
        var mh$ = op_read_float_stereo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("op_read_float_stereo", _of, _pcm, _buf_size);
            }
            return (int) mh$.invokeExact(_of, _pcm, _buf_size);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static final int _opusfile_h = (int) 1L;

    /**
     * {@snippet lang = c : * #define _opusfile_h 1
     * }
     */
    public static int _opusfile_h() {
        return _opusfile_h;
    }

    private static final int _VCRUNTIME_DISABLED_WARNINGS = (int) 4514L;

    /**
     * {@snippet lang = c : * #define _VCRUNTIME_DISABLED_WARNINGS 4514
     * }
     */
    public static int _VCRUNTIME_DISABLED_WARNINGS() {
        return _VCRUNTIME_DISABLED_WARNINGS;
    }

    private static final MemorySegment NULL = MemorySegment.ofAddress(0L);

    /**
     * {@snippet lang = c : * #define NULL (void*) 0
     * }
     */
    public static MemorySegment NULL() {
        return NULL;
    }

    private static final int _UCRT_DISABLED_WARNINGS = (int) 4324L;

    /**
     * {@snippet lang = c : * #define _UCRT_DISABLED_WARNINGS 4324
     * }
     */
    public static int _UCRT_DISABLED_WARNINGS() {
        return _UCRT_DISABLED_WARNINGS;
    }

    private static final long _TRUNCATE = -1L;

    /**
     * {@snippet lang = c : * #define _TRUNCATE -1
     * }
     */
    public static long _TRUNCATE() {
        return _TRUNCATE;
    }

    private static final long _CRT_SIZE_MAX = -1L;

    /**
     * {@snippet lang = c : * #define _CRT_SIZE_MAX -1
     * }
     */
    public static long _CRT_SIZE_MAX() {
        return _CRT_SIZE_MAX;
    }

    /**
     * {@snippet lang = c : * #define __FILEW__ "j"
     * }
     */
    public static MemorySegment __FILEW__() {
        class Holder {
            static final MemorySegment __FILEW__ = opusfile_h.LIBRARY_ARENA.allocateFrom("j");
        }
        return Holder.__FILEW__;
    }

    private static final int __STDC_SECURE_LIB__ = (int) 200411L;

    /**
     * {@snippet lang = c : * #define __STDC_SECURE_LIB__ 200411
     * }
     */
    public static int __STDC_SECURE_LIB__() {
        return __STDC_SECURE_LIB__;
    }

    private static final int __GOT_SECURE_LIB__ = (int) 200411L;

    /**
     * {@snippet lang = c : * #define __GOT_SECURE_LIB__ 200411
     * }
     */
    public static int __GOT_SECURE_LIB__() {
        return __GOT_SECURE_LIB__;
    }

    /**
     * {@snippet lang = c : * #define _CRT_INTERNAL_STDIO_SYMBOL_PREFIX ""
     * }
     */
    public static MemorySegment _CRT_INTERNAL_STDIO_SYMBOL_PREFIX() {
        class Holder {
            static final MemorySegment _CRT_INTERNAL_STDIO_SYMBOL_PREFIX = opusfile_h.LIBRARY_ARENA.allocateFrom("");
        }
        return Holder._CRT_INTERNAL_STDIO_SYMBOL_PREFIX;
    }

    private static final long _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION = 1L;

    /**
     * {@snippet lang = c
     * : * #define _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION 1
     * }
     */
    public static long _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION() {
        return _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION;
    }

    private static final long _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR = 2L;

    /**
     * {@snippet lang = c
     * : * #define _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR 2
     * }
     */
    public static long _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR() {
        return _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR;
    }

    private static final long _CRT_INTERNAL_PRINTF_LEGACY_WIDE_SPECIFIERS = 4L;

    /**
     * {@snippet lang = c : * #define _CRT_INTERNAL_PRINTF_LEGACY_WIDE_SPECIFIERS 4
     * }
     */
    public static long _CRT_INTERNAL_PRINTF_LEGACY_WIDE_SPECIFIERS() {
        return _CRT_INTERNAL_PRINTF_LEGACY_WIDE_SPECIFIERS;
    }

    private static final long _CRT_INTERNAL_PRINTF_LEGACY_MSVCRT_COMPATIBILITY = 8L;

    /**
     * {@snippet lang = c
     * : * #define _CRT_INTERNAL_PRINTF_LEGACY_MSVCRT_COMPATIBILITY 8
     * }
     */
    public static long _CRT_INTERNAL_PRINTF_LEGACY_MSVCRT_COMPATIBILITY() {
        return _CRT_INTERNAL_PRINTF_LEGACY_MSVCRT_COMPATIBILITY;
    }

    private static final long _CRT_INTERNAL_PRINTF_LEGACY_THREE_DIGIT_EXPONENTS = 16L;

    /**
     * {@snippet lang = c
     * : * #define _CRT_INTERNAL_PRINTF_LEGACY_THREE_DIGIT_EXPONENTS 16
     * }
     */
    public static long _CRT_INTERNAL_PRINTF_LEGACY_THREE_DIGIT_EXPONENTS() {
        return _CRT_INTERNAL_PRINTF_LEGACY_THREE_DIGIT_EXPONENTS;
    }

    private static final long _CRT_INTERNAL_PRINTF_STANDARD_ROUNDING = 32L;

    /**
     * {@snippet lang = c : * #define _CRT_INTERNAL_PRINTF_STANDARD_ROUNDING 32
     * }
     */
    public static long _CRT_INTERNAL_PRINTF_STANDARD_ROUNDING() {
        return _CRT_INTERNAL_PRINTF_STANDARD_ROUNDING;
    }

    private static final long _CRT_INTERNAL_SCANF_SECURECRT = 1L;

    /**
     * {@snippet lang = c : * #define _CRT_INTERNAL_SCANF_SECURECRT 1
     * }
     */
    public static long _CRT_INTERNAL_SCANF_SECURECRT() {
        return _CRT_INTERNAL_SCANF_SECURECRT;
    }

    private static final long _CRT_INTERNAL_SCANF_LEGACY_WIDE_SPECIFIERS = 2L;

    /**
     * {@snippet lang = c : * #define _CRT_INTERNAL_SCANF_LEGACY_WIDE_SPECIFIERS 2
     * }
     */
    public static long _CRT_INTERNAL_SCANF_LEGACY_WIDE_SPECIFIERS() {
        return _CRT_INTERNAL_SCANF_LEGACY_WIDE_SPECIFIERS;
    }

    private static final long _CRT_INTERNAL_SCANF_LEGACY_MSVCRT_COMPATIBILITY = 4L;

    /**
     * {@snippet lang = c
     * : * #define _CRT_INTERNAL_SCANF_LEGACY_MSVCRT_COMPATIBILITY 4
     * }
     */
    public static long _CRT_INTERNAL_SCANF_LEGACY_MSVCRT_COMPATIBILITY() {
        return _CRT_INTERNAL_SCANF_LEGACY_MSVCRT_COMPATIBILITY;
    }

    private static final short WEOF = (short) 65535L;

    /**
     * {@snippet lang = c : * #define WEOF 65535
     * }
     */
    public static short WEOF() {
        return WEOF;
    }

    private static final int _NFILE = (int) 512L;

    /**
     * {@snippet lang = c : * #define _NFILE 512
     * }
     */
    public static int _NFILE() {
        return _NFILE;
    }

    private static final int EOF = (int) -1L;

    /**
     * {@snippet lang = c : * #define EOF -1
     * }
     */
    public static int EOF() {
        return EOF;
    }

    private static final int L_tmpnam_s = (int) 260L;

    /**
     * {@snippet lang = c : * #define L_tmpnam_s 260
     * }
     */
    public static int L_tmpnam_s() {
        return L_tmpnam_s;
    }

    private static final int TMP_MAX = (int) 2147483647L;

    /**
     * {@snippet lang = c : * #define TMP_MAX 2147483647
     * }
     */
    public static int TMP_MAX() {
        return TMP_MAX;
    }

    private static final int TMP_MAX_S = (int) 2147483647L;

    /**
     * {@snippet lang = c : * #define TMP_MAX_S 2147483647
     * }
     */
    public static int TMP_MAX_S() {
        return TMP_MAX_S;
    }

    private static final int _TMP_MAX_S = (int) 2147483647L;

    /**
     * {@snippet lang = c : * #define _TMP_MAX_S 2147483647
     * }
     */
    public static int _TMP_MAX_S() {
        return _TMP_MAX_S;
    }

    private static final int SYS_OPEN = (int) 20L;

    /**
     * {@snippet lang = c : * #define SYS_OPEN 20
     * }
     */
    public static int SYS_OPEN() {
        return SYS_OPEN;
    }

    private static final int INT8_MIN = (int) -128L;

    /**
     * {@snippet lang = c : * #define INT8_MIN -128
     * }
     */
    public static int INT8_MIN() {
        return INT8_MIN;
    }

    private static final int INT16_MIN = (int) -32768L;

    /**
     * {@snippet lang = c : * #define INT16_MIN -32768
     * }
     */
    public static int INT16_MIN() {
        return INT16_MIN;
    }

    private static final int INT32_MIN = (int) -2147483648L;

    /**
     * {@snippet lang = c : * #define INT32_MIN -2147483648
     * }
     */
    public static int INT32_MIN() {
        return INT32_MIN;
    }

    private static final long INT64_MIN = -9223372036854775808L;

    /**
     * {@snippet lang = c : * #define INT64_MIN -9223372036854775808
     * }
     */
    public static long INT64_MIN() {
        return INT64_MIN;
    }

    private static final byte INT8_MAX = (byte) 127L;

    /**
     * {@snippet lang = c : * #define INT8_MAX 127
     * }
     */
    public static byte INT8_MAX() {
        return INT8_MAX;
    }

    private static final short INT16_MAX = (short) 32767L;

    /**
     * {@snippet lang = c : * #define INT16_MAX 32767
     * }
     */
    public static short INT16_MAX() {
        return INT16_MAX;
    }

    private static final int INT32_MAX = (int) 2147483647L;

    /**
     * {@snippet lang = c : * #define INT32_MAX 2147483647
     * }
     */
    public static int INT32_MAX() {
        return INT32_MAX;
    }

    private static final long INT64_MAX = 9223372036854775807L;

    /**
     * {@snippet lang = c : * #define INT64_MAX 9223372036854775807
     * }
     */
    public static long INT64_MAX() {
        return INT64_MAX;
    }

    private static final byte UINT8_MAX = (byte) 255L;

    /**
     * {@snippet lang = c : * #define UINT8_MAX 255
     * }
     */
    public static byte UINT8_MAX() {
        return UINT8_MAX;
    }

    private static final short UINT16_MAX = (short) 65535L;

    /**
     * {@snippet lang = c : * #define UINT16_MAX 65535
     * }
     */
    public static short UINT16_MAX() {
        return UINT16_MAX;
    }

    private static final int UINT32_MAX = (int) 4294967295L;

    /**
     * {@snippet lang = c : * #define UINT32_MAX 4294967295
     * }
     */
    public static int UINT32_MAX() {
        return UINT32_MAX;
    }

    private static final long UINT64_MAX = -1L;

    /**
     * {@snippet lang = c : * #define UINT64_MAX -1
     * }
     */
    public static long UINT64_MAX() {
        return UINT64_MAX;
    }

    private static final int INT_LEAST8_MIN = (int) -128L;

    /**
     * {@snippet lang = c : * #define INT_LEAST8_MIN -128
     * }
     */
    public static int INT_LEAST8_MIN() {
        return INT_LEAST8_MIN;
    }

    private static final int INT_LEAST16_MIN = (int) -32768L;

    /**
     * {@snippet lang = c : * #define INT_LEAST16_MIN -32768
     * }
     */
    public static int INT_LEAST16_MIN() {
        return INT_LEAST16_MIN;
    }

    private static final int INT_LEAST32_MIN = (int) -2147483648L;

    /**
     * {@snippet lang = c : * #define INT_LEAST32_MIN -2147483648
     * }
     */
    public static int INT_LEAST32_MIN() {
        return INT_LEAST32_MIN;
    }

    private static final long INT_LEAST64_MIN = -9223372036854775808L;

    /**
     * {@snippet lang = c : * #define INT_LEAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_LEAST64_MIN() {
        return INT_LEAST64_MIN;
    }

    private static final byte INT_LEAST8_MAX = (byte) 127L;

    /**
     * {@snippet lang = c : * #define INT_LEAST8_MAX 127
     * }
     */
    public static byte INT_LEAST8_MAX() {
        return INT_LEAST8_MAX;
    }

    private static final short INT_LEAST16_MAX = (short) 32767L;

    /**
     * {@snippet lang = c : * #define INT_LEAST16_MAX 32767
     * }
     */
    public static short INT_LEAST16_MAX() {
        return INT_LEAST16_MAX;
    }

    private static final int INT_LEAST32_MAX = (int) 2147483647L;

    /**
     * {@snippet lang = c : * #define INT_LEAST32_MAX 2147483647
     * }
     */
    public static int INT_LEAST32_MAX() {
        return INT_LEAST32_MAX;
    }

    private static final long INT_LEAST64_MAX = 9223372036854775807L;

    /**
     * {@snippet lang = c : * #define INT_LEAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_LEAST64_MAX() {
        return INT_LEAST64_MAX;
    }

    private static final byte UINT_LEAST8_MAX = (byte) 255L;

    /**
     * {@snippet lang = c : * #define UINT_LEAST8_MAX 255
     * }
     */
    public static byte UINT_LEAST8_MAX() {
        return UINT_LEAST8_MAX;
    }

    private static final short UINT_LEAST16_MAX = (short) 65535L;

    /**
     * {@snippet lang = c : * #define UINT_LEAST16_MAX 65535
     * }
     */
    public static short UINT_LEAST16_MAX() {
        return UINT_LEAST16_MAX;
    }

    private static final int UINT_LEAST32_MAX = (int) 4294967295L;

    /**
     * {@snippet lang = c : * #define UINT_LEAST32_MAX 4294967295
     * }
     */
    public static int UINT_LEAST32_MAX() {
        return UINT_LEAST32_MAX;
    }

    private static final long UINT_LEAST64_MAX = -1L;

    /**
     * {@snippet lang = c : * #define UINT_LEAST64_MAX -1
     * }
     */
    public static long UINT_LEAST64_MAX() {
        return UINT_LEAST64_MAX;
    }

    private static final int INT_FAST8_MIN = (int) -128L;

    /**
     * {@snippet lang = c : * #define INT_FAST8_MIN -128
     * }
     */
    public static int INT_FAST8_MIN() {
        return INT_FAST8_MIN;
    }

    private static final int INT_FAST16_MIN = (int) -2147483648L;

    /**
     * {@snippet lang = c : * #define INT_FAST16_MIN -2147483648
     * }
     */
    public static int INT_FAST16_MIN() {
        return INT_FAST16_MIN;
    }

    private static final int INT_FAST32_MIN = (int) -2147483648L;

    /**
     * {@snippet lang = c : * #define INT_FAST32_MIN -2147483648
     * }
     */
    public static int INT_FAST32_MIN() {
        return INT_FAST32_MIN;
    }

    private static final long INT_FAST64_MIN = -9223372036854775808L;

    /**
     * {@snippet lang = c : * #define INT_FAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST64_MIN() {
        return INT_FAST64_MIN;
    }

    private static final byte INT_FAST8_MAX = (byte) 127L;

    /**
     * {@snippet lang = c : * #define INT_FAST8_MAX 127
     * }
     */
    public static byte INT_FAST8_MAX() {
        return INT_FAST8_MAX;
    }

    private static final int INT_FAST16_MAX = (int) 2147483647L;

    /**
     * {@snippet lang = c : * #define INT_FAST16_MAX 2147483647
     * }
     */
    public static int INT_FAST16_MAX() {
        return INT_FAST16_MAX;
    }

    private static final int INT_FAST32_MAX = (int) 2147483647L;

    /**
     * {@snippet lang = c : * #define INT_FAST32_MAX 2147483647
     * }
     */
    public static int INT_FAST32_MAX() {
        return INT_FAST32_MAX;
    }

    private static final long INT_FAST64_MAX = 9223372036854775807L;

    /**
     * {@snippet lang = c : * #define INT_FAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST64_MAX() {
        return INT_FAST64_MAX;
    }

    private static final byte UINT_FAST8_MAX = (byte) 255L;

    /**
     * {@snippet lang = c : * #define UINT_FAST8_MAX 255
     * }
     */
    public static byte UINT_FAST8_MAX() {
        return UINT_FAST8_MAX;
    }

    private static final int UINT_FAST16_MAX = (int) 4294967295L;

    /**
     * {@snippet lang = c : * #define UINT_FAST16_MAX 4294967295
     * }
     */
    public static int UINT_FAST16_MAX() {
        return UINT_FAST16_MAX;
    }

    private static final int UINT_FAST32_MAX = (int) 4294967295L;

    /**
     * {@snippet lang = c : * #define UINT_FAST32_MAX 4294967295
     * }
     */
    public static int UINT_FAST32_MAX() {
        return UINT_FAST32_MAX;
    }

    private static final long UINT_FAST64_MAX = -1L;

    /**
     * {@snippet lang = c : * #define UINT_FAST64_MAX -1
     * }
     */
    public static long UINT_FAST64_MAX() {
        return UINT_FAST64_MAX;
    }

    private static final long INTPTR_MIN = -9223372036854775808L;

    /**
     * {@snippet lang = c : * #define INTPTR_MIN -9223372036854775808
     * }
     */
    public static long INTPTR_MIN() {
        return INTPTR_MIN;
    }

    private static final long INTPTR_MAX = 9223372036854775807L;

    /**
     * {@snippet lang = c : * #define INTPTR_MAX 9223372036854775807
     * }
     */
    public static long INTPTR_MAX() {
        return INTPTR_MAX;
    }

    private static final long UINTPTR_MAX = -1L;

    /**
     * {@snippet lang = c : * #define UINTPTR_MAX -1
     * }
     */
    public static long UINTPTR_MAX() {
        return UINTPTR_MAX;
    }

    private static final long INTMAX_MIN = -9223372036854775808L;

    /**
     * {@snippet lang = c : * #define INTMAX_MIN -9223372036854775808
     * }
     */
    public static long INTMAX_MIN() {
        return INTMAX_MIN;
    }

    private static final long INTMAX_MAX = 9223372036854775807L;

    /**
     * {@snippet lang = c : * #define INTMAX_MAX 9223372036854775807
     * }
     */
    public static long INTMAX_MAX() {
        return INTMAX_MAX;
    }

    private static final long UINTMAX_MAX = -1L;

    /**
     * {@snippet lang = c : * #define UINTMAX_MAX -1
     * }
     */
    public static long UINTMAX_MAX() {
        return UINTMAX_MAX;
    }

    private static final long PTRDIFF_MIN = -9223372036854775808L;

    /**
     * {@snippet lang = c : * #define PTRDIFF_MIN -9223372036854775808
     * }
     */
    public static long PTRDIFF_MIN() {
        return PTRDIFF_MIN;
    }

    private static final long PTRDIFF_MAX = 9223372036854775807L;

    /**
     * {@snippet lang = c : * #define PTRDIFF_MAX 9223372036854775807
     * }
     */
    public static long PTRDIFF_MAX() {
        return PTRDIFF_MAX;
    }

    private static final long SIZE_MAX = -1L;

    /**
     * {@snippet lang = c : * #define SIZE_MAX -1
     * }
     */
    public static long SIZE_MAX() {
        return SIZE_MAX;
    }

    private static final int SIG_ATOMIC_MIN = (int) -2147483648L;

    /**
     * {@snippet lang = c : * #define SIG_ATOMIC_MIN -2147483648
     * }
     */
    public static int SIG_ATOMIC_MIN() {
        return SIG_ATOMIC_MIN;
    }

    private static final int SIG_ATOMIC_MAX = (int) 2147483647L;

    /**
     * {@snippet lang = c : * #define SIG_ATOMIC_MAX 2147483647
     * }
     */
    public static int SIG_ATOMIC_MAX() {
        return SIG_ATOMIC_MAX;
    }

    private static final int OPUS_BAD_ARG = (int) -1L;

    /**
     * {@snippet lang = c : * #define OPUS_BAD_ARG -1
     * }
     */
    public static int OPUS_BAD_ARG() {
        return OPUS_BAD_ARG;
    }

    private static final int OPUS_BUFFER_TOO_SMALL = (int) -2L;

    /**
     * {@snippet lang = c : * #define OPUS_BUFFER_TOO_SMALL -2
     * }
     */
    public static int OPUS_BUFFER_TOO_SMALL() {
        return OPUS_BUFFER_TOO_SMALL;
    }

    private static final int OPUS_INTERNAL_ERROR = (int) -3L;

    /**
     * {@snippet lang = c : * #define OPUS_INTERNAL_ERROR -3
     * }
     */
    public static int OPUS_INTERNAL_ERROR() {
        return OPUS_INTERNAL_ERROR;
    }

    private static final int OPUS_INVALID_PACKET = (int) -4L;

    /**
     * {@snippet lang = c : * #define OPUS_INVALID_PACKET -4
     * }
     */
    public static int OPUS_INVALID_PACKET() {
        return OPUS_INVALID_PACKET;
    }

    private static final int OPUS_UNIMPLEMENTED = (int) -5L;

    /**
     * {@snippet lang = c : * #define OPUS_UNIMPLEMENTED -5
     * }
     */
    public static int OPUS_UNIMPLEMENTED() {
        return OPUS_UNIMPLEMENTED;
    }

    private static final int OPUS_INVALID_STATE = (int) -6L;

    /**
     * {@snippet lang = c : * #define OPUS_INVALID_STATE -6
     * }
     */
    public static int OPUS_INVALID_STATE() {
        return OPUS_INVALID_STATE;
    }

    private static final int OPUS_ALLOC_FAIL = (int) -7L;

    /**
     * {@snippet lang = c : * #define OPUS_ALLOC_FAIL -7
     * }
     */
    public static int OPUS_ALLOC_FAIL() {
        return OPUS_ALLOC_FAIL;
    }

    private static final int OPUS_AUTO = (int) -1000L;

    /**
     * {@snippet lang = c : * #define OPUS_AUTO -1000
     * }
     */
    public static int OPUS_AUTO() {
        return OPUS_AUTO;
    }

    private static final int OPUS_BITRATE_MAX = (int) -1L;

    /**
     * {@snippet lang = c : * #define OPUS_BITRATE_MAX -1
     * }
     */
    public static int OPUS_BITRATE_MAX() {
        return OPUS_BITRATE_MAX;
    }

    private static final int OP_FALSE = (int) -1L;

    /**
     * {@snippet lang = c : * #define OP_FALSE -1
     * }
     */
    public static int OP_FALSE() {
        return OP_FALSE;
    }

    private static final int OP_EOF = (int) -2L;

    /**
     * {@snippet lang = c : * #define OP_EOF -2
     * }
     */
    public static int OP_EOF() {
        return OP_EOF;
    }

    private static final int OP_HOLE = (int) -3L;

    /**
     * {@snippet lang = c : * #define OP_HOLE -3
     * }
     */
    public static int OP_HOLE() {
        return OP_HOLE;
    }

    private static final int OP_EREAD = (int) -128L;

    /**
     * {@snippet lang = c : * #define OP_EREAD -128
     * }
     */
    public static int OP_EREAD() {
        return OP_EREAD;
    }

    private static final int OP_EFAULT = (int) -129L;

    /**
     * {@snippet lang = c : * #define OP_EFAULT -129
     * }
     */
    public static int OP_EFAULT() {
        return OP_EFAULT;
    }

    private static final int OP_EIMPL = (int) -130L;

    /**
     * {@snippet lang = c : * #define OP_EIMPL -130
     * }
     */
    public static int OP_EIMPL() {
        return OP_EIMPL;
    }

    private static final int OP_EINVAL = (int) -131L;

    /**
     * {@snippet lang = c : * #define OP_EINVAL -131
     * }
     */
    public static int OP_EINVAL() {
        return OP_EINVAL;
    }

    private static final int OP_ENOTFORMAT = (int) -132L;

    /**
     * {@snippet lang = c : * #define OP_ENOTFORMAT -132
     * }
     */
    public static int OP_ENOTFORMAT() {
        return OP_ENOTFORMAT;
    }

    private static final int OP_EBADHEADER = (int) -133L;

    /**
     * {@snippet lang = c : * #define OP_EBADHEADER -133
     * }
     */
    public static int OP_EBADHEADER() {
        return OP_EBADHEADER;
    }

    private static final int OP_EVERSION = (int) -134L;

    /**
     * {@snippet lang = c : * #define OP_EVERSION -134
     * }
     */
    public static int OP_EVERSION() {
        return OP_EVERSION;
    }

    private static final int OP_ENOTAUDIO = (int) -135L;

    /**
     * {@snippet lang = c : * #define OP_ENOTAUDIO -135
     * }
     */
    public static int OP_ENOTAUDIO() {
        return OP_ENOTAUDIO;
    }

    private static final int OP_EBADPACKET = (int) -136L;

    /**
     * {@snippet lang = c : * #define OP_EBADPACKET -136
     * }
     */
    public static int OP_EBADPACKET() {
        return OP_EBADPACKET;
    }

    private static final int OP_EBADLINK = (int) -137L;

    /**
     * {@snippet lang = c : * #define OP_EBADLINK -137
     * }
     */
    public static int OP_EBADLINK() {
        return OP_EBADLINK;
    }

    private static final int OP_ENOSEEK = (int) -138L;

    /**
     * {@snippet lang = c : * #define OP_ENOSEEK -138
     * }
     */
    public static int OP_ENOSEEK() {
        return OP_ENOSEEK;
    }

    private static final int OP_EBADTIMESTAMP = (int) -139L;

    /**
     * {@snippet lang = c : * #define OP_EBADTIMESTAMP -139
     * }
     */
    public static int OP_EBADTIMESTAMP() {
        return OP_EBADTIMESTAMP;
    }

    private static final int OPUS_CHANNEL_COUNT_MAX = (int) 255L;

    /**
     * {@snippet lang = c : * #define OPUS_CHANNEL_COUNT_MAX 255
     * }
     */
    public static int OPUS_CHANNEL_COUNT_MAX() {
        return OPUS_CHANNEL_COUNT_MAX;
    }

    private static final int OP_PIC_FORMAT_UNKNOWN = (int) -1L;

    /**
     * {@snippet lang = c : * #define OP_PIC_FORMAT_UNKNOWN -1
     * }
     */
    public static int OP_PIC_FORMAT_UNKNOWN() {
        return OP_PIC_FORMAT_UNKNOWN;
    }

    private static final int OP_PIC_FORMAT_URL = (int) 0L;

    /**
     * {@snippet lang = c : * #define OP_PIC_FORMAT_URL 0
     * }
     */
    public static int OP_PIC_FORMAT_URL() {
        return OP_PIC_FORMAT_URL;
    }

    private static final int OP_PIC_FORMAT_JPEG = (int) 1L;

    /**
     * {@snippet lang = c : * #define OP_PIC_FORMAT_JPEG 1
     * }
     */
    public static int OP_PIC_FORMAT_JPEG() {
        return OP_PIC_FORMAT_JPEG;
    }

    private static final int OP_PIC_FORMAT_PNG = (int) 2L;

    /**
     * {@snippet lang = c : * #define OP_PIC_FORMAT_PNG 2
     * }
     */
    public static int OP_PIC_FORMAT_PNG() {
        return OP_PIC_FORMAT_PNG;
    }

    private static final int OP_PIC_FORMAT_GIF = (int) 3L;

    /**
     * {@snippet lang = c : * #define OP_PIC_FORMAT_GIF 3
     * }
     */
    public static int OP_PIC_FORMAT_GIF() {
        return OP_PIC_FORMAT_GIF;
    }

    private static final int OP_SSL_SKIP_CERTIFICATE_CHECK_REQUEST = (int) 6464L;

    /**
     * {@snippet lang = c : * #define OP_SSL_SKIP_CERTIFICATE_CHECK_REQUEST 6464
     * }
     */
    public static int OP_SSL_SKIP_CERTIFICATE_CHECK_REQUEST() {
        return OP_SSL_SKIP_CERTIFICATE_CHECK_REQUEST;
    }

    private static final int OP_HTTP_PROXY_HOST_REQUEST = (int) 6528L;

    /**
     * {@snippet lang = c : * #define OP_HTTP_PROXY_HOST_REQUEST 6528
     * }
     */
    public static int OP_HTTP_PROXY_HOST_REQUEST() {
        return OP_HTTP_PROXY_HOST_REQUEST;
    }

    private static final int OP_HTTP_PROXY_PORT_REQUEST = (int) 6592L;

    /**
     * {@snippet lang = c : * #define OP_HTTP_PROXY_PORT_REQUEST 6592
     * }
     */
    public static int OP_HTTP_PROXY_PORT_REQUEST() {
        return OP_HTTP_PROXY_PORT_REQUEST;
    }

    private static final int OP_HTTP_PROXY_USER_REQUEST = (int) 6656L;

    /**
     * {@snippet lang = c : * #define OP_HTTP_PROXY_USER_REQUEST 6656
     * }
     */
    public static int OP_HTTP_PROXY_USER_REQUEST() {
        return OP_HTTP_PROXY_USER_REQUEST;
    }

    private static final int OP_HTTP_PROXY_PASS_REQUEST = (int) 6720L;

    /**
     * {@snippet lang = c : * #define OP_HTTP_PROXY_PASS_REQUEST 6720
     * }
     */
    public static int OP_HTTP_PROXY_PASS_REQUEST() {
        return OP_HTTP_PROXY_PASS_REQUEST;
    }

    private static final int OP_GET_SERVER_INFO_REQUEST = (int) 6784L;

    /**
     * {@snippet lang = c : * #define OP_GET_SERVER_INFO_REQUEST 6784
     * }
     */
    public static int OP_GET_SERVER_INFO_REQUEST() {
        return OP_GET_SERVER_INFO_REQUEST;
    }

    private static final int OP_DEC_FORMAT_SHORT = (int) 7008L;

    /**
     * {@snippet lang = c : * #define OP_DEC_FORMAT_SHORT 7008
     * }
     */
    public static int OP_DEC_FORMAT_SHORT() {
        return OP_DEC_FORMAT_SHORT;
    }

    private static final int OP_DEC_FORMAT_FLOAT = (int) 7040L;

    /**
     * {@snippet lang = c : * #define OP_DEC_FORMAT_FLOAT 7040
     * }
     */
    public static int OP_DEC_FORMAT_FLOAT() {
        return OP_DEC_FORMAT_FLOAT;
    }

    private static final int OP_DEC_USE_DEFAULT = (int) 6720L;

    /**
     * {@snippet lang = c : * #define OP_DEC_USE_DEFAULT 6720
     * }
     */
    public static int OP_DEC_USE_DEFAULT() {
        return OP_DEC_USE_DEFAULT;
    }

    private static final int OP_HEADER_GAIN = (int) 0L;

    /**
     * {@snippet lang = c : * #define OP_HEADER_GAIN 0
     * }
     */
    public static int OP_HEADER_GAIN() {
        return OP_HEADER_GAIN;
    }

    private static final int OP_ALBUM_GAIN = (int) 3007L;

    /**
     * {@snippet lang = c : * #define OP_ALBUM_GAIN 3007
     * }
     */
    public static int OP_ALBUM_GAIN() {
        return OP_ALBUM_GAIN;
    }

    private static final int OP_TRACK_GAIN = (int) 3008L;

    /**
     * {@snippet lang = c : * #define OP_TRACK_GAIN 3008
     * }
     */
    public static int OP_TRACK_GAIN() {
        return OP_TRACK_GAIN;
    }

    private static final int OP_ABSOLUTE_GAIN = (int) 3009L;

    /**
     * {@snippet lang = c : * #define OP_ABSOLUTE_GAIN 3009
     * }
     */
    public static int OP_ABSOLUTE_GAIN() {
        return OP_ABSOLUTE_GAIN;
    }
}
